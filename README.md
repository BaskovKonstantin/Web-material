## 1. Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.

HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP  лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser).

Браузер (клиент) отправляет серверу HTTP запросы, а сервер отправляет клиенту HTTP ответы. Эти запросы и ответы оформляются по определенным правилам. Есть, что-то вроде синтаксиса, как и в какой последовательности, должно быть написано. Должна быть строго определенная структура.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.

1. строка запроса (Request Line) - указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
2. заголовки (Message Headers) - описывают тело сообщений, передают различные параметры и др. сведения и информацию.

Пустая строка (разделитель)

3. тело сообщения (Entity Body) – сами данные, которые передаются в запросе.
*необязательный параметр*

Когда мы получаем ответный запрос от сервера, тело сообщения, чаще всего представляет собой содержимое веб-страницы. Но, при запросах к серверу, оно тоже может иногда присутствовать, например, когда мы передаем данные, которые заполнили в форме обратной связи на сервер.

#### Методы запросов:

- Метода GET в HTTP используется для получения информации от сервера по заданному URI (URI в HTTP). Запросы клиентов, использующие метод GET должны получать только данные и не должны никак влиять на эти данные.
Сервер кэширует ответы

- HTTP метод HEAD работает точно так же, как GET, но в ответ сервер посылает только заголовки и статусную строку без тела HTTP сообщения. (используется для получения метаинформации об объекте без пересылки тела HTTP сообщения)
(Метод HEAD часто используется для тестирования HTTP соединений и достижимости узлов и ресурсов, так как нет необходимости гонять по сети содержимое, тестирование HTTP методом HEAD производится гораздо быстрее.)
Сервер может кэшировать ответы

- HTTP метод POST используется для отправки данных на сервер, например, из HTML форм, которые заполняет посетитель сайта.
Сервер НЕ кэширует ответы

- HTTP метод PUT используется для загрузки содержимого запроса на указанный в этом же запросе URI. (метод POST и метод PUT выполняют совершенно разные операции. Метод POST обращается к ресурсу (странице или коду), которая содержит механизмы обработки сообщения метода POST, а вот метод PUT создает какой-то объект по URI, указанному в сообщение с HTTP методом PUT.)

- HTTP метод DELETE удаляет указанный в URI ресурс.

- HTTP метод CONNECT преобразует существующее соединение в тоннель. (HTTP метод CONNECT используется для преобразования HTTP соединения в прозрачный TCP/IP туннель.  Пожалуй, это всё, что можно сказать про HTTP метод CONNECT в контексте рассматриваемого протокола, разве что стоит добавить, что данный метод используется в основном для шифрования соединения (не путайте с кодировкой сообщений).)

- HTTP метод OPTIONS используется для получения параметров текущего HTTP соединения.

- HTTP метод TRACE создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи. (HTTP метод TRACE применяется для диагностики, он позволяет видеть клиенту, что происходит в каждом звене цепочки между компьютером клиента и конечным получателем)

#### Коды ответов сервера:

- Код ответа (состояния) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:

Информационные 100 - 199

Успешные 200 - 299

Перенаправления 300 - 399

Клиентские ошибки 400 - 499

Серверные ошибки 500 - 599

#### Заголовки запросов и ответов:

##### Поля общего(general-header) заголовка (он общий как для запросов так и для ответов):

Date:

Указывает дату запроса,например:
Date: Sun, 20 Nov 1994 08:12:31 GMT

MIME-version:

Указывает версию MIME (по умолчанию 1.0)
MIME-version: 1.0

Pragma:

Содержит указания для таких промежуточных агентов как прокси и шлюзы,
Pragma: no-cache

##### Поля относящиеся к запросу(Request-Header):

Authorization:

Содержит информацию аутентификации
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

From:

Браузер может посылать адрес пользователя серверу
From: quake@doom.ru

If-Modified-Since:

используется при методе GET ресурс возвращается ,если он был изменен с указаного момента, может использоваться при кешировании.
If-Modified-Since:Mon 15 Jul 1997 00:15:24 GMT

Referer:

Содержит URL предшествующего ресурса.
Referer: http://www.uic.nnov.ru/~paaa/index.html

User-Agent:

Програмное обеспечение клиента.
User-Agent: Mozilla/3.0

##### Заголовок информации сообщения (Entity-Header) применяется как в запросах так и в ответах (при этом некоторые поля только в ответах):

Allow: (в ответе сервера)

Список методов,поддерживаемых ресурсом.
Allow: GET, HEAD

Content-Encoding:

идентифицирует метод кодировки,которым был закодирован ресурс
Content-Encoding: x-gzip

Content-Length:

Длина тела сообщения
Content-Length: 102

Content-Type:
Содержит тип ресурса(MIME),для текстовых еще и кодировку символов(необязательно)

Content-Type: text/html; charset=windows-1251

Expires: (в ответе сервера)

Дата окончания действия ресурса,применяется в кешировании для запрета кеширования устаревших ресурсов (в ответе)
Expires: Tue, 24 Sep 1998 23:00:15 GMT

Last-Modified: (в ответе сервера)

Время последнего обновления ресурса
Last-Modified: Tue, 23 sep 1998 13:48:40 GMT

##### Другие поля:

Поля Accept: указывают серверу выдавать только указаные форматы данных,которые клиент может распознать.

Accept: text/html
Accept: text/plain
Accept: image/gif

Поле Host: служит для того , чтобы указать, к какому хосту идет обращение. Данное поле не входит в число обязательных. Однако оно является необходимым в тех случаях, когда одному физическому серверу соответствует несколько виртуальных хостов. В этом поле тогда указывается какой из виртуальных хостов имеется в виду.

Host: www.nnov.city.ru

##### Заголовок ответа состоит из полей:

Location:

Содержит URI ресурса,может быть использован для переключения клиента в другое место, если например ресурс был перемещен в другое место или на другой сервер.
Location: http://www.uic.nnov.ru/newlocation/index.html

Server:

Информация о програмном обеспечении сервера
Server: Apache/1.1

WWW-Autenticate:

Параметры аутентификации.
WWW-Autenticate: Basic realm="doomsday"

## 2. Язык разметки HTML. Особенности, основные теги и атрибуты тегов.

HTML (HyperText Markup Language) - язык разметки гипертекста - предназначен для создания Web-страниц.
Под гипертекстом в этом случае понимается текст, связанный с другими текстами указателями-ссылками.

HTML представляет собой достаточно простой набор кодов, которые описывают структуру документа. HTML позволяет выделить в тексте отдельные логические части (заголовки, абзацы, списки и т.д.), поместить на Web-страницу подготовленную фотографию или картинку, организовать на странице ссылки для связи с другими документами.

#### Каковы особенности языка HTML?
HTML расшифровывается как язык маркировки гипертекста. С его помощью создаются страницы в интернете. Но он не относится к программированию, а является лишь элементом, необходимым для форматирования документов.

Составными частями языка HTML называют теги. От них зависит то, как текст будет выглядеть на странице. Тег задает команду браузеру, с помощью которого происходит просмотр сайтов, он анализирует полученную информацию, преобразует ее и выдает готовый результат в виде форматированных подзаголовков, списков. Теги позволяют также вставлять ссылки, картинки, создавать таблицы на странице. 

#### Основные теги и атрибуты тегов.
- Тег (tag). Тег HTML это компонент, который командует Web- броузеру выполнить определенную задачу типа создания абзаца или вставки изображения.
- Атрибут (или аргумент). Атрибут HTML изменяет тег. Например, можно выровнять абзац или изображение внутри тега.
- Значение. Значения присваиваются атрибутам и определяют вносимые изменения. Например, если для тега используется атрибут выравнивания, то можно указать значение этого атрибута. Значения могут быть текстовыми, типа left или right, а также числовыми, как например ширина и высота изображения, где значения определяют размер изображения в пикселях.

##### Основные атрибуты HTML*
Существует четыре основных атрибута в HTML, которые могут использоваться для большинства html-элементов (хотя и не для всех):

-- id

Атрибут id html-тега может быть использован для однозначной идентификации любого элемента внутри html-страницы. Существуют две основные причины, по которым Вы можете использовать атрибут id для элемента:

 - Если элемент содержит атрибут id как уникальный идентификатор, то можно идентифицировать только этот элемент и его содержимое.
 - Если на веб-странице (или в таблице стилей) есть два элемента с одним и тем же именем, Вы можете использовать атрибут id для различения элементов, имеющих одно и то же имя.

-- title

Атрибут title — дает название элемента для элемента. Синтаксис для атрибута title аналогичен атрибуту id.

Поведение этого атрибута будет зависеть от элемента, который его несет, хотя он часто отображается как подсказка, когда курсор наводится на элемент или когда элемент загружается.

-- class

Атрибут class — используется для связывания элемента со списком стилей и задает класс элементу.

-- style

Атрибут style — позволяет указывать правила каскадной таблицы стилей (CSS) внутри элемента.

![GitHub Logo](/attributes.png)

## 3. Структура HTML-страницы. Объектная модель документа (DOM).

DOM – это объектное представление исходного HTML-документа, попытка преобразовать его структуру и содержимое в объектную модель, с которой смогли бы работать различные программы.

В ближайшем приближении DOM – это "дерево узлов" (node tree). У него единый корень, который разветвляется на множество дочерних ветвей, каждая из которых может ветвиться сама и заканчивается "листьями". Корень – это элемент html, а ветви – вложенные элементы.

Модификация с помощью JavaScript
DOM позволяет не только просматривать содержимое страницы, но и взаимодействовать с ним, изменять. Это не статичное отображение, а живой ресурс.

Например, с помощью JavaScript можно создать дополнительные элементы:

var newParagraph = document.createElement("p");
var paragraphContent = document.createTextNode("I'm new!");
newParagraph.appendChild(paragraphContent);
document.body.appendChild(newParagraph);

Document метод querySelector() возвращает первый элемент (Element) документа, который соответствует указанному селектору или группе селекторов. Если совпадений не найдено, возвращает значение null.

#### Основные характеристики объектной модели:

- основана на валидном HTML-коде;
- может быть модифицирована из JavaScript;
- не включает псевдоэлементы, созданные из CSS;
- включает скрытые элементы (display: none).

Объектная модель документа – очень полезная штука. Благодаря ей JavaScript может взаимодействовать со страницей, изменять ее содержимое, структуру и стили. Именно благодаря DOM вы можете отслеживать клиентские события.

DOM – понятие, специфичное для браузерной среды выполнения кода. Это не JavaScript, а лишь API, которым JavaScript может пользоваться.

## 4. HTML-формы. Задание метода HTTP-запроса. Правила размещения форм на страницах, виды полей ввода.

Форма предназначена для обмена данными между пользователем и сервером.

Задается с помощью тега <form> и могут содержать в себе атрибуты: action, содержищий URI обработчика формы (обязательный атрибут), method (по умолчанию, GET), enctype (тип кодирования), accept (MIME-типы для загрузки файлов), name, onsubmit/onreset (обработчик события submit/reset для скриптов), accept-character.
 
Виды полей:

- Кнопка <input>. Типы кнопок <submit>, <image>, <reset>, <button>.
- Checkbox.
- Radio.
- Select.
- Text и многострочный textarea.
- Password.
- Hidden (скрытое поле).
- File.
 
 ## 5. Каскадные таблицы стилей (CSS). Структура - правила, селекторы. Виды селекторов, особенности их применения. Приоритеты правил. Преимущества CSS перед непосредственным заданием стилей через атрибуты тегов.
 
 #### Каскадные таблицы стилей (CSS)
 
CSS (англ. Cascading Style Sheets — каскадные таблицы стилей) — технология описания внешнего вида документа, оформленного языком разметки.

Преимущественно используется как средство оформления веб-страниц в формате HTML и XHTML, но может применяться с любыми видами документов в формате XML, включая SVG и XUL.

Каскадные таблицы стилей используются создателями веб-страниц для задания цветов, шрифтов, расположения и других аспектов представления веб-документа. Основной целью разработки CSS являлось __разделение содержимого (написанного на HTML или другом языке разметки) и оформления документа (написанного на CSS)__. Это разделение может __увеличить доступность документа, предоставить большую гибкость и возможность управления его представлением, а также уменьшить сложность и повторяемость в структурном содержимом__. Кроме того, CSS __позволяет представлять один и тот же документ в различных стилях или методах вывода__, таких как экранное представление, печать, чтение голосом (специальным голосовым браузером или программой чтения с экрана), или при выводе устройствами, использующими шрифт Брайля.
 
Каскадные таблицы стилей (Cascading Style Sheets, CSS) — это стандарт, определяющий представление данных в браузере. Если HTML предоставляет информацию о структуре документа, то таблицы стилей сообщают как он должен выглядеть.

Стиль — это совокупность правил, применяемых к элементу гипертекста и определяющих способ его отображения. Стиль включает все типы элементов дизайна: шрифт, фон, текст, цвета ссылок, поля и расположение объектов на странице.

Таблица стилей — это совокупность стилей, применимых к гипертекстовому документу.

Каскадирование — это порядок применения различных стилей к веб-странице. Браузер, поддерживающий таблицы стилей, будет последовательно применять их в соответствии с приоритетом: сначала связанные, затем внедренные и, наконец, встроенные стили. Другой аспект каскадирования — наследование (inheritance), — означает, что если не указано иное, то конкретный стиль будет применен ко всем дочерним элементами гипертекстового документа. Например, если вы примените определенный цвет текста в теге <div>, то все теги внутри этого блока будут отображаться этим же цветом.

__Использование каскадных таблиц дает возможность разделить содержимое и его представление и гибко управлять отображением гипертекстовых документов путем изменения стилей__.

#### Структура - правила, селекторы

Таблицы стилей строятся в соответствии с определенным порядком (синтаксисом), в противном случае они не могут нормально работать. Таблицы стилей составляются из определенных частей (рис. 1):

https://iit-web-lectures.readthedocs.io/ru/latest/_images/css-rule.png
Рис. 1. Синтаксис описания стиля CSS

- Селектор (Selector). Селектор — это элемент, к которому будут применяться назначаемые стили. Это может быть тег, класс или идентификатор объекта гипертекстового документа.
- Свойство (Property). Свойство определяет одну или несколько характеристик селектора. Свойства задают формат отображения селектора: отступы, шрифты, выравнивание, размеры и т.д.
- Значение (Value). Значения — это фактические числовые или строковые константы, определяющие свойство селектора.
- Описание (Declaration). Совокупность свойств и их значений.
- Правило (Rule). Полное описание стиля (селектор + описание).

Таким образом, таблица стилей — это набор правил, задающих значения свойств селекторов, перечисленных в этой таблице. 

####  Виды селекторов, особенности их применения

- Селектор по элементу
p {color:#666; font-size:12px;}

- Селекторы классов 
p {color:#666; font-size:12px;}
p.redmal { color:#b50404; font-size:11px;}

- Селекторы по идентификатору 
p#sin { color:#548DD4; }

- Контекстный селектор
strong {color:#C00000;}

- Псевдоэлементы 
p { color:#666; font-size:14px;}
p:first-letter { color:#cc0000; font-size:36px;}

- Псевдоклассы 
a:link {color:#548DD4}
a:visited {color:#666666}
a:hover {color:#B1030D}
a:active {color:#92D050}

- Группировка селекторов
p, td, h1 {color:#cc0000; font-size:16px;}

#### Приоритеты правил

- Универсальный селектор — количество начисляемых баллов равно нулю (0).
- Селекторы тегов и псевдоэлементы — по одному (1) баллу за каждый.
- Селекторы атрибутов, классы и псевдоклассы — по десять (10) баллов за каждый.
- Идентификаторы — по сто (100) баллов за каждый идентификатор находящийся в селекторе.
- Атрибут style — встроенные стили не используют селекторов, а указываются непосредственно внутри тегов элементов, но при этом они имеют самый высокий приоритет исчисляемый тысячей (1000) баллов.

Правило !important используется в тех случаях, когда необходимо, чтобы конкретное свойство было обязательно применено к элементу вне зависимости от того, в каком селекторе и в каком месте CSS-кода оно находится, а также, невзирая на имеющиеся дубли. Общий синтаксис:

селектор { свойство: значение !important; }

1. Самый низкий приоритет имеют стили установленные в браузере по умолчанию, как например вертикальные поля у параграфов.
2. Более высокий приоритет получают обычные стили подключаемые пользователями.
3. Еще более высокий — авторские стили, то есть ваши.
4. Еще более высокий достается также авторским стилям, но у которых указан !important.
5. И наконец самый высокий приоритет получают стили пользователей с правилом !important. Это сделано для того, чтобы пользователи с ограниченными возможностями в любом случае могли изменить внешний вид страниц сайта под свои нужды.

## 6. LESS, Sass, SCSS. Ключевые особенности, сравнительные характеристики. Совместимость с браузерами, трансляция в "обычный" CSS.

### LESS

LESS - это динамический язык стилей, который является надстройкой над CSS (Поэтому любой CSS код будет валидный LESS). 

Приемущества LESS:
- Переменные (и области видимости переменных).
- Операции (в том числе и для управления цветом, т.е можно смешивать цвета: #941f1f + #222222).
- И другие функции для работы с цветом (осветление, затемнение и т.п.)
- Вложенность (можно вложить одно правило в другое, `article.post p {}` <=> `article.post { p{   }}`).
- Объединение аргуметов.

LESS-файл конвертируется в CSS при помощи js (для этого необходимо скачать less.js с сайта LESS).

```html
<script src="less.js" type="text/javascript"></script>
```

Затем можно привязывать файлы с расширением `.less`.

```html
<link rel="stylesheet/less" type="text/css" href="style.less">
```

### Sass

Sass - это метаязык на основе CSS, предназначенный для увеличения уровня абстракции CSS кода и упрощения файлов каскадных таблиц стилей. 

Приемущества Sass:
- Вложенные правила.
- Переменные.
- Возможность создавать миксины, позволяющие создавать многоразовые CSS-правила - группы деклараций, для многократного использования. *(LESS в это не может)*
- Расширения. Одиночный селектор может быть расширен больше, чес одним селектором с помошью `@extend`.
- Есть логика. (if/then/for). *(Этого в LESS тоже нет)*

*Не может компилироватся на сервере в CSS (LESS использует js).* 

Браузер не распознает файлы Sass, так что сначала их нужно скомпилировать в обычный CSS.

### SCSS

SCSS — "диалект" языка SASS. Отличие SCSS от SASS заключается в том, что SCSS больше похож на обычный CSS код. 

- `@import` - @import "template" подключит template.scss.
- Вложенность.
- $переменные.
- Математика чисел и цветов.
- Строки (умеет складвать строки, поддерживает конструкцию `#{$var}`)

Файлы, заканчивающиеся на .scss представляют собой стандартный синтаксис, поддерживаемый Sass. SCSS - это надмножество CSS.
Файлы, заканчивающиеся на .sass представляют собой "старый" синтаксис, поддерживаемый Sass, происходящим в мире ruby.

## 7. Клиентские сценарии. Особенности, сферы применения. Язык JavaScript.

При разработке динамических web-сайтов в большинстве случаев целесообразно разделять бизнес-логику между клиентом и сервером, чтобы добиться оптимальной производительности в условиях низкоскоростных каналов Интернета и лимитированных ресурсов Web-серверов.

Например, предварительную обработку введенных данных, отправляемых серверу, имеет смысл выполнять на стороне клиента. Это позволит исключить повторные передачи неправильно заполненных форм. Графическое представление результатов запроса также стоит выполнять на стороне клиента, что существенно сократит объем данных, передаваемых по сети.

#### Сферы применения 
- Оперативная проверка достоверности заполняемых пользователем полей форм HTML до передачи их на сервер. Сценарии JavaScript способны обрабатывать данные, введенные пользователями в полях форм, а также события, возникающие в процессе манипуляций пользователя с мышью, копировать в окно браузера другие страницы HTML или изменять содержимое уже загруженных страниц.
- Создание динамических HTML-страниц совместно с каскадными таблицами стилей и объектной моделью документа.
- Взаимодействие с пользователем при решении "локальных" задач, решаемых приложением JavaScript, встроенном в HTML-страницу. В частности, сценарии JavaScript широко применяются для создания различных визуальных эффектов. Например, изменение внешнего вида элементов управления, над которыми установлен курсор мыши, анимация графических изображений, создание звуковых эффектов и т. д. Механизм локальной памяти Cookie позволяет сценариям JavaScript сохранять на компьютере локальную информацию, введенную пользователем. Например, в Cookie может храниться список товаров из Интернет-магазина, отобранных для покупки.

Основные архитектурные черты:

- динамическая типизация;
- слабая типизация;
- автоматическое управление памятью;
- прототипное программирование;
- функции как объекты первого класса.

## 8. Версии ECMAScript, новые возможности ES6 и ES7.

ECMAScript — это встраиваемый расширяемый не имеющий средств ввода-вывода язык программирования, используемый в качестве основы для построения других скриптовых языков. Стандартизирован международной организацией ECMA в спецификации. (ECMAScript это стандарт, а JavaScript его реализация).

### ES6 

Это обновление добавило новый синтаксис для написания классов и модулей, добавились итераторы и циклы for/of, Python-style генераторы, двоичные данные, лямбда-выражения, типизированные массивы, коллекции, обещания (promises), рефлексию и прокси, усовершенствовали числа и математику. Добавлено ключевое слово let (которое помогает объявить переменной область видимости - блок) и const.

### ES7

- Метод includes — это простой метод объектов типа Array, который позволяет выяснить, имеется ли в массиве некий элемент (он, в отличие от indexOf, подходит и для работы со значениями NaN).
- инфиксный оператор, который используется для возведения в степень. Такой оператор, выглядящий как «**», был представлен в ECMAScript 2016, он может служить заменой Math.pow().

## 9.Синхронная и асинхронная обработка HTTP-запросов. AJAX.

Синхронный запрос - запрос с ожидением ответа. (скрипт послал запрос (объект) на сервер и ждет ответ).

Асинхронный запрос - запрос без ожидания ответа от сервера. (скрипт послал запрос (объект) на сервер, но продолжает выполняться, когда данные вернутся вступает в дело событие onreadystatechenge. Сам объект меняет это событие, когда у него меняется свойство readyState. Для события создается собственная функция, в которой проверяется свойство readyState. И как только оно становится равным "4" - это значит, что данные с сервера пришли. Теперь можно полученные данные обрабатывать).

```js
   var request = getXmlHttpRequest(); // создание объекта
   request.onreadystatechenge = function(){ // установка обработчика onreadystatechenge и проверка свойства readyState
       if(request.readyState == 4)
       ...
   }
   request.open('GET', url, true); // готовим запрос
   request.send(null); // посылаем запрос
```

### AJAX

Asynchronous Javascript and XML - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером.

Пользователь что-то делает -> скрипт определяет с чем там надо работать -> браузер отправляет запрос на сервер -> сервер возвращает только то, от чего ожидаются изменения -> скрипт вносит изменения обратно (без перезагрузки страницы).

## 10. Библиотека jQuery. Назначение, основные API. Использование для реализации AJAX и работы с DOM.

jQuery – это библиотека JavaScript (т.e., она написана на JavaScript), предназначенная для абстрагирования, выравнивания, исправления и упрощения скриптинга при работе с узлами HTML-элементов в браузере или для работы в браузере без графического интерфейса.

jQuery включается в страницу как внешний файл.

```html
<script src="jquery-2.2.2.min.js">
 ```
Вся работа с jQuery ведется с помощью функции $. Работу с jQuery можно разделить на 2 типа:
- Получение jQuery-объекта с помощью функции $().
- Вызов глобальных методов у объекта $.

Типичный пример манипуляции сразу несколькими узлами DOM заключается в вызове $ функции со строкой селектора CSS, что возвращает объект jQuery, содержащий некоторое количество элементов HTML-страницы. Эти элементы затем обрабатываются методами jQuery.

```js
$("div.test").add("p.quote").addClass("blue").slideDown("slow");
//находит элементы div с классом test, все элементы p с классом quote, добавляет им класс blue, ...
```
Итак:

- Абстрагируется интерфейс объектной модели документа (он же DOM API).
- Выравниваются все различия реализаций DOM, существующие между браузерами.
- Исправляются известные браузерные баги, связанные с CSS и DOM.

Все это оборачивается в более простой и менее корявый API, нежели нативный API DOM – вот вам и библиотека jQuery.

Теперь позвольте объяснить, что я понимаю под “скриптингом HTML-элементов”. При помощи jQuery совершенно тривиально решаются задачи вроде «визуально скрыть второй элемент h2 в документе .html. Код jQuery для такой задачи выглядел бы так:

```js
jQuery('h2:eq(1)').hide();
```
Теперь сравним его с нативным DOM-кодом, который потребовалось бы написать, если бы мы не работали с jQuery.

```js
document.querySelectorAll('h2')[1].style.setProperty('display','none');
```
Две базовые концепции, на которых основана jQuery, таковы: “найди и сделай” и “пиши меньше, делай больше.”
Две этих концепции можно развернуть и переформулировать в виде следующего утверждения: первоочередная задача jQuery заключается в организации выбора (то есть, нахождении) или в создании HTML-элементов для решения практических задач. Без jQuery для этого потребовалось бы больше кода и больше сноровки в обращении с DOM. Достаточно вспомнить рассмотренный выше пример с сокрытием элемента h2.

Следует отметить, что круг возможностей jQuery этим не ограничивается. Она не просто абстрагирует нативные DOM-взаимодействия, но и абстрагирует асинхронные HTTP-запросы (т.н. AJAX) при помощи объекта XMLHttpRequest. Кроме того, в ней есть еще ряд вспомогательных решений на JavaScript и мелких инструментов. Но основная польза jQuery заключается именно в упрощении HTML-скриптинга и просто в том, что с ней приятно работать.

$.ajax и соответствующие функции позволяют использовать методы AJAX

```js
$.ajax({
  type: "POST",
  url: "some.php",      // обращение к some.php
  data: {name: 'John', location: 'Boston'},   //с какими-то параметрами
  success: function(msg){
    alert( "Data Saved: " + msg );  // получный результат выводится в alert
  }
}); 
```
## 11. Реализация AJAX с помощью SuperAgent.

Библиотека Superagent, как и Axios, подходит для Node.js и для современных браузеров. Она предоставляет разработчику простое и понятное API, с которым удобно работать.

#### Что такое Node.js?
Node.js (или просто Node) — это серверная платформа для работы с JavaScript через движок V8. JavaScript выполняет действие на стороне клиента, а Node — на сервере. С помощью Node можно писать полноценные приложения. Node умеет работать с внешними библиотеками, вызывать команды из кода на JavaScript и выполнять роль веб-сервера.

#### В чём преимущество Node?
C Node проще масштабироваться. При одновременном подключении к серверу тысяч пользователей Node работает асинхронно, то есть ставит приоритеты и распределяет ресурсы грамотнее. Java же, например, выделяет на каждое подключение отдельный поток.

####  Откуда Node вообще взялся?
Node появился в 2009 году благодаря Райану Далу. До этого в серверах царил подход «один поток на каждое соединение», а Дал придумал использовать систему, которая ориентирована на события. То есть реагирует на действие или бездействие и выделяет под это ресурс. Главная цель Node — построение масштабируемых сетевых серверов.


SuperAgent позиционируется разработчиками как легковесная и расширяемая библиотека для работы с AJAX. 
Для того чтобы выполнить HTTP-запрос средствами Superagent, достаточно вызвать подходящий метод объекта request:

request
  .post('/api/pet')
  .send({ name: 'Manny', species: 'cat' })
  .set('X-API-Key', 'foobar')
  .set('Accept', 'application/json')
  .then(res =>{
      console.log('I got: ' + JSON.stringify(res.body));
  }).catch(error => {
      console.log("Something wrong", errror);
  });
 

#### ▍Сильные стороны

Поддерживает плагины.
Поддаётся конфигурированию.
Имеет приятный интерфейс для выполнения HTTP-запросов.
Поддерживает объединение в цепочку нескольких вызовов для выполнения запросов.
Работает в среде Node.js и в браузерах.
Поддерживает индикацию прогресса для выгрузки и загрузки данных.
Поддерживает механизм chunked-transfer encoding.
Поддерживает коллбэки.
Для этой библиотеки разработано множество плагинов.

####  ▍Слабые стороны

Имеет своеобразное API, не придерживающееся каких-либо стандартов.

## 12. Серверные сценарии. CGI - определение, назначение, ключевые особенности.

CGI (Common Gateway Interface — общий интерфейс шлюза) — стандарт интерфейса, используемого для связи внешней программы с веб-сервером. Программу, которая работает по такому интерфейсу совместно с веб-сервером, принято называть шлюзом (оно же скрипт или CGI-программа). По сути позволяет использовать консоль ввода и вывода для взаимодействия с клиентом.

Поскольку гипертекст статичен по своей природе, веб-страница не может непосредственно взаимодействовать с пользователем. До появления JavaScript, не было иной возможности отреагировать на действия пользователя, кроме как передать введенные им данные на веб-сервер для дальнейшей обработки. В случае CGI эта обработка осуществляется с помощью внешних программ и скриптов, обращение к которым выполняется через стандартизованный (см. RFC 3875: CGI Version 1.1) интерфейс — общий шлюз.

Обобщенный алгоритм работы через CGI можно представить в следующем виде:

1. Клиент запрашивает CGI-приложение по его URI.
2. Веб-сервер принимает запрос и устанавливает переменные окружения, через них приложению передаются данные и служебная информация.
3. Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
4. CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
5. Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.
6. Веб-сервер передает результаты запроса клиенту.

Наиболее частая задача, для решения которой применяется CGI — создание интерактивных страниц, содержание которых зависит от действий пользователя. Типичными примерами таких веб-страниц является форма регистрации на сайте или форма для отправки комментария. Другая область применения CGI, остающаяся за кулисами взаимодействия с пользователем, связана со сбором и обработкой информации о клиенте: установка и чтение «печенюшек»-cookies; получение данных о браузере и операционной системе; подсчет количества посещений веб-страницы; мониторинг веб-трафика и т.п.

#### Преимущества CGI
- Процесс CGI скрипта не зависит от Веб-сервера и, в случае падения, никак не отразится на работе последнего
- Может быть написан на любом языке программирования
- Поддерживается большинством Веб-серверов

### Недостатки

Самым большим недостатком этой технологии являются повышенные требования к производительности веб-сервера. Дело в том, что каждое обращение к CGI-приложению вызывает порождение нового процесса, со всеми вытекающими отсюда накладными расходами. Если же приложение написано с ошибками, то возможна ситуация, когда оно, например, зациклится. Браузер прервет соединение по истечении тайм-аута, но на серверной стороне процесс будет продолжаться, пока администратор не снимет его принудительно.

## 13. FastCGI - особенности технологии, преимущества и недостатки относительно CGI.

Дальнейшее развитие технологии CGI, является более производительным и безопасным, снимает множество ограничений CGI-программ.

CGI — устаревшая технология, позволяющая взаимодействовать веб-серверу с сервером приложений. Для каждого запроса запускается процесс с интерпретатором PHP, после возвращения ответа он завершается. Поскольку это очень неэффективно, был создан FastCGI, в котором процесс интерпретатора не завершается, а используется для последующих запросов.

### Особенности технлогии 
FastCGI программа работает следующим образом: программа единожды загружается в память в качестве демона (независимо от HTTP-сервера), а затем входит в цикл обработки запросов от HTTP-сервера. Один и тот же процесс обрабатывает несколько различных запросов один за другим, что отличается от работы в CGI-режиме, когда на каждый запрос создается отдельный процесс, "умирающий" после окончания обработки.

### Недостатки 

Написание FastCGI программ-демонов сложнее чем CGI, нужны дополнительные библиотеки, зависящие от языка.

## 14. Язык PHP - синтаксис, типы данных, встраивание в веб-страницы, правила обработки HTTP-запросов. Особенности реализации принципов ООП в PHP.

PHP - скриптовый язык общего назначения, интенсивно применяемый для разработки веб-приложений.

### Типы данных

PHP - яп с динамической типизацией. Преобразования меджду скалярными типами происходят неявно.
Скалярные типы: integer, float, double, boolean, string.
Нескалярные: array, object, resource, null
Псевдотипы: mixed (любой тип), number, callback (string или анонимная фунуция), void.

### ООП в PHP

Следует учитывать, что в PHP несколько упрощенная реализация ООП (объектно-ориентированное программирование). Поэтому, когда речь идёт об ООП как абстрактной парадигме, то следует использовать какой-то более серьёзный язык, вроде Java, С++ или Object Pascal. Потому что на этих языкам можно посмотреть практическую реализацию принципов ООП. В PHP программисты пытаются подражать другим ЯП, что в итоге приводит к излишней сложности и путанице, поскольку язык сам по себе не позволяет сделать «как в теории».

Главная проблема такого (спагетти) кода в том, что у него низкая читабельность и слишком большая запутанность. Там где нужно выполнить какой-то один метод, подтягивается еще десяток классов. При этом каждый класс в отдельном файле, что может окончательно свести с ума даже опытных программистов.

```php
class ClassName {
  public $publicName;
  private $privateName;
  protected $protectedName;
  
  const CONST_VAL = 'val';
  
  public function getPrivateName() {
    return $this->$privateName; // $this -- ссылка на сам объект, $parent - на родительский.
  }
};

echo ClassName::CONST_VAL; // для обращения к константам

$classname = new ClassName();

$className->publicName; // доступ к переменной
```

PHP поддерживает все три основных механизма ООП — инкапсуляцию, полиморфизм подтипов и наследование (с помощью extend). Поддерживаются интерфейсы (с помощью implements). Есть абстрактные и final методы и классы. Множественное наследование не поддерживается, но класс может реализовывть несколько интерфейсов или с помощью механизма особенностей (trait), который имеет средства для разрешения конфликтов.

Методы: __construct() -- конструктор __destruct() -- для деинициализации объекта __get(), __set() __sleep(), __wakeup() __clone()

## Polling 

Первое решение, которое приходит в голову для получения событий с сервера - это "поллинг" (polling), т.е периодический опрос сервера стандартными пакетами: "я тут, изменилось ли что-нибудь?”

В ответ сервер во-первых помечает у себя, что клиент онлайн, а во-вторых посылает датаграмму, в которой в специальном формате содержится весь пакет событий, накопившихся к данному моменту

У этого способа есть одна большая проблема, а именно - __большие задержки между созданием и получением данных__. Сервер отсылает их не тогда, когда они появились, а когда настанет время очередного запроса.

_Задержка = время между опросами + установление соединения + передача данных._

Другой минус - __лишний входящий трафик на сервер__. При каждом запросе браузер передает множество заголовков, причем заголовки
всегда идут в несжатом виде. Для некоторых приложений входящий трафик заголовков может в 10 и более раз превосходить исходящий трафик реальных данных.

![GitHub Logo](/polling1.jpg)
![GitHub Logo](/polling2.jpg)

## Long Polling 

Чтобы сэкономить на ресурсах, можно использовать long polling. Устроен он так же, как и polling, с одним отличием: сервер дольше отвечает. Вообще, при лонг-поллинге сервер отвечает в двух случаях: или потому, что пришло новое сообщение, или потому, что соединение пора разрывать.

У каждого запроса есть timeout — время, в течении которого нужно ответить. Если на запрос не ответили за это время, считается, что сервер не ответит вообще. 

Поэтому сервер смотрит на timeout и решает так:
1. Если за это время у меня не появится обновлений для клиента, я отвечу ему, что их нет.
2. Если появятся, я отправлю ему обновления сразу, не дожидаясь таймаута.

__Чтобы реализовать long polling на стороне клиента, нужно выставить большой timeout: 30 или 60 секунд.

Итак, что же из себя представляет Long Polling?

Выглядит это примерно следующим образом:
1) Клиент отсылает на сервер обычный ajax-запрос
2) Сервер, вместо того, чтобы быстро обработать этот запрос и отправить ответ клиенту, запускает цикл, в каждой итерации которого следит за возникновением событий (другой клиент добавил запись или удалил).
3) При возникновении события сервер генерирует ответ и отсылает его клиенту, таким образом завершая запрос.
4) Клиент, получив ответ от сервера, запускает обработчик события и параллельно отправляет очередной «длинный» запрос серверу.

![GitHub Logo](/Long%20Polling.jpeg)

## Cookie

__Ку́ки (англ. cookie, буквально — печенье)__ — небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса.

Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:

- аутентификации пользователя;
- хранения персональных предпочтений и настроек пользователя;
- отслеживания состояния сеанса доступа пользователя;
- сведения статистики о пользователях.

Cookie легко перехватить и подменить (например, для получения доступа к учётной записи), если пользователь использует нешифрованное соединение с сервером. В группе риска пользователи, выходящие в интернет при помощи публичных точек доступа Wi-Fi и не использующие при этом таких механизмов, как SSL и TLS. Шифрование позволяет также решить и другие проблемы, связанные с безопасностью передаваемых данных.

Большинство современных браузеров позволяет пользователям выбрать — принимать cookie или нет, но их отключение делает невозможной работу с некоторыми сайтами. Кроме того, по законам некоторых стран (например, по закону Евросоюза от 2016 года, см. общий регламент по защите данных) сайты должны в обязательном порядке запрашивать согласие перед установкой cookie.

### Назначение 

1) Cookie используются веб-серверами для идентификации пользователей и хранения данных о них.

К примеру, если вход на сайт осуществляется при помощи cookie, то, после ввода пользователем своих данных на странице входа, cookie позволяют серверу запомнить, что пользователь уже идентифицирован и ему разрешён доступ к соответствующим услугам и операциям.

2) Многие сайты также используют cookie для сохранения настроек пользователя. Эти настройки могут использоваться для персонализации, которая включает в себя выбор оформления и функциональности. Например, Википедия позволяет авторизованным пользователям выбрать дизайн сайта. Поисковая система Google позволяет пользователям (в том числе и не зарегистрированным в ней) выбрать количество результатов поиска, отображаемых на одной странице.

3) Cookie также используются для отслеживания действий пользователей на сайте. Как правило, это делается с целью сбора статистики, а рекламные компании на основе такой статистики формируют анонимные профили пользователей для более точного нацеливания рекламы.
  
## 15. Java-сервлеты. Особенности реализации, ключевые методы, преимущества и недостатки относительно CGI и FastCGI.

__Servlet__ – в первую очередь это простой Java интерфейс, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентами посредством принципа запрос-ответ. 

#### Что же такое сервлет ? В двух словах описать работу сервлета можно так:

Web-сервер, который умеет работать с сервлетами, запускает Java-машину, которая в свою очередь выполняет сервлет, а сервлет отдает данные, которые он сформирует. Т.е. при приходе запроса от клиента сервер с помощью специального конфигурационного файла может определить, какой сервлет выполнить, сервлет выполняется и создает HTML-страницу, которую сервер отправляет клиенту.

На сервер приходит запрос от клиента, запрос содержит внутри себя URL и параметры. Сервер имеет специальный конфигурационный файл, который ему сообщает о том, какой сервлет надо выполнить в случае прихода определенного URL. Сервлет выполняется (там вы можете использовать параметры) и создает HTML-страницу, которая отсылается клиенту.
Сервер по сути является контейнером (теперь уже не визуальных компонентов), который загружает сервлеты, выполняет их, вызывая определенные методы и получив от них результат, отправляет его клиенту.

Таким образом сервлет — это Java-класс, который наследуется обычно от класса • HttpServlet и переопределяет часть методов:
- doGet — если мы хотим, чтобы сервлет реагировал на GET запрос.
- doPost — если мы хотим, чтобы сервлет реагировал на POST запрос.
- doPut, doDelete — если мы хотим, чтобы сервлет реагировал на PUT и DELETE запрос (есть и такие в HTTP). Эти методы реализуются крайне редко, т.к. сами команды тоже очень редко встречаются.
- init, destroy — для управления ресурсами в момент создания сервлета и в момент его уничтожения.

Если же необходимо перехватывать все команды, то проще переопределить метод __service__. Именно этот метод вызывается при приходе запроса от клиента. В HttpServlet происходит разбор запроса и в соответствии с указанной командой вызывается метод doGet, doPost и т.д.


#### Важно !!!
- ServletContext живет до тех пор, пока живет веб-приложение. Он является общим для всех запросов во всех сеансах.
- HttpSession живет до тех пор, пока клиент взаимодействует с веб-приложением с одним и тем же экземпляром браузера, а время ожидания сеанса на стороне сервера не истекло. Он является общим для всех запросов в одном сеансе.
- HttpServletRequest и HttpServletResponse живут с момента получения сервлетом запроса HTTP от клиента, пока не будет получен полный ответ (веб-страница). Он не разделяется в других местах.
- Все экземпляры Servlet , Filter и Listener живут до тех пор, пока живет веб-приложение. Они являются общими для всех запросов во всех сеансах.
- Любой attribute , определенный в ServletContext, HttpServletRequest и HttpSession , будет жить до тех пор, пока живет рассматриваемый объект. Сам объект представляет собой "scope" в рамках управления бобами, таких как JSF, CDI, Spring и т.д. Эти фреймворки хранят свои ограниченные бобы как attribute из своей ближайшей совпадающей области.

#### Преимущества и недостатки относительно CGI и FastCGI

Преимущества:
-	Выполняются быстрее, чем CGI-сценарии.
-	Хорошая масштабируемость.
-	Надежность и безопасность (реализованы на JAVA)
-	Платформенно-независимы
-	Множество инструментов мониторинга и отладки

Недостатки:
-	Слабое разделение уровня представления и бизнес-логики.
-	Возможны конфликты при параллельной обработке запросов.

## 16. Контейнеры сервлетов. Жизненный цикл сервлета.

Сервлет-контейнер поддерживает только API сервлета (включая JSP, JSTL).

Сервер приложений поддерживает весь JavaEE - EJB, JMS, CDI, JTA, API сервлета (включая JSP, JSTL) и т.д.


#### Жизненный цикл сервлета
Для каждого сервлета движок сервлетов создает только одну копию. Вне зависимости от того, сколько запросов будет отправлено сервлету, все запросы будут обрабатываться толькой одной копией сервлета. Объект сервлета создается либо при запуске движка сервлетов, либо когда сервлет получает первый запрос. Затем для каждого запроса запускается поток, который обращается к объекту сервлета.

При работе с сервлетом движок сервлетов вызывает у класса сервлета ряд методов, которые определены в родительском абстрактном классе HttpServlet.

Когда движок сервлетов создает объект сервлета, у сервлета вызывается метод init().

```java
public void init(ServletConfig config) throws ServletException { 
}
```
Этот метод вызывается только один раз - при создании сервлета. Мы можем переопределить этот метод, чтобы определить в нем некоторую логику инициализации.

Когда к сервлету приходит запрос, движок сервлетов вызывает метод service() сервлета. А этот метод, исходя из типа запроса (GET, POST, PUT и т.д.) решает, какому методу сервлета (doGet, doPost и т.д.) обрабатывать этот запрос.

```java
public void service(HttpServletRequest request, HttpServletResponse response) 
        throws IOException, ServletException{
        }
```
Этот метод также можно переопределить, однако в этом нет смысла. В реальности для обработки запроса переопределяются методы onGet, onPost и т.д., которые обрабатывают конкретные типы запросов.

Если объект сервлета долгое время не используется (к нему нет никаких запросов), или если происходит завершение работы движка сервлетов, то движок сервлетов выгружает из памяти все созданные экземпляры сервлетов. Однако до выгрузки сервлета из памяти у сервлета вызывается метод destroy().

```java
public void destroy()
```
При необходимости мы также можем его переопределить, например, определить в нем логику логгирования или что иное. В то же время следует учитывать, что если сервер вдруг упадет по какой-то причине, например, отключится электричество и т.д., тогда данный метод естественно не будет вызван и его логика не сработает.

Поскольку для обработки всех запросов создается один экземпляр сервлета, и все обращения к нему идут в отдельных потоках, то не рекомендуется в классе сервлета объявлять и использовать глобальные переменные, так как они не будут потокобезопасными.

## 17.Диспетчеризация запросов в сервлетах. Фильтры сервлетов.

#### Диспетчеризация запросов в сервлетах

- Сервлеты могут делегировать обработку запросов другим ресурсам (сервлетам, JSP и HTML-страницам).
- Диспетчеризация осуществляется с помощью реализаций интерфейса javax.servlet.RequestDispatcher.
- Два способа получения RequestDispatcher — через ServletRequest (абсолютный или относительный URL) (RequestDispatcher view = request.getRequestDispatcher(“result.jsp”);) и ServletContext (только абсолютный URL). (RequestDispatcher reqDispObj = getServletContext().getRequestDispatcher("/ContextRoot/home.jsp");)
- Два способа делегирования обработки запроса — forward и include (include используется чтобы вставить вывод другого сервлета в текущий. forward позволяет провести предварительную обработку запроса и потом полностью передать управление другому сервлету) 

__Отличие include от forward:__

- Assume you have two pages, pageA, and pageB. In pageA you wrote the include tag. In this case the control was in pageA til you called the include tag. At this point the full control goes to pageB. When It's done, control is returned to pageA starting from the next point of coding after the include tag and continuing to the rest of pageA.

- Well, to get things much clearer, let's say that we have the same pages, pageA and pageB, but this time we will use the forward tag in pageA, not the include tag. Again, the control will begin in pageA till we call the forward tag in pageA, at this point, control is transfered to pageB, just like the include tag. But the difference is what happens when pageB completes. In case of the forward tag, control doesn't go back to pageA again.

Отличие redirect от forward:
- response.sendRedirect(""); используется для перенаправления ресурсов на разные серверы или домены. Эта передача задачи управления делегируется браузеру контейнером. То есть, перенаправление отправляет заголовок обратно в браузер/клиент. Этот заголовок содержит URL-адрес ресурса, который будет перенаправлен браузером. Затем браузер инициирует новый запрос к указанному URL-адресу.

- request.getRequestDispathcer("login.jsp").forward(request, response); используется для пересылки ресурсов, доступных на сервере, с которых выполняется вызов. Эта передача управления осуществляется контейнером внутри, а браузер/клиент не задействован.

__мы должны использовать forward() при доступе к ресурсам в том же приложении, потому что это быстрее, чем метод sendRedirect(), который требовал дополнительного сетевого вызова.__

#### Фильтры сервлетов

Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.


Сервлетные фильтры могут:

- Перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
- Определить содержание запроса прежде, чем сервлет будет инициирован;
- Модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
- Модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
- Перехватывать инициацию сервлета после обращения к сервлету.
Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:

```java
<filter>
    <filter-name>FilterName</filter-name>
    <filter-class>common.FilterConnect</filter-class>
    <init-param>
        <param-name>active</param-name>
        <param-value>true</param-true>
    </init-param>
</filter>
 
<filter-mapping>
    <filter-name>FilterName</filter-name>
    <servlet-name>ServletName</servlet-name>
</filter-mapping>
```

```java
void init (FilterConfig config) throws ServletException;

void destroy ();

void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; 
```
__Пример предобработки:__
```java
if (userAuthorized()) {
    chain.doFilter(request, response);  
} else { 
    httpResponse.sendRedirect("login.jsp");
}
```
__Пример постобработки__
Чтобы манипулировать ответами от сервера, прежде чем они будут отправлены обратно клиенту.


## 18. Контекст сервлета - назначение, способы взаимодействия сервлетов с контекстом.

Для доступа из сервлета к параметрам WEB-приложения необходимо использовать интерфейс javax.servlet.ServletContext. Объект ServletContext является уникальным и доступен всем сервлетам.

ServletContext позволяет получить доступ к параметрам WEB-приложения, определенным в дескрипторе web.xml тегом <context-param> :
        
getAttribute () Гибкий способ получения информации о сервере через пары атрибутов имя/значение. Зависит от сервера.

GetMimeType () Возвращает тип MIME данного файла.

getRealPath () Этот метод преобразует относительный или виртуальный путь в новый путь относительно месторасположения корня HTML-документов сервера.

getServerInfo () Возвращает имя и версию сетевой службы, в которой исполняется сервлет.

getServlet () Возвращает объект Servlet указанного имени. Полезен при доступе к службам других сервлетов.

getServletNames () Возвращает список имен сервлетов, доступных в текущем пространстве имен.

log () Записывает информацию в файл регистрации сервлета. Имя файла регистрации и его формат зависят от сервера.

## 19. JavaServer Pages. Особенности, преимущества и недостатки по сравнению с сервлетами, область применения.

Страницы JSP — это текстовые файлы, содержащие статический HTML и JSP-элементы.
- JSP-элементы позволяют формировать динамическое содержимое.
- При загрузке в веб-контейнер страницы JSP транслируются компилятором (jasper) в сервлеты.
- Позволяют отделить бизнес-логику от уровня представления (если их комбинировать с сервлетами).

Преимущества:
- Высокая производительность — транслируются в
сервлеты.
- Не зависят от используемой платформы — код
пишется на Java.
- Позволяют использовать Java API.
- Простые для понимания — структура похожа на
обычный HTML.
 Недостатки:
- Трудно отлаживать, если приложение целиком
основано на JSP.
- Возможны конфликты при параллельной обработке
нескольких запросов.

ЕЩЕ!1!1!

- Модификация в сервлете является трудоемкой задачей, поскольку включает в себя перезагрузку, перекомпиляцию и перезапуск сервера. В то время как модификация JSP быстрая, просто нажмите кнопку обновления.

- В сервлете мы должны выполнить все, как бизнес-логику и логику представления, в одном файле сервлета. Принимая во внимание, что в JSP бизнес-логика изолирована от логики представления с помощью JavaBeans.

- Сервлет может принимать любые запросы к протоколу и может переопределять метод service (). В то время как JSP получает только HTTP-запросы и не может переопределить его метод service ().

- Более того, сервлет - это Java-код. Написание кода для сервлета сложнее, чем JSP, так как это HTML в Java. Принимая во внимание, что JSP - это код на основе HTML, а JSP прост в кодировании, так как это Java в HTML.

- Сервлеты выполняются на веб-сервере, таком как Tomcat, а программа JSP перед выполнением компилируется в сервлет Java. Как только он скомпилирован в сервлет, его жизненный цикл будет аналогичен сервлету. Однако у JSP есть свой индивидуальный API для жизненного цикла.

## 20. Правила записи Java-кода внутри JSP. Стандартные переменные, доступные в скриптлетах и выражениях.


2 варианта синтаксиса — на базе HTML и XML.

- Обозначаются тегами <% %> (HTML-вариант):
<html>
<%-- scripting element --%>
</html>
        
- Существует 5 типов JSP-элементов:
- Комментарий — <%-- Comment --%>;

  Поддерживаются 3 типа комментариев:
  * HTML-комментарии:
  <!-ч- This is an HTML comment.
  It will show up in the response. -ч->
  * JSP-комментарии:
  <%-- This is a JSP comment.
  It will only be seen in the JSP code.
  It will not show up in either the servlet code
  or the response.
  --%> 
  * Java-комментарии:
  <%
  /* This is a Java comment.
  It will show up in the servlet code.
  It will not show up in the response. */
  %>

- Директива — <%@ directive %>;

  Управляют процессом трансляции страницы в сервлет.
    * Директива страницы (Директива страницы используется для предоставления инструкций контейнеру. Эти инструкции относятся к текущей странице JSP.)
    <%@ page session=”false” %>
    <%@ page import="java.util.ArrayList" %>
    <%@ page import="helpers.Point" %>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    (buffer, contentType, language, isThreadSafe)
    * Директива включения (Директива include используется для включения файла на этапе перевода. Эта директива указывает контейнеру объединять содержимое других       внешних файлов с текущим JSP на этапе трансляции.)
    <%@ include file=”incl/copyright.html” %> 
    Эквивалент на XML:<jsp:directive.include file="url"\>.
    URL должен быть относительным . Для подключения файла в процессе запроса а не в ходе трансляции используйте действие jsp:include.
       1) Директива include :
       <%@ include file="header.html" %>
       Статический : добавляет содержимое из значения атрибута файла на текущую страницу во время перевода . Директива изначально предназначалась для статических          шаблонов макета, таких как заголовки HTML.

      2) <jsp:include> Стандартное действие :
      <jsp:include page="header.jsp" />
      Динамический : добавляет содержимое из значения атрибута страницы на текущую страницу во время запроса . Был предназначен больше для динамического контента,       поступающего из JSP.

      3) <c:import>Тег JSTL:
      <c:import url=”http://www.example.com/foo/bar.html” />
      Динамический : добавляет содержимое из значения атрибута URL на текущую страницу во время запроса . Он работает примерно так же <jsp:include>, но он более         мощный и гибкий: в отличие от двух других включений, <c:import> URL-адрес может быть извне веб-контейнера !
    
    * Директива taglib ( Библиотеки тегов-это фрагменты кода Java, которые могут использоваться в JSP, но которые соответствуют определенному API и которые             выглядят как теги HTML в JSP. Файл описания библиотеки тегов (TLD) описывает имена этих тегов, какие атрибуты они могут иметь и какие классы Java реализуют их)
    
    Директива taglib имеет следующий синтаксис: 
    <%@ taglib uri="URI включаемой библиотеки тегов" prefix="имяПрефикса" %>
    Префикс "имяПрефикса" используется при обращении к библиотеке. Пример использования библиотеки тегов mytags:
    <%@ taglib uri="http://www.taglib/mytags" prefix="customs" %>
    . . .
    <customs:myTag>
    
- Объявление — <%! decl %>;(declarations не производят никакого вывода в стандартный выходной поток out. Переменные и методы, декларированные в объявлениях, инициализируются и становятся доступными для скриптлетов и других объявлений в момент инициализации страницы JSP.)

    Позволяют объявлять поля и методы:
    * Синтаксис:
    ```jsp
    <%! JavaClassDeclaration %>
    ```
    * Примеры:
    ```jsp
    <%!
    public static final String DEFAULT_NAME = “World”;
    %>
    <%!
    public String getName(HttpServletRequest request) {
    return request.getParameter(“name”);
    }
    %>
    <%! int counter = 0; %>
    ```
    
- Скриптлет — <% code %>; (Позволяют задать Java-код, который будет выполняться при обработке запросов (при вызове метода _jspService).)
    * Синтаксис:
    ```jsp
    <% JavaCode %>
    ```
    * Примеры:
    ```jsp
    <% int i = 0; %>
    <% if ( i > 10 ) %>
    I am a big number
    <% } else { %>
    I am a small number
    <% } %>
    ```

- Выражение — <%= expr %>. (Позволяют вывести результат вычисления выражения.)
    * Синтаксис:
    ```jsp
    <%= JavaExpression %>
    ```
    * Примеры:
    ```
     <B>Ten is <%= (2 * 5) %></B>
     Thank you, <I><%= name %></I>, for registering for the soccer league.
     The current day and time is: <%= new java.util.Date() %>
     ```


### Стандартные переменные, доступные в скриптлетах и выражениях.

В процессе трансляции контейнер добавляет в
метод _jspService ряд объектов, которые можно
использовать в скриптлетах и выражениях:

- application     javax.servlet.ServletContext
- config          javax.servlet.ServletConfig
- exception       java.lang.Throwable.   (используется только на страницахперенаправлениях с информацией об ошибках (Error Pages).)
- out             javax.servlet.jsp.JspWriter
- page            java.lang.Object   (API для доступа к экземпляру класса сервлета, в который транслируется JSP.)
- PageContext     javax.servlet.jsp.PageContext (PageContext — контекст JSP-страницы)
- request         javax.servlet.ServletRequest
- response        javax.servlet.ServletResponse
- session         javax.servlet.http.HttpSession

## 21. Bean-компоненты и их использование в JSP.
JavaBeans — классы в языке Java, написанные по определённым правилам. Они используются для объединения нескольких объектов в один для удобной передачи данных.

Чтобы класс мог работать как bean, он должен соответствовать определённым соглашениям об именах методов, конструкторе и поведении. Эти соглашения дают возможность создания инструментов, которые могут использовать, замещать и соединять JavaBeans.

Правила описания:

- Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.
- Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов.
- Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.
- Класс должен иметь переопределенные методы equals(), hashCode() и toString().


JavaBean – это одноуровневые объекты, использующиеся для того, чтобы инкапсулировать в одном объекте код, данные или и то и другое. Компонент JavaBean может иметь свойства, методы и события, открытые для удаленного доступа.

```jsp
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
         "http://www.w3.org/TR/html4/loose.dtd">

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ page import="java.util.*, java.text.*" %>

<jsp:useBean id="hello" class="example.JavabeanHello" scope="page" />

<%! 
String getFormattedDate() 
{ 
    SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy hh:mm:ss"); 
    return sdf.format(new Date()); 
} 
%>
<html>
  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>JavaBean с JSP!</title>
  </head>
  <body>
       <h2>${hello.message}</h2>
       <i>Сегодня <%= getFormattedDate() %></i>
  </body>
</html>
```
__Scope__
Атрибут, определяющий область видимости ссылки на экземпляр объекта JavaBean. Допустимыми значениями являются page, request, session, application. Данный атрибут фактически описывает пространство имен и цикл жизни ссылки на объект. По умолчанию значение объекта равно page.

- page (страница). Объект, определенный с областью видимости page, доступен до тех пор, пока не будет отправлен ответ клиенту или пока запрос к текущей странице JSP не будет перенаправлен куда-нибудь еще. Ссылки на объект возможны только в пределах страницы, в которой этот объект определен. Объекты, объявленные с атрибутом page, сохраняются в объекте pageContext.
- request (запрос). Объект, имеющий область видимости request, существует и доступен в течение текущего запроса, и остается видимым, даже если запрос перенаправляется другому ресурсу в том же самом цикле выполнения. Объекты, декларированные с атрибутом области видимости request, сохраняются в объекте request.
- session (сессия). Объект, имеющий область видимости session доступен в течение текущего сеанса, если страница JSP "знает" о сеансе.
- application (приложение). Объект, имеющий область видимости application доступен страницам, обрабатывающим запросы в одном и том же приложении Web, и cуществует до тех пор, пока сервер приложений поддерживает объект ServletContext. Объекты, объявленные с атрибутом области видимости application, сохраняются в объекте application.

## 22. Стандартные теги JSP. Использование Expression Language (EL) в JSP.

### Стандартные теги JSP.

Стандартная библиотека тегов JSP (JavaServer Pages Standard Tag Library, JSTL) является расширением её спецификации, используемая для условной обработки, создания циклов, интернационализации страницы, разбора XML данных.

JSTL является альтернативой скриплетам, встроенным в JSP, то есть прямым вставкам Java кода. JSTL представляет собой набор тегов в стиле HTML, позволяющих обращаться к объектам Java и выполнять многие из конструкций языка Java.

Для подключения библиотеки тегов JSTL используются следующие выражения:

```jsp
// Основные теги создания циклов, определения условий, вывода информации на страницу и т.д.
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

// Теги для работы с XML-документами
<%@ taglib prefix="x" uri="http://java.sun.com/jsp/jstl/xml" %>

// Теги для работы с базами данных 
<%@ taglib prefix="s" uri="http://java.sun.com/jsp/jstl/sql" %>

// Теги для форматирования и интернационализации информации (i10n и i18n)
<%@ taglib prefix="f" uri="http://java.sun.com/jsp/jstl/fmt" %>
```
__Тэг <c:out>__
Тэг <c:out> используется для вывода данных на экран. Следующий код отобразит выражение, представленное в атрибуте value.

```jsp
// отображение текста 16+64*2
<c:out value="16+64*2" />
```

__Тэг <c:set>__
Тег c:set используется для определения переменной подобно <jsp:setProperty>. Пример использования :

```jsp
<c:set var="user" scope="session" value="Sergey" />
<c:out value="${user}" />
```
__Тэг <c:remove>__
Для удаления переменной следует использовать тэг <c:remove>.

```jsp
<c:remove var="user" scope="request" />
```

__Тэг <c:if>__
Тег <c:if> серьезно отличается от того, что мы используем в других языках программирования. Он не позволяет определить ветку else или elseif. Можно только проверить некоторое условие. Пример :

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
    <head>
        <title>Пример тега <c:if> библиотеки JSTL</title>
    </head>
    <body>
        <c:set var="salary" scope="session" value="${23400*2}"/>
        <c:if test="${salary > 45000}">
            <p>Salary = <c:out value="${salary}"/><p>
        </c:if>
    </body>
</html>
```

### Использование Expression Language (EL) в JSP.

Expression Language или сокращенно EL предоставляет компактный синтаксис для обращения к массивам, коллекциям, объектам и их свойствам внутри страницы jsp. Он довольн прост. Вставку окрывает знак $, затем в фигурные скобки {} заключается выводимое значение:

Откуда эти данные берутся? EL пытается найти значения для этих данных во всех доступных контекстах.

И EL просматривает все эти контексты в следующем порядке:

1. Контекст страницы (данные сохраняются в PageContext)

2. Контекст запроса

3. Контекст сессии

4. Контекст приложения

Соответственно, если контексты запроса и сессии содержат атрибут с одним и тем же именем, то будет использоваться атрибут из контекста запроса.

Затем найденное значение (если оно было найдено) конвертируется в строку и выводится на страницу.

## 23. Шаблоны проектирования и архитектурные шаблоны. Использование в веб-приложениях.

__Шаблон проектирования или паттерн__ — повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста (© Wikipedia).

- Описывает подход к решению типовой задачи.

- Одну и ту же задачу часто можно решить с использованием разных шаблонов.

- Существует много литературы с описанием различных шаблонов проектирования.

__Зачем нужно__

- Позволяют избежать «типовых» ошибок при разработке типовых решений.
- Позволяют кратко описать подход к решению задачи; программистам, знающим шаблоны, проще обмениваться информацией.
- Легче поддерживать код — его поведение более предсказуемо.

__GoF-паттерны__
Описаны в книге 1994 г. «Design Patterns: Elements of Reusable Object-Oriented Software» («Приёмы объектно-ориентированного проектирования. Паттерны проектирования»).

_Порождающие GoF-паттерны_
- Abstract Factory — Абстрактная фабрика.
- Builder — Строитель.
- Factory Method — Фабричный метод.
- Prototype — Прототип.
- Singleton — Одиночка.

_Структурные GoF-паттерны_
- Adapter — Адаптер.
- Bridge — Мост.
- Composite — Компоновщик.
- Decorator — Декоратор.
- Facade — Фасад.
- Flyweight — Приспособленец.
- Proxy — Заместитель.

_Поведенческие GoF-паттерны_
- Chain of responsibility — Цепочка обязанностей.
- Command — Команда.
- Interpreter — Интерпретатор.
- Iterator — Итератор.
- Mediator — Посредник.
- Memento — Хранитель.
- Observer — Наблюдатель.
- State — Состояние.
- Strategy — Стратегия.
- Template — Шаблонный метод.
- Visitor — Посетитель.

__Архитектурные шаблоны__
- Более высокий уровень по сравнению с шаблонами проектирования.
- Описывают архитектуру всей системы или приложения.
- Обычно имеют дело не с отдельными классами, а с целыми компонентами или модулями.
- Компоненты и модули могут быть построены с использованием различных шаблонов проектирования.  
  
  ## 24.Технология JavaServer Faces. Особенности, отличия от сервлетов и JSP, преимущества и недостатки. Структура JSF-приложения.

__JavaServer Faces (JSF)__ — это фреймворк для веб-приложений, написанный на Java. Он служит для того, чтобы облегчать разработку пользовательских интерфейсов для Java EE приложений. В отличие от прочих MVC фреймворков, которые управляются запросами, подход JSF основывается на использовании компонентов. Состояние компонентов пользовательского интерфейса сохраняется, когда пользователь запрашивает новую страницу и затем восстанавливается, если запрос повторяется. Для отображения данных обычно используется JSP, но JSF можно приспособить и под другие технологии, например XUL.


// WTF??1?!!??!
__Технология JavaServer Faces включает:__

- Набор API для представления компонент пользовательского интерфейса (UI) и управления их состоянием, обработкой событий и валидацией вводимой информации, определения навигации, а также поддержку интернационализации (i18n) и доступности (accessibility).
- Специальная библиотека JSP тегов для выражения интерфейса JSF на JSP странице.
- Призванная быть гибкой, технология JavaServer Faces усиливает существующие, стандартные концепции пользовательского интерфейса (UI) и концепции Web-уровня без привязки разработчика к конкретному языку разметки, протоколу или клиентскому устройству.

#### Особенности, отличия от сервлетов и JSP

- JSF предлагает компоненто-центрический, независимый от клиента подход к разработке пользовательских интерфейсов для Web, таким образом увеличивая продуктивность разработчика и простой в использовании;
- Упрощает доступ и управление данными приложения через Web-интерфейс; 
- Автоматически управляет состоянием пользовательского интерфейса между несколькими запросами и несколькими клиентами простым и ненавязчивым способом;

jsf | jsp
------------------------- | --------------------------
jsf is a web application that is used to simplify development integration of web based user interfaces. | jsp is a java based technology used specifically in order to help software developers create dynamic web pages.
jsf contains multiple core features, including, but not limited to, managed beans, a template based component system, and two xml based tag libraries. |  jsp must be compiled in java bytecode in order to function properly.jsp must be compiled in java bytecode in order to function properly.
jsf is a framework. model:backing bean view:jsf controller:facesservlet | jsp  is not a request driven model view controller, but jsp is accessed by the  dynamically generated web pages like html or xml.
jsf supports validator and conversion,ajax. | jsp does not. 

#### Преимущества JSF
- Четкое разделение бизнес-логики и интерфейса
- Управление на уровне компонент
- Простая работа с событиями на стороне сервера
- Расширяемость
- Доступность нескольких реализаций от различных компаний-разработчиков
- Широкая поддержка со стороны интегрированных средств разработки (IDE)

- упрощает обмен данными между UI компонентами
- позволяет реализовывать собственные компоненты
- обеспечивает UI компоненты, которые могут быть повторно использованы
- управляет состоянием UI, которое зависит от нескольких серверов
- соединяет события на стороне клиента с серверной частью приложения

#### Недостатки JSF
- Высокоуровневый фреймворк — сложно реализовывать не предусмотренную авторами функциональность.
- Сложности с обработкой GET-запросов (устранены в JSF 2.0).
- Сложность разработки собственных компонентов.


#### Структура JSF-приложения
- JSP или XHTML-страницы, содержащие компоненты GUI.
- Библиотеки тегов.
- Управляемые бины.
- Дополнительные объекты (компоненты, конвертеры и валидаторы).
- Дополнительные теги.
- Конфигурация — faces-confg.xml (опционально).
- Дескриптор развёртывания — web.xml.


## 25.Использование JSP-страниц и Facelets-шаблонов в JSF-приложениях.

JSP-это старая технология просмотра и широко используется в сочетании с JSF 1.x. Facelets (некоторые люди чрезмерно обобщены как XHTML) является преемником JSP и введена в качестве технологии просмотра по умолчанию JSF 2.x в конце 2009 года

Конечно, с JSF 2.0 контейнер по умолчанию будет искать файлы xhtml, что не очень хорошо, если вы все еще работаете с JavaServer Pages. Но не волнуйтесь, это простое решение. Все, что вам нужно сделать, это отредактировать файл web.xml и сообщить контейнеру, что вашей технологией представления по умолчанию должны быть JSP.

```xml
 <context-param>
      <param-name>javax.faces.DEFAULT_SUFFIX</param-name> 
      <param-value>.jsp</param-value>
 </context-param>
````
 
JSF представляет собой структуру MVC на основе компонентов, которая построена поверх API Servlet и предоставляет компоненты через taglibs который может использоваться в JSP или любой другой технологии просмотра на основе Java, такой как Facelets. Facelets гораздо более подходит для JSF, чем JSP. Это обеспечивает отличные возможности шаблонов, такие как составные компоненты, в то время как JSP в основном предлагает <jsp:include> для шаблонов, так что вы вынуждены создавать пользовательские компоненты с необработанным кодом Java (который немного непрозрачен и много утомительной работы в JSF), когда вы хотите заменить повторяющуюся группу компонентов одним компонентом. Начиная с JSF 2.0, JSP устарела как технология просмотра в пользу Facelets.

Facelets — открытый веб-фреймворк, распространяемый под лицензией Apache license. Технология управления представлением для JavaServer Faces (JSF), альтернатива технологии JavaServer Pages (JSP). Фреймворк требует для функционирования валидные XML документы. Это означает, что веб-страницы должны быть созданы с использованием языка разметки XHTML. Facelets поддерживает все компоненты JSF и создаёт собственное дерево компонент, отражая view (см. MVC) для JSF-приложения. В Facelets полностью устранена широко известная проблема смешанного контента, присущая JavaServer Pages.

__Java Server Pages (JSP)__ - это технология Java, которая позволяет веб-разработчикам и дизайнерам быстро разрабатывать и легко поддерживать насыщенные информацией динамические веб-страницы, которые используют существующие бизнес-системы. Технология JSP отделяет пользовательский интерфейс от создания контента, позволяя дизайнерам изменять общий макет страницы без изменения основного динамического контента.

__Facelets__ - это первый язык объявления страниц без JSP, разработанный для JSF (Java Server Faces), который предоставил разработчикам JSF более простую и мощную модель программирования по сравнению с JSP. Он решает различные проблемы, возникающие в JSP для разработки веб-приложений.

![GitHub Logo](/pictures/JspVsFacelets.png)


## 26. JSF-компоненты - особенности реализации, иерархия классов. Дополнительные библиотеки компонентов. Модель обработки событий в JSF-приложениях.

### Особенности реализации:

+ Интерфейс строится из компонентов.
+ Компоненты расположены на страницах  Facelets-шаблонах или страницах JSP.
+ Компоненты реализуют интерфейс javax.faces.component.UIComponent.
+ Можно создавать собственные компоненты.
+ Компоненты на странице объединены в древовидную структуру — представление.
+ Корневым элементов представления является экземпляр класса javax.faces.component.UIViewRoot.

### Иерархия классов

![GitHub Logo](/pictures/classHierarchy.png)

```css
-- javax.faces.component.UIComponent
---- javax.faces.component.UIComponentBase
------ javax.faces.component.UIOutput
-------- javax.faces.component.UIInput
---------- javax.faces.component.UISelectOne
---------- javax.faces.component.UISelectMany
```

### Дополнительные библиотеки компонентов

JSF - это веб-среда MVC, управляемая запросами, для создания пользовательских интерфейсов с использованием компонентов.

И PrimeFaces/RichFaces/IceFaces являются компонентами/JSF-библиотеками, которые вы можете использовать поверх JSF

RichFaces: это библиотека компонентов с поддержкой Ajax с открытым исходным кодом для JavaServer Faces

ICEfaces: open-source, Java JSF расширение и богатые компоненты, Ajax без JavaScript

PrimeFaces: Структура Ajax с компонентами JSF

### Модель обработки событий в JSF-приложениях

1. Отправляется request
2. Формирование представления 
    - JSF Runtime формирует представление (начиная с UIViewRoot):
      - Создаются объекты компонентов.
      - Назначаются слушатели событий, конвертеры и валидаторы.
      - Все элементы представления помещаются в FacesContext.
    - Если это первый запрос пользователя к странице JSF, то формируется пустое представление.
    - Если это запрос к уже существующей странице, то JSF Runtime синхронизирует состояние компонентов представления с клиентом.
3. Получение значений компонентов 
    - На стороне клиента все значения хранятся в строковом формате — нужна проверка их корректности:
        - Вызывается конвертер в соответствии с типом данных значения.
    - Если конвертация заканчивается успешно, значение сохраняется в локальной переменной компонента.
    - Если конвертация заканчивается неудачно, создаётся сообщение об ошибке, которое помещается в FacesContext.
4. Валидации значений компонентов
    - Вызываются валидаторы, зарегистрированные для компонентов представления.
    - Если значение компонента не проходит валидацию, формируется сообщение об ошибке, которое сохраняется в FacesContext.
5. Обновление значений компонентов 
    - Если данные валидны, то значение компонента обновляется.
    - Новое значение присваивается полю объекта компонента.
6. Фаза вызова приложения
    - Управление передаётся слушателям событий.
    - Формируются новые значения компонентов.
7. JSF Runtime обновляет представление в соответствии с результатами обработки запроса.
   - Если это первый запрос к странице, то компоненты помещаются в иерархию представления.
   - Формируется ответ сервера на запрос.
   - На стороне клиента происходит обновление страницы.
   
Фазы жизненного цикла:
- Восстановление представления (Restore View) : для запрошенной страницы либо извлекается дерево компонентов, если страница уже открывалась, либо создается новое дерево компонентов, если страница запрашивается впервые. Для компонентов запрашиваемой страницы восстанавливаются их прошлые состояния (форма заполняет вводимыми значениями).
- Применение значений запроса (Apply Request Values) : анализ HTTP запроса, объектам дерева компонентов присваиваются соответствующие им значения из запроса. Если к компоненту подключен конвертер, то значение обрабатывается/конвертируется. При возникновении ошибки, все последующие шаги пропускаются. Если компонент ввода (UIInput) содержит валидатор и имеет свойство immediate="true", то этот компонент будет валидироваться в этой фазе. Также, при необходимости, события (нажатие кнопки или ссылки) добавляются в очередь событий.
- Выполнение проверок (Process Validations) : преобразование строковых значений в "локальные значения" и применение валидации дерева компонентов. Если в результате валидации компонента возникает ошибка, то она сохраняется и JSF пропускает все последующие шаги обработки запроса до фазы "Формирования ответа" для предупреждения пользователя об ошибке.
- Обновление значений модели (Update Model Values) : обновление свойства managed bean информацией из дерева компонентов.
- Выполнение приложения (Invoke Application) : JSF обрабатывает события, которые были сгенерированы нажатием на кнопки и ссылки. На данном этапе также решаются вопросы, связанные с навигацией приложения, если это необходимо. Если один из компонентов формы имеет свойство immediate="true", то он должен был быть обработан в фазе "Применение значений запроса".
- Формирование ответа (Render Response) : JSF создает ответ, основываясь на данных, полученных на предыдущих шагах. Информация страницы обновляется данными из managed bean и генерируется html страница с помощью Renderers. Если на предыдущих шагах происходили какие-либо ошибки, то они инкапсулируются в тег <messages>.
- Страница Java Server Faces представлена в виде дерева компонентов. Корневым компонентом дерева является UIViewRoot.

Первоначальный запрос - это запрос, который браузер выполняет для отображения страницы с ${customer.name}тегом. Обратная передача происходит, когда браузер публикует некоторые или все значения страницы, а затем та же самая страница, которая была отправлена ​​в первую очередь, возвращается клиенту. Это могло произойти, например, в результате ошибки проверки.

- initial request passes only Restore View & Render Response phases, while postback request process under all phases (Apply Request Values, Validations Phase, etc).

- Initial request is created by clicking a link, pasting an URL in address bar, while a postback request is create by posting a form by clicking a submit button or any post request.

Not all the time. All the 6 phases will be executed in case of an initial GET request with view parameters. – Shirgill Farhan Mar 21 '16 at 12:44 
This answer is not 100% correct. 

@ShirgillFarhanAnsari 's comment is correct and the answer is better updated. – Koray Tugay May 18 '16 at 7:51

- The initial and postback requests in JSF go through a JSF life cycle. When an initial request is processed, it only executes the Restore View and Render Response phases, because there is no user input or actions to process. On the other hand, when the life cycle handles a postback request, it executes all of the phases.

Moreover, JSF supports AJAX requests. An AJAX request consists of two parts: partial processing (the execute attribute) and partial rendering (the render attribute).

#### Ajax Request Lifecycle

An Ajax request varies from other typical JavaServer Faces requests, and its processing is also handled differently by the JavaServer Faces lifecycle.

As described in Partial Processing and Partial Rendering, when an Ajax request is received, the state associated with that request is captured by the javax.faces.context.PartialViewContext. This object provides access to information such as which components are targeted for processing/rendering. The processPartial method of PartialViewContext uses this information to perform partial component tree processing and rendering.

The execute attribute of the f:ajax tag identifies which segments of the server-side component tree should be processed. Because components can be uniquely identified in the JavaServer Faces component tree, it is easy to identify and process a single component, a few components, or a whole tree. This is made possible by the visitTree method of the UIComponent class. The identified components then run through the JavaServer Faces request lifecycle phases.

Similar to the execute attribute, the render attribute identifies which segments of the JavaServer Faces component tree need to be rendered during the render response phase.

During the render response phase, the render attribute is examined. The identified components are found and asked to render themselves and their children. The components are then packaged up and sent back to the client as a response.

Запрос Ajax отличается от других типичных запросов JavaServer Faces, и его обработка также по-разному обрабатывается жизненным циклом JavaServer Faces.

Как описано в разделах «Частичная обработка и частичная отрисовка» , при получении запроса Ajax состояние, связанное с этим запросом, фиксируется в javax.faces.context.PartialViewContext. Этот объект обеспечивает доступ к информации, например, о том, какие компоненты предназначены для обработки / рендеринга. processPartialМетод PartialViewContextиспользует эту информацию для выполнения частичного компонента обработки дерева и рендеринга.

executeАтрибут f:ajaxтег определяет , какие сегменты дерева компонентов на стороне серверов должны быть обработаны. Поскольку компоненты могут быть однозначно идентифицированы в дереве компонентов JavaServer Faces, легко идентифицировать и обрабатывать отдельный компонент, несколько компонентов или все дерево. Это стало возможным благодаря visitTreeметоду UIComponentкласса. Затем идентифицированные компоненты проходят этапы жизненного цикла запроса JavaServer Faces.

Подобно executeатрибуту, renderатрибут определяет, какие сегменты дерева компонентов JavaServer Faces должны быть визуализированы во время фазы ответа на визуализацию.

На этапе отклика на рендеринг renderпроверяется атрибут. Идентифицированные компоненты находят и просят отобразить самих себя и своих детей. Затем компоненты упаковываются и отправляются обратно клиенту в качестве ответа.

## 28.Конвертеры и валидаторы данных.

JSF имеет встроенные конвенторы и позволяет создавать специализированные.

### Стандартные конвертеры JSF

- javax.faces.BigDecimal
- javax.faces.BigInteger
- javax.faces.Boolean
- javax.faces.Byte
- javax.faces.Character
- javax.faces.DateTime
- javax.faces.Double
- javax.faces.Float

```jsf
<h:outputLabel value="Age" for="age" accesskey="age" />
<h:inputText id="age" size="3" value="#{contactController.contact.age}">
</h:inputText>
```

```xhtml
<h:outputLabel value="Birth Date" for="birthDate" accesskey="b" />
<h:inputText id="birthDate" value="#{contactController.contact.birthDate}">
<f:convertDateTime pattern="MM/yyyy"/>
</h:inputText>
```

### Cпециализированные конвертеры

1. Создать класс, реализующий интерфейс Converter
2. Реализовать метод getAsObject(), для преобразования строкового значения поля в объект.
3. Реализовать метод getAsString.
4. Зарегистрировать конвертер в контексте Faces в файле faces-config.xml, используя элемент <converter>. 

__файл faces-config.xml__
```xml  
<converter>
  <converter-for-class>
    com.arcmind.contact.model.Group
  </converter-for-class>
  <converter-class>
    com.arcmind.contact.converter.GroupConverter (com.arcmind.contact.converter.TagConverter)
  </converter-class>
</converter>
```

### Валидаторы

####  Существует 4 типа валидаторов

1. С помощью встроенных компонентов
2. На уровне приложения
3. С помощью проверочных методов серверных объектов (inline-валидация)
4. С помощью специализированных компонентов, реализующих интерфейс Validator

#### 1. С помощью встроенных компонентов

1. DoubleRangeValidator
2. LongRangeValidator
3. LengthValidator

```html
<%-- возраст (age) --%>
<h:outputLabel value="Age" for="age" accesskey="age" />
<h:inputText id="age" size="3" value="#{contactController.contact.age}">
<f:validateLongRange minimum="0" maximum="150"/>
</h:inputText>
<h:message for="age" errorClass="errorClass" />
```

#### 2. На уровне приложения

Это непосредственно бизнес-логика. Заключается в добавлении в методы управляемых bean-объектов кода, который использует модель приложения для проверки уже помещенных в нее данных. 

#### 3. С помощью проверочных методов серверных объектов

Для типов данных, не поддерживаемых стандартными валидаторами, например, адресов электронной почты, можно создавать собственные валидирующие компоненты

#### 4. С помощью специализированных компонентов, реализующих интерфейс Validator

JSF позволяет создавать подключаемые валидирующие компоненты, которые можно использовать в различных Web-приложениях.

Это должен быть класс, реализующий интерфейс Validator, в котором реальзован метод validate(). Необходимо зарегистрировать валидатор в файле faces-config.xml. После этого можно использовать тег <f:validator/> на страницах JSP.

__faces-config.xml__
```xml
<validator>
  <validator-id>arcmind.zipCode</validator-id>
  <validator-class>com.arcmind.validators.ZipCodeValidator</validator-class>
</validator>
```


## 29.Представление страницы JSF на стороне сервера. Класс UIViewRoot.

За представление отвечают:

- UI Component. Объект с состоянием, методами, событиями, который содержится на сервере и отвечает за взаимодействие с пользователем (визуальный компонент). Каждый UI компонент содержит метод метод render для прорисовки самого себя, согдасно правилам в классе Render

- Renderer - Отвечает за отображение компонента и преобразование ввода пользователя

- Validator, Convertor

- Backing bean - собирает значения из компонент, реагирует на события, взаимодействует с бизнес-логикой.

- Events, Listeners, Message

- Navigation - =правила навигации между страницами, задаются в виде xml документа

- UIViewRoot

Объект UIViewRoot дает представление JSF, он связан с активным FacesContext. JSF реализация создаёт представление при первом обращении (запросе), либо восстанавливает уже созданное. Когда клиент отправляет форму (postback), JSF конвертирует отправленные данные, проверяет их, сохраняет в managed bean, находит представление для навигации, восстанавливает значения компонента из managed bean, генерирует ответ по представлению. Все эти действия JSF описываются с помощью 6 упорядоченных процессов.

process update render execute 

execute = process and update = render

## 30.Управляемые бины - назначение, способы конфигурации. Контекст управляемых бинов.

__Управляемые бины__ – классы, содержащие параметры и методы для обработки данных с компонентов. Должны иметь методы get и set/ Используются для обработки UI и валидации данных. Жихненным цикллом управляет JSF Runtime Env. Доступ из JSP-страниц осуществляется с помощью языка выражений (EL). Конфигурация задается либо в faces-config.xml, либо с помощью аннотаций.

Конфиуграция управляемых бинов
faces-config.xml

```xml
<managed-bean>
  <managed-bean-name>customer</managed-bean-name>
  <managed-bean-class>CustomerBean</managed-bean-class>
  <managed-bean-scope>request</managed-bean-scope>
  <managed-property>
    <property-name>areaCode</property-name>
    <value>#{initParam.defaultAreaCode}</value>
  </managed-property>
</managed-bean>
```

С помощью аннотаций

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
  @ManagedProperty(value="#{initParam.defaultAreaCode}" name="areaCode")
  private String areaCode;
  ...
}
```

A JSF application is just like any other Java technology-based web application; it runs in a Java servlet container, and contains:


__Managed bean__ - бин, зарегистрированный в JSF, управляется JSF платформой. Мanaged bean используются в качестве модели для компонентов и имеют свою область жизни (scope), которую можно задать при помощи аннотации или в конфигурационном файле faces-config.xml.

У управляемых бинов есть контекст, который оперделяет продолжительность жизни. Он задается аннотацией.

Аннотации

- @RequestScoped - используется по умолчанию. Создаётся новый экземпляр managed bean на каждый HTTP запрос (и при отправке, и при получении). Контекст - запрос

- @SessionScoped - экземпляр создаётся один раз при обращении пользователя к приложению, и используется на протяжении жизни сессии. Managed bean обязательно должен быть Serializable. Контекст — сессия.

- @ApplicationScoped - экземпляр создаётся один раз при обращении и используется на протяжении жизни всего приложения. Не должен иметь состояния, а если имеет, то должен синхронизировать доступ, так как доступен для всех пользователей. Контекст — приложение.

- @ViewScoped - экземпляр создаётся один раз при обращении к странице, и используется ровно столько, сколько пользователь находится на странице (включая ajax запросы). Контекст — страница, представление.

- @CustomScoped(value="#{someMap}") - экземпляр создаётся и сохраняется в Map. Программист сам управляет областью жизни.

- @NoneScoped - экземпялр создаётся, но не привязывается ни к одной области жизни. Применяется когда к нему обращаются другие managed bean'ы, имеющие область жизни. Бин без контекста.

## 31.Конфигурация JSF-приложений. Файл faces-config.xml. Класс FacesServlet.

The responsibilities of the application architect include the following:

- Registering back-end objects with the application so that all parts of the application have access to them

- Configuring backing beans and model beans so that they are instantiated with the proper values when a page makes reference to them

- Defining navigation rules for each of the pages in the application so that the application has a smooth page flow

- Packaging the application to include all the pages, objects, and other files so that the application can be deployed on any compliant container

web.xml is the deployment descriptor file and it is part of the servlet standard for web applications. It is used to determine how URLs map to servlets, which URLs require authentication, and other information. This file resides in the app's WAR under the WEB-INF/ directory.

faces-config.xml is usually the name for the application configuration resource file in JavaServer Faces technology and provides a portable configuration format (as an XML document) for configuring resources.An application architect creates one or more files, called application configuration resource files, that use this format to register and configure objects and to define navigation rules.

__________________________________________________________________________________________________

__faces-config.xml__ — конфигурационный файл JavaServer Faces, который должен находиться в директории WEB-INF проекта. В этом файле могут находиться настройки managed bean, конвертеры, валидаторы, локализация, навигации и другие настройки, связанные с JSF

Объявление управляемого объекта: имя объекта задается с помощью <managed-bean-name>, полное имя класса - <managed-bean-class>. Класс управляемого объекта обязан содержать конструктор без параметров.

<managed-bean-scope>> определяет, где JSF будет искать объект. Если объект привязан к представлению и не существует на момент обращения, то JSF создаст его автоматически с помощью API универсального языка выражений EL. Объект будет доступен в течение обработки одного запроса.

По умолчанию используется faces-config, но можно использовать дополнительные конфиги, перечислив их в web.xml.

__Способ 1 — через faces-confg.xml:__

```xml
<?xml version="1.0" encoding="UTF-8"?>
<faces-config xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd" 
    version="1.2">
  <managed-bean>
    <managed-bean-name>calculator</managed-bean-name>
    <managed-bean-class>Point</managed-bean-class>
    <managed-bean-scope>request</managed-bean-scope>
  </managed-bean>
</faces-config>
```

__Способ 2 (JSF 2.0) — с помощью аннотаций:__

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {

    @ManagedProperty(value="#{initParam.defaultAreaCode}", name="areaCode")
    private String areaCode;
}
```

#### Класс FacesServlet:
- Обрабатывает запросы с браузера.
- Формирует объекты-события и вызывает методы-слушатели.

## 32.Навигация в JSF-приложениях.

https://coderlessons.com/tutorials/veb-razrabotka/vyuchi-jsf/jsf-navigatsiia-po-stranitsam

Правила навигации — это правила, предоставляемые JSF Framework, которые описывают, какое представление должно отображаться при нажатии кнопки или ссылки.

Правила навигации могут быть определены в файле конфигурации JSF с именемface-config.xml. Они могут быть определены в управляемых компонентах.

Правила навигации могут содержать условия, на основании которых может быть отображено полученное представление. JSF 2.0 также обеспечивает неявную навигацию, в которой нет необходимости определять правила навигации как таковые.

Механизм нафигации JSF позволяет определить связь между логическим признаком результата и следующим представлением. Реализуется объектами NavigationHandler. Навигация осуществляется с помощью правил перехода.

Ссылку можно добавить тремя различными способами:

- С помощью commandLink и обычного правила перехода, определяемого в faces-config.xml
```xml
<navigation-rule>
  <navigation-case>
    <from-outcome>CALCULATOR</from-outcome>
    <to-view-id>/pages/calculator.jsp</to-view-id>
  </navigation-case>
</navigation-rule>
```


- С помощью commandLink и правила перехода, использующего элемент .

- Связывание с помощью прямой ссылки (элемента <h:outputLink>)

```jsp
<h:outputLink value="pages/calculator.jsf">
<h:outputText value="Calculator Application (outputlink)"/>
</h:outputLink>
```

#### Форвард против перенаправления

- JSF по умолчанию выполняет пересылку страницы сервера при переходе на другую страницу, и URL-адрес приложения не изменяется.

- Чтобы включить перенаправление страницы, добавьте Face-Redirect = True в конце имени представления.

```jsp
<h:form>
   <h3>Forward</h3>
   <h:commandButton action = "page1" value = "Page1" />
   <h3>Redirect</h3>
   <h:commandButton action = "page1?faces-redirect = true" value = "Page1" />
</h:form>
```

In Java environments, client sessions are identified by a "jsessionid", a unique identifier that lets the server associate a series of client requests as being from the same client. Normally the jsessionid is held in a JSESSIONID cookie, but not all clients have cookies enabled. Servlet engines work around this limitation by adding the jsessionid into the URLs presented to the client so that each client click includes in the request URL itself the jsessionid value. Servlets provide a response.encodeURL() method that programmers are instructed to use when outputting URLs. This method gives the servlet environment the opportunity to add the jsessionid value to the URL when it deems it necessary.

You can get rid of jsessionid path fragment in URL by adding the following to web.xml:

```xml
<session-config>
    <tracking-mode>COOKIE</tracking-mode>
</session-config>
```

It basically disables URL-rewriting.

### Реализуется экземплярами класса NavigationHandler.
- Правила задаются в файле faces-confg.xml:
```xml
<navigation-rule>
    <from-view-id>/pages/inputname.xhtml</from-viewid>
    <navigation-case>
        <from-outcome>sayHello</from-outcome>
        <to-view-id>/pages/greeting.xhtml</to-view-id>
     </navigation-case>
    <navigation-case>
        <to-view-id>/pages/goodbye.xhtml</to-view-id>
    </navigation-case>
 </navigation-rule>
```

-- Пример перенаправления на другую страницу:
```jsp
<h:commandButton id="submit" action="sayHello" value="Submit" />
```


## 33.Доступ к БД из Java-приложений. Протокол JDBC, формирование запросов, работа с драйверами СУБД.

ODBC - это API данных, разработанный для языка программирования Java. Он был выпущен вместе с JDK 1.1 компанией Sun Microsystems (первоначальные владельцы Java). И его текущей версией является JDBC 4.0 (в настоящее время распространяется с JAVA SE6). Пакеты Java.sql и javax.sql содержат классы JDBC. Это интерфейс, который помогает клиенту получить доступ к системе баз данных, предоставляя методы для запроса и обновления данных в базах данных. JDBC больше подходит для объектно-ориентированных баз данных. Вы можете получить доступ к любой ODBC-совместимой базе данных, используя мост JDBC-ODBC.

#### В чем разница между ODBC и JDBC?

ODBC - это открытый интерфейс, который может использоваться любым приложением для связи с любой системой баз данных, а JDBC - это интерфейс, который может использоваться приложениями Java для доступа к базам данных. Следовательно, в отличие от JDBC, ODBC не зависит от языка. Но с помощью моста JDBC-к-ODBC Java-приложения могут также общаться с любой ODBC-совместимой базой данных.

Для взаимодействия Java-апплета с внешним сервером баз данных разработан специализированный протокол JDBC, который, фактически, сочетает функции шлюзования между интерпретатором мобильных Java-кодов и интерфейсом ODBC (Open Data Base Connectivity). JDBC - это разработанный JavaSoft прикладной программный SQL интерфейс API JDBC к базам данных. Этот API позволяет использовать стандартный набор процедур высокого уровня для доступа к различным БД.

Архитектура JDBC состоит из двух уровней: JDBC API, который обеспечивает связь между приложением и менеджером JDBC и драйвер JDBC API, который поддерживает связь между JDBC менеджером и драйвером (рис.3). Разработчики имеют возможность взаимодействовать напрямую с ODBC посредством моста JDBC-ODBC.

### Driver'ы

__JDBC__ – Java DataBase Connectivity – соединение с базами данных на Java. Это стандарт взаимодействия с БД. Его интерфейс поставляется в стандартной JDK в виде пакета java.sql. Какой бы библиотекой для работы с базой данных вы ни пользовались, в ее основе почти всегда лежит низкоуровневый JDBC.

__JDBC-драйвер__ – реализация JDBC для определенной базы данных. В приложении может быть зарегистрировано несколько разных драйверов. При соединении к базе, нужный выбирается исходя из URL соединения. Например, для jdbc:mysql://localhost:3306/db_name будет использован MySQL JDBC драйвер (при наличии). Драйверы делятся на 4 типа:

__Тип 1__ – JDBC-ODBC мост. Делегирует работу с базой установленному в системе ODBC-драйверу. Платформозависимый. Не поддерживается с Java 8.

__Тип 2__ – Native API. Делегирует работу с базой библиотеке, установленной в системе. Платформозависимый. Библиотеки в отличие от ODBC специфичны для конкретной базы, поэтому такой драйвер обычно работает быстрее.

__Тип 3__ – драйвер сетевого протокола. Работает с промежуточным слоем (JavaEE сервером приложений), который транслирует запросы в сетевой протокол, с которым работает конкретная БД. Такой драйвер полностью реализован на Java.

__Тип 4__ – драйвер протокола БД/тонкий драйвер. Полная реализация протокола взаимодействия с базой данных. Отличается от типа 3 тем, что здесь логика протокола находится не на внешнем промежуточном слое, а прямо в самом драйвере.

### Интерфейс Driver

- java.sql.Driver
- Отвечает за связь с БД
- Метод Connection connect(String url, Properties info)
- Используется для написания драйверов для СУБД

Преза Гаврилова https://se.ifmo.ru/documents/10180/1422934/prog-lec2.5v5.pdf/8f72469d-3693-9331-111c-054351cfa97e


## 34.Концепция ORM. Библиотеки ORM в приложениях на Java. Основные API. Интеграция ORM-провайдеров с драйверами JDBC.


Достоинства

Среди достоинств ORM выделяют:

- наличие явного описания схемы БД, представленное в терминах какого-либо языка программирования, которое находится и редактируется в одном месте;
- возможность оперировать элементами языка программирования, т.е. классами, объектами, атрибутами, методами, а не элементами реляционной модели данных;
- возможность автоматического создания SQL-запросов, которая избавляет от необходимости использования языка для описания структуры БД (Data Definition Language) и языка манипулирования данными (Data Manipulation Language) при проектировании БД и изменении её схемы соответственно;
- не нужно создавать новые SQL-запросы при переносе на другую систему управления базами данных, поскольку за это отвечает низкоуровневый драйвер ORM.
- ORM избавляет от необходимости работы с SQL и проработки значительного количества программного кода, который зачастую однообразен и подвержен ошибкам.
- код, генерируемый ORM гипотетически проверен и оптимизирован, следовательно не нужно беспокоиться о его тестировании;
- развитые реализации ORM поддерживают отображение наследования и композиции на таблицы;
- ORM дает возможность изолировать код программы от подробностей хранения данных.

Недостатки

Среди недостатков ORM выделяются:

- Дополнительная нагрузка на программиста, которому, в случае использования ORM необходимо изучать этот некий «дополнительный слой» между программной и базой данных, который к тому же создает дополнительный уровень абстракции — объекты ORM. В связи с этим могут возникнуть вопросы соответствия особенностям ООП и соответствующим реляционным операциям. Эту проблему называют impedance mismatch, а сама реализация ORM ведет к увеличению объема программного кода и снижению скорости работы программы. Однако, с другой стороны, ORM наглядно и в одном месте концентрирует различие между реляционной и объектно-ориентированной парадигмами, что нельзя назвать недостатком;
- Появление трудно поддающихся отладке ошибок в программе, если присутствуют ошибки в реализации ORM, например, ошибки в реализации кэширования ORM, такие как согласование изменений в разных сессиях.
- Недостатки реализаций, которые могут иметь определенные ограничения и выдвигать определенные требования, например, требование собственной схемы базы данных и ограничение на средства создания базы данных. Также может отсутствовать возможность написать в явном виде SQL-запрос.
- Требуются отдельные таблицы в случае прямого отображения классов в таблицы и необходимости отображения атрибутов множественного характера.
- Если говорить о главном минусе ORM, снижении производительности, то причина этого состоит в том, что большинство из ORM нацелены на обработку значительного большего количества различных сценариев использования данных, чем в случае отдельного приложения. В случае небольших проектов, которые не сталкиваются с высокой нагрузкой, применение ORM очевидно, особенно, если учесть такой важный критерий разработки, как время. «То, что с легкостью пишется с использованием ORM за неделю, можно реализовывать ни один месяц собственными усилиями».[Источник 2]


ORM ― Object/Relational Mapping ― преобразование данных из объектной формы в реляционную и наоборот.

## 35.Библиотеки ORM Hibernate и EclipseLink. Особенности, API, сходства и отличия.

Но время шло и разработчики каждый раз сталкивались с необходимостью писать однотипный и ненужный "обслуживающий" код (так называемый Boilerplate code) для тривиальных операций по сохранению Java объектов в БД и наоборот, созданию Java объектов по данным из БД.  И тогда для решения этих проблем на свет появилось такое понятие, как ORM.

ORM — Object-Relational Mapping или в переводе на русский объектно-реляционное отображение. Это технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования. Если упростить, то ORM это связь Java объектов и записей в БД:

EclipseLink is more standards compliant, since it is the reference implementation for JPA 2, Hibernate has some compliancy issues, but is more mature.

One of the main benefits of EclipseLink is that you can call native SQL functions directly in your JPQL queries. In Hibernate this is not directly possible.

But Hibernate has a bigger community, better documentation and also better error messages.

EclipseLink больше соответствует стандартам, поскольку это эталонная реализация для JPA 2, Hibernate имеет некоторые проблемы с совместимостью, но он более зрелый.

Одним из основных преимуществ EclipseLink является то, что вы можете вызывать собственные функции SQL непосредственно в своих запросах JPQL. В Hibernate это невозможно напрямую.

Но Hibernate имеет большее сообщество, лучшую документацию, а также лучшие сообщения об ошибках.

#### Hibernate:

ORM-фреймворк от Red Hat, разрабатывается с 2001 г.

Ключевые особенности:
- Таблицы БД описываются в XML-файле, либо с помощью аннотаций.
- 2 способа написания запросов — HQL и Criteria API.
- Есть возможность написания native SQL запросов.
- Есть возможность интеграции с Apache Lucene для полнотекстового поиска по БД (Hibernate Search).

#### EclipseLink

ORM-фреймворк от Eclipse Foundation.

Ключевые особенности:
- Основан на кодовой базе Oracle TopLink.
- Является эталонной реализацией (reference implementation) для JPA.


Hibernate одна из самых популярных открытых реализаций последней версии спецификации (JPA 2.1). Даже скорее самая популярная, почти стандарт де-факто. То есть JPA только описывает правила и API, а Hibernate реализует эти описания, впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA


## 36.Технология JPA. Особенности, API, интеграция с ORM-провайдерами.

ORM — это по сути концепция о том, что Java объект можно представить как данные в БД (и наоборот). Она нашла воплощение в виде спецификации JPA — Java Persistence API. 

Спецификация — это уже описание Java API, которое выражает эту концепцию. Спецификация рассказывает, какими средствами мы должны быть обеспечены (т.е. через какие интерфейсы мы сможем работать), чтобы работать по концепции ORM. И как использовать эти средства.

Реализацию средств спецификация не описывает. Это даёт возможность использовать для одной спецификации разные реализации. Можно упростить и сказать, что спецификация — это описание API.

Реализации JPA ещё называют JPA Provider. Одной из самых заметных реализаций JPA является Hibernate. Поэтому, предлагаю её и рассмотреть.

Java-стандарт (JSR 220, JSR 317), который определяет:
- как Java-объекты хранятся в базе;
- API для работы с хранимыми Java-объектами;
- язык запросов (JPQL);
- возможности использования в различных окружениях

###Что даёт использование JPA?

- Достижение лучшей переносимости.
- Упрощение кода.
- Сокращение времени разработки.
- Независимость от ORM-фреймворков.

## 37. Платформа Java EE. Спецификации и их реализации.

Java EE — это платформа, построенная на основе Java SE, которая предоставляет API и среду времени выполнения для разработки и запуска крупномасштабных, многоуровневых, масштабируемых, надежных и безопасных сетевых приложений.

Подобные приложения называют корпоративными (Enterprise applications), так как они решают проблемы, с которыми сталкиваются большие бизнесы. 

Java EE представляет из себя набор спецификаций и документации, описывающий архитектуру серверной платформы для задач средних и крупных предприятий.
Сервер приложений Java EE (часто называемый контейнером) — это реализация системы в соответствии со спецификацией, обеспечивающая работу модулей с логикой конкретного приложения.

Деление на платформы (Java SE, Java EE, Java Card ...) появилось в Java EE 6 и позволяет сделать более «лёгкими» приложения, которым не нужен полный стек технологий Java EE. Существует только 2 профиля — Full и Web. 	Сервер приложений может реализовывать спецификации не всей платформы, а конкретного профиля.

###Отличие Spring от JavaEE

Конкурентном Java EE считается Spring Framework. Если взглянуть на развитие двух данных платформ, выходит интересная картина. Первые версии Java EE были созданы при участии IBM. Они вышли крутыми, но неповоротливыми, тяжеловесными, неудобными в использовании. Разработчики плевались из-за необходимости поддерживать большое количество конфигурационных файлов и из-за прочих причин, усложняющих разработку.

В то же время на свет появился Spring IoC. Это была маленькая, красивая и приятная в обращении библиотека. В ней также использовался конфигурационный файл, но в отличии от Java EE, он был один. Простота Spring привела к тому, что практически все стали использовать данный фреймворк в своих проектах. 

А далее Spring и Java EE начали свой путь к одному и тому же, но с разных концов. Компания Pivotal Software, разработчик Spring, стали выпускать проект за проектом, чтобы покрыть все возможные и невозможные потребности Java-разработчиков. Постепенно то, что раньше называлось Spring, сначала стало одним из проектов, а потом и вовсе слилось с несколькими другими проектами в Spring Core. Все это привело к неминуемому усложнению Spring по сравнению с тем, каким он был изначально. Со временем следить за всем клубком зависимостей спринга стало уж совсем сложно, и возникла потребность в отдельной библиотеке, которая стала бы загружать и запускать все сама (сейчас где-то икнул так горячо любимый Spring Boot).

Все это время JCP работал над одним — добиться максимального упрощения всего, что только можно внутри Java EE. В итоге в современном EJB для описания бина достаточно указать одну аннотацию над классом, что предоставляет разработчику доступ ко всей мощи технологии Enterprise Java Beans. И подобные упрощения затронули каждую спецификацию внутри Java EE. 

В итоге по функционалу Spring и Java EE примерно разделяют паритет. Где-то что-то лучше, где-то что-то хуже, но если смотреть глобально, больших различий нет. То же самое касается сложности работы. И Spring, и Java EE являются превосходными инструментами. Пожалуй, лучшими из того, что сейчас есть, для построения корпоративных сетевых приложений на языке Java. 

!! Однако, Java EE может работать в общем случае только в рамках Enterprise Application Server’a (Tomcat таковым не является), а приложение на Spring стеке может работать на чем угодно (на том же Tomcat), и даже вообще без сервера (так как запустит его внутри себя самостоятельно).

!! Это делает Spring идеальным инструментом для разработки небольших приложений с GUI на Front-end или для микросервисной архитектуры. Но отказ от зависимости от серверов приложений отрицательно сказался на масштабируемости Spring-приложений.

А Java EE хорошо подходит для реализации масштабируемого монолитного кластерного приложения.


Пример Web profile: Tomcat

Пример Full profile: Glassfish

### Основные концепции

- Приложения строятся из компонентов, работающих под управлением контейнеров.
- Используются следующие принципы:
    - Inversion of Control (IoC) + Contexts & Dependency Injection (CDI).
    - Location Transparency.

https://javarush.ru/groups/posts/2637-vvedenie-v-java-ee - классное объяснение 


https://ru.photo-555.com/2403908-java-ee-interview-questions - вопросы с собеса

## 38. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.

Есть такая штука - JNDI - набор API, позволяющий доставать объекты из контейнера по их именам. По сути, это замена обращению по ссылкам, и благодаря этому легко реализуется Dependency Lookup и Dependency Injection. Хранение объектов в таком случае можно представить как Map, где ключи - это имена, а значения - нужные объекты (например, ссылки на них).

#### Два варианта использования JNDI:

- CDI (аннотации) — работает только в managed компонентах. 
- Прямой вызов API — работает везде.

```java
// Пример получения ссылки на JDBC datasource. DataSource dataSource = null;
public class JNDI { 

public void jndi() {
  try {
   // Инициализируем контекст по умолчанию. 
   Context context = new InitialContext(); 
   dataSource = (DataSource) context.lookup("Database"); 
  } catch (NamingException e) {
    // Ссылка не найдена
  }
}


}
```

### IoC - Inversion of Control (применительно к Java EE):
- Жизненным циклом компонента управляет контейнер (а не программист).
- Объекты создает не программист (используя new), а контейнер IoC. Применяется далеко не ко всем объектам в приложении, а только к  управляемым (в Spring это классы с аннотациями @Component, @Service и т.д., в EJB — бобы @Stateless, @Stateful, @MessageDriven).
- За взаимодействие между компонентами отвечает тоже контейнер.

### CDI — Contexts and Dependency Injection (позволяет снизить (или совсем убрать) зависимость компонента от контейнера):
как бы компонент и так зависит от контейнера, так как тот его порождает, но тут о другом: __программист, когда пишет компонент, он не зависит от API, предоставляемых контейнером__

- Не требуется реализации каких-либо интерфейсов. 
- Не нужны прямые вызовы API.
- Реализуется через аннотации.

Пример CDI (JSF Managed Bean):

```java
@ManagedBean(name="message")
@SessionScoped
public class MessageBean implements Serializable {
   //business logic and whatever methods
}


@ManagedBean
@SessionScoped
public class HelloBean implements Serializable {

   @ManagedProperty(value="#{message}") //ЭТО И ЕСТЬ CDI
   private MessageBean messageBean;

   //must povide the setter method
   public void setMessageBean(MessageBean messageBean) {
this.messageBean = messageBean; }
}
```
#### Еще одна интерпретация CDI

Вместо построения зависимостей в компоненте, где они нужны:

```java
public class Something {
  private Dependency dependency = new Dependency();
}
```
Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:

```java
public class Something {
  private Dependency dependency;

  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
} 
```
Чтобы нам не пришлось вручную собирать все зависимости для создания компонентов, контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:
```java
public class SomethingDI {
  @Autowired private Dependency dependency; // Spring
  @EJB private EjbDependency ejbDependency; // EJB
}
```



### Location Transparency - прозрачность местонахождения - это что-то вроде паттерна

Инфраструктура завязана на RMI (Java API, позволяющий вызывать методы удаленных объектов)

Благодаря CDI не важно, где физически расположен вызываемый компонент — за его вызов отвечает контейнер.

Клиент имеет прокси, обращается с ней как с нужным объектом. Прокси перенаправляет его вызовы куда следует: если нужный компонент находится локально, идёт к нему обращение по ссылке; если удалённо (в другой JVM) - необходима сериализация передаваемых данных.

### Компоненты и контейнеры

Приложение состоит из компонентов и контейнера, управляющего жизненным циклом компонентов. Пример: Servlet - компонент, Glassfish - контейнер.

Голая Java EE — это просто набор спецификаций. 

Данные спецификации реализуют различные Java EE сервера.

Java EE сервер — это серверное приложение, которое реализует API-интерфейсы платформы Java EE и предоставляет стандартные службы Java EE. Серверы Java EE иногда называют серверами приложений. Данные сервера могут содержать в себе компоненты приложения, каждый из которых соответствует своему уровню в многоуровневой иерархии. Сервер Java EE предоставляет этим компонентам различные сервисы в форме контейнера.

Контейнеры — это интерфейс между размещенными на них компонентами и низкоуровневыми платформо-независимыми функциональными возможностями, поддерживающими компонент.  

Контейнеры предоставляют размещенным на них компонентам определенные службы. Например, управление жизненным циклом разработки, внедрение зависимости, параллельный доступ и т. д. Контейнеры скрывают техническую сложность и повышают мобильность.

#### В Java EE существует четыре различные типа контейнеров:

- Контейнеры апплетов выполняются большинством браузеров. При разработке апплетов можно сконцентрироваться на визуальной стороне приложения, в то время как контейнер обеспечивает безопасную среду.
- Контейнер клиентского приложения (ACC) включает набор Java-классов, библиотек и других файлов, необходимых для реализации в приложениях Java SE таких возможностей, как внедрение, управление безопасностью и служба именования.
- Веб-контейнер предоставляет базовые службы для управления и исполнения веб-компонентов (сервлетов, компонентов EJB Lite, страниц JSP, фильтров, слушателей, страниц JSF и веб-служб). Он отвечает за создание экземпляров, инициализацию и вызов сервлетов, а также поддержку протоколов HTTP и HTTPS. Этот контейнер используется для подачи веб-страниц к клиент-браузерам.
- EJB (Enterprise Java Bean) контейнер отвечает за управление и исполнение компонентов модели EJB, содержащих уровень бизнес-логики приложения. Он создает новые сущности компонентов EJB, управляет их жизненным циклом и обеспечивает реализацию таких сервисов, как транзакция, безопасность, параллельный доступ, распределение, служба именования либо возможность асинхронного вызова. 

#### Также в Java EE выделяют четыре типа компонентов, которые должна поддерживать реализация Java EE спецификации:

- Апплеты — это приложения из графического пользовательского интерфейса (GUI), выполняемые в браузере. Они задействуют насыщенный интерфейс Swing API для производства мощных пользовательских интерфейсов.
- Приложениями называются программы, выполняемые на клиентской стороне. Как правило, они относятся к графическому пользовательскому интерфейсу (GUI) и применяются для пакетной обработки.
- Веб-приложения (состоят из сервлетов и их фильтров, слушателей веб-событий, страниц JSP и JSF) — выполняются в веб-контейнере и отвечают на запросы HTTP от веб-клиентов. Сервлеты также поддерживают конечные точки веб-служб SOAP и RESTful.
- Корпоративные приложения (созданные с помощью технологии Enterprise Java Beans, службы сообщений Java Message Service, интерфейса Java API для транзакций, асинхронных вызовов, службы времени) выполняются в контейнере EJB. Управляемые контейнером компоненты EJB служат для обработки транзакционной бизнес-логики. Доступ к ним может быть как локальным, так и удаленным по протоколу RMI (или HTTP для веб-служб SOAP и RESTful).

Апплета: 

Но до сих пор эти надежды не сбылись. Проведенный недавно опрос, касающийся использования апплетов Java, показал, что они применяются менее чем на 2% из 500 самых популярных Web-сайтов. Почему? Некоторые разработчики неверно оценили накладные расходы при интерпретации байт-кода в виртуальной машине Java. У других множество нареканий вызывает защита, основанная на принципе (sandbox), который не позволяет Java использовать в полной мере локальные и удаленные службы. Третьи отмечают различия между виртуальными машинами основных браузеров, имеющихся на рынке. Так или иначе по прошествии пяти лет апплеты не оправдали ожиданий, и Web-приложения на базе HTML не были вытеснены Web-приложениями с равным уровнем переносимости и мобильности, но функционально более мощным графическим пользовательским интерфейсом.
"богатому графическому пользовательскому интерфейсу" не было визуальной среды разработки. А программировать графику вручную - задача рутинная для программиста и ненужная для дизайнера. %)

![alt text](resources/architectureJavaEE.png "Типичная архитектура Java EE приложения")

## 39. Управление жизненным циклом компонентов. Дескрипторы развёртывания.

По большей части, жизненным циклом компонентов управляет контейнер. Тем не менее, есть возможность влиять на этот процесс с помощью аннотаций / xml / прочих файлов настроек. Дескрипторы - это как раз такие файлы (в том числе xml). В них можно задавать свойства используемых в приложении компонентов: имена, ссылки, параметры. Также можно настраивать то, как итоговое приложение будет собираться и как оно будет взаимодействовать с внешним миром.

Дескриптор развёртывания - конфигурационный файл артефакта. Дескриптор развёртывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развёрнуто

Примеры дескрипторов развёртывания:
- web.xml - дескриптор развёртывания веб-приложений (упаковываемых обычно в .war архивы)
- ejb-jar.xml - дескриптор развёртывания EJB-приложения	
- application.xml - дескриптор развёртывания приложения, использующего несколько web.xml / ejb-jar.xml

## 40. Java EE API. Виды компонентов. Профили платформы Java EE.

Деление на платформы (Java SE, Java EE, Java Card ...) появилось в Java EE 6 и позволяет сделать более «лёгкими» приложения, которым не нужен полный стек технологий Java EE. Существует только 2 профиля — Full и Web. 	Сервер приложений может реализовывать спецификации не всей платформы, а конкретного профиля.

Пример Web profile: Tomcat
Пример Full profile: Glassfish

Виды компонентов: 
- веб-компоненты (сервлеты, jsp, ...) - формируют содержимое представления
- Java-бины (POJO, ManagedBean, EJB) - позволяют изменять данные и осуществлять их временное хранение, взаимодействовать с базами данных и веб-службами, а также отображать содержимое в ответ на запросы клиентов.

## 41. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.

EJB — технология разработки серверных компонентов,
реализующих бизнес-логику.

Особенности EJB:
- Возможность локального и удалённого доступа.
- Возможность доступа через JNDI или Dependency
Injection.
- Поддержка распределённых транзакций (с помощью
JTA).
- Поддержка событий.
- Жизненным циклом управляет EJB-контейнер (в составе
сервера приложений).

Компонентная модель EJB:

- EJB-компоненты инкапсулируются контейнером.
- Контейнер предоставляет клиентам проксиобъекты (proxy objects) для доступа к EJB компонентам.
- Прокси-объекты реализуют бизнес-интерфейсы
(Business Interfaces).
- Клиенты вызывают методы бизнесинтерфейсов.

Sessions Beans:
- Предназначены для синхронной обработки вызовов.
- Вызываются посредством обращения через API.
- Могут вызываться локально или удалённо.
- Могут быть endpoint'ами для веб-сервисов.
- CDI — аннотация @EJB.
- Не обладают свойством персистентности. (Персистентность в программировании означает способность состояния существовать дольше, чем процесс, создавший его)
- Можно формировать пулы бинов (за
исключением @Singleton).

Stateless Session Beans:

- Не сохраняют состояние между
последовательными обращениями клиента.
- Нет привязки к конкретному клиенту.
- Хорошо масштабируются.
- Объявление — аннотация @Stateless.

```java
package converter.ejb;
import java.math.BigDecimal;
import javax.ejb.*;
@Stateless
public class ConverterBean {
 private BigDecimal yenRate = new BigDecimal("83.0602");
 private BigDecimal euroRate = new BigDecimal("0.0093016");
 public BigDecimal dollarToYen(BigDecimal dollars) {
 BigDecimal result = dollars.multiply(yenRate);
 return result.setScale(2, BigDecimal.ROUND_UP);
 }
 public BigDecimal yenToEuro(BigDecimal yen) {
 BigDecimal result = yen.multiply(euroRate);
 return result.setScale(2, BigDecimal.ROUND_UP);
 }
}
```

Stateful Session Beans:

- «Привязываются» к конкретному клиенту.
- Можно сохранять контекст в полях класса.
- Масштабируются хуже, чем @Stateless.
- Объявление — аннотация @Stateful.

```java
@Stateful
@StatefulTimeout(unit = TimeUnit.MINUTES, value = 20)
public class CartBean implements Cart {
@PersistenceContext(unitName = "pu", type = PersistenceContextType.EXTENDED)
private EntityManager entityManager;
private List products;

@PostConstruct
private void initializeBean(){
products = new ArrayList<>();
}

@Override
public void addProductToCart(Product product) {
products.add(product);
}

@Override
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public void checkOut() {
for(Product product : products){
entityManager.persist(product);
}
products.clear();
}
}
```
Singleton Session Beans:
- Контейнер гарантирует существование строго
одного экземпляра такого бина.
- Объявление — аннотация @Singleton.
+ Один корпоративный компонент должен быть доступен нескольким потокам одновременно. 
+ Приложение нуждается в корпоративном Бобе для выполнения задач на запуск и завершение работы приложения.

Требования к классам Session Beans:

- Должен быть public классом верхнего уровня.
- Не должен быть final и/или abstract.
- Должен иметь public конструктор без
параметров.
- Не должен переопределять метод finalize().
- Должен реализовывать все методы бизнесинтерфейса(-ов).


В плюс к этому ещё есть пулы экземпляров бинов. 

Так как клиенты обращаются к проксям, реализующим бизнес-интерфейс, а с реальными объектами бинов дел не имеют, с их жизненным циклом можно вытворять разные штуки. Вот что происходит для каждого из трёх видов сессионных бинов:
- Stateful - у каждого клиента своя прокси, ведущая на свой и только свой экземпляр бина, потому что клиенту важно состояние его бина
- Stateless - у каждого клиента один и тот же интерфейс, который каким-то образом уводит пользователя к одному из экземпляров бина из пула
- Singleton - единый интерфейс и единый экземпляр заставят вас поразвлекаться с concurrency

Message driven beans выполняют метод в ответ на получение сообщения из определенной очереди JMS.

Аннотация @EJB служит для CDI и предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

Stateless or Singleton:

Я бы выбрал Stateless - сервер может генерировать множество экземпляров bean-компонента и обрабатывать входящие запросы параллельно.

Синглтон звучит как потенциальное узкое место - значение @Lock по умолчанию - @Lock (WRITE), но может быть изменено на @Lock (READ) для компонента или отдельных методов.

@Stateless позволит вам иметь несколько копий, готовых для обработки в JVM (столько, сколько позволяет память и размер пула), где, как @Singleton, в JVM есть только одна копия, даже если одна может поддерживать несколько параллельных потоков, работающих против нее.

С точки зрения производительности @Singleton было бы лучше, при условии, что используемые ресурсы позволяют длительный доступ. Однако в распределенной среде иногда происходят плохие вещи, например, могут выйти из строя ссылки базы данных или сети.

С @Stateless бином доступ более недолговечный. Кроме того, в случае сбоя он просто возродится и попытается установить новое соединение с ресурсом. Если что-то подобное происходит с синглтоном, то синглтон должен обработать его, не требуя перезапуска приложения, потому что @PostConstruct вызывается только один раз для каждой JVM.

Я бы предпочел немного отказоустойчивости по сравнению с производительностью в большинстве ситуаций, особенно в системах, которые я не контролирую.


## 42. Работа с электронной почтой в Java EE. JavaMail API.

JavaMail API - фреймворк для работы с электронной почтой в Java с поддержкой протоколов SMTP, MIME, POP и некоторые другие.
Предоставляется следующее API из пакета javax.mail:
Session - класс, открывающий дверь в мир JavaMail 
Message - абстрактный класс (используются его наследники, 
например MimeMessage)
Address - абстрактный класс
Authenticator - абстрактный класс для защиты сообщений на сервере
Transport
Store
Folder
Пример кода:
```java
	// Recipient's email ID needs to be mentioned.
      String to = "destinationemail@gmail.com";

      // Sender's email ID needs to be mentioned
      String from = "fromemail@gmail.com";
      final String username = "manishaspatil";//change accordingly
      final String password = "******";//change accordingly

      // Assuming you are sending email through relay.jangosmtp.net
      String host = "relay.jangosmtp.net";

      Properties props = new Properties();
      props.put("mail.smtp.auth", "true");
      props.put("mail.smtp.starttls.enable", "true");
      props.put("mail.smtp.host", host);
      props.put("mail.smtp.port", "25");

      // Get the Session object.
      Session session = Session.getInstance(props,
         new javax.mail.Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
               return new PasswordAuthentication(username, password);
	   }
         });

      try {
	   // Create a default MimeMessage object.
	   Message message = new MimeMessage(session);
	
	   // Set From: header field of the header.
	   message.setFrom(new InternetAddress(from));
	
	   // Set To: header field of the header.
	   message.setRecipients(Message.RecipientType.TO,
               InternetAddress.parse(to));
	
	   // Set Subject: header field
	   message.setSubject("Testing Subject");
	
	   // Now set the actual message
	   message.setText("Hello, this is sample for to check send " +
		"email using JavaMailAPI ");

	   // Send message
	   Transport.send(message);

	   System.out.println("Sent message successfully....");

      } catch (MessagingException e) {
         throw new RuntimeException(e);
      }
```




## 43. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.

### JMS

JMS, Java Message Service - это Java API (то есть набор интерфейсов и классов) для работы с Message-Oriented Middleware, изначально разработанная компанией Sun, чтобы предоставить разработчикам создавать гибкие и слабосвязанные приложения с использованием асинхронного обмена данными между приложениями (клиентами/серверами) через посредника. Асинхронность - это главная причина создания и использования JMS.

Данный набор определен в пакете javax.jms в дереве пакетов J2EE. JMS поддерживает две модели обмена сообщениями: point-to-point(точка - точка) и publish-subscribe(издатель-подписчик).

### MOM

MOM, Message-Oriented Middleware (промежуточное программное обеспечение) - подпрограммное обеспечение промежуточного слоя, ориентированное на обмен сообщениями в распределённом окружении. Прежде всего предназначено для реализации отложенного обмена сообщениями, на основе которого и строится Messaging System.

В отличие от традиционных систем, &nbsp;в Messaging System приложения общаются не напрямую, а посредством MOM. Если один компонент системы хочет послать сообщение другому компоненту, он посылает данное сообщение MOM, а MOM затем пересылает его адресату.

### Способы доставки сообщений до клиента

Существует 2 модели:
- Модель Точка-Точка (Point-to-Point, P2P) - в этой модели место назначения, используемое для хранения сообщений, называется очередью. Объект Queue. В этой модели один клиент помещает сообщение в очередь, а другой получает сообщение. Как только получение сообщения подтверждено, поставщик сообщений удаляет его из очереди.
- Модель Подписчик-Издатель (Publisher-Subscriber) - место назначения называется темой. Объект Topic. При использовании данной модели клиент публикует сообщение в теме и все абоненты этой темы получают сообщение.

https://jsehelper.blogspot.com/2016/12/jms.html
_____

Java Message Service — стандарт для асинхронного распределенного взаимодействия программных компонентов (которые могут находиться на одном компьютере, в одной локальной сети, или быть связаны через Интернет) путем рассылки сообщений.

JMS поддерживает две модели коммуникации: point-to-point и publish-subscribe (pubsub).

В point-to-point сообщения от разных отправителей адресуются определенной очереди, к которой подключаются клиенты. При этом для каждого сообщения гарантируется, что оно будет доставлено одному и только одному клиенту.

В pubsub сообщения адресуются определенному topic'у, на которые подписываются клиенты. Каждое сообщение может быть получено несколькими клиентами или не получено вообще, если подписчиков на момент доставки не было.

Существует несколько реализаций JMS провайдеров (RabbitMQ, Open Message Queue, ...) - эти решения шире

### Message-Driven Beans
 
MDB — это компоненты, логика которых является
реакцией на события, происходящие в системе.
Особенности MDB:
- Реализуют интерфейс слушателя соответствующего
типа сообщений (например, JMS).
- Нет возможности вызова методов «напрямую».
- Нет локальных и удалённых интерфейсов.
- Контейнер может создавать пулы MDB.
- При развёртывании MDB нужно регистрировать в
качестве получателей сообщений.

### Пример MDB

```java
import javax.ejb.*;
import javax.jms.*;
@MessageDriven(mappedName = "jms/MyQueue",
    activationConfig = {
        @ActivationConfigProperty(propertyName =
            "acknowledgeMode", propertyValue =
            "Auto-acknowledge"),
        @ActivationConfigProperty(propertyName =
            "destinationType", propertyValue =
            "javax.jms.Queue")
 })
public class SampleMDB implements MessageListener {
 public void onMessage(Message message) {
 // Do something
 }
}
```
## 44. Понятие транзакции. Управление транзакциями в Java EE. JTA.

Транзакция — группа последовательных операций, представляет собой логическую единицу работы с данными. Транзакция либо выполняется успешно и целиком, соблюдая целостность данных, либо не производит никакого эффекта на данные.

Java Transaction API позволяет выполнять распределенные транзакции, т.е. транзакции, читающие и обновляющие данные на разных сетевых ресурсах (которыми могут быть различные серверы баз данных, JMS).

JTA предоставляет высокоуровневый интерфейс для управления транзакциями (begin, commit, rollback), избавляя от необходимости работы с каждым ресурсом по-своему (интерфейс транзакций в JDBC, например, немного отличается от интерфейса JMS).

Транзакция координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.

Транзакции могут быть объявлены:
- декларативно — аннотацией @Transactional на отдельном методе или всем классе, при этом rollback происходит при необработанном RuntimeException
- программно — вызывая begin, rollback, commit у UserTransaction

В дополнение (там немного, но важно): http://tomee.apache.org/jpa-concepts.htm

## 45. Веб-сервисы. Технологии JAX-RS и JAX-WS.

- Позволяют организовать взаимодействие между
сетевыми ресурсами по стандартизированному
протоколу.
- Ресурсы могут работать на любой платформе.
- Данные «упаковываются» в XML и передаются по
HTTP.
- Основные стандарты — SOAP, WSDL и WS-I.
- На платформе Java EE реализуются JAX-WS API и
JAX-RS API.
- Основа SOA (Service Oriented Architecture).

JAX-WS:

```java
package example;
import javax.jws.*;
@WebService
public class SayHello {
 @WebMethod
 public String getGreeting(String name){
 return "Hello " + name;
 }
}
```

Пример JAX-RS (REST веб-сервис)

```java
import javax.enterprise.ApplicationScoped;
import javax.ws.rs.*;

@ApplicationScoped
@Path("/")
public class Rest {
  @GET
  @Path("echo")
  public String echo(@QueryParam("q") String original) {
    return original;
  }
}
```
Difference between JAX-WS и JAX-RS:

JAX-WS - это Java API для веб-служб на основе XML - стандартный способ разработки веб-служб в нотации SOAP (Simple Object Access Protocol).

Вызов веб-служб осуществляется посредством удаленных вызовов процедур. Для обмена информацией между клиентом и веб-сервисом используется протокол SOAP. Обмен сообщениями между клиентом и сервером осуществляется через сообщения SOAP на основе XML .

Клиентам веб-службы JAX-WS необходим файл WSDL для создания исполняемого кода, который клиенты могут использовать для вызова веб-службы.

JAX-RS - Java API для веб-служб RESTful. Веб-службы RESTful представлены как ресурсы и могут быть идентифицированы с помощью унифицированных идентификаторов ресурсов ( URI ). Вызов удаленной процедуры в данном случае представляет собой HTTP- запрос, а необходимые данные передаются в качестве параметров запроса. Веб-службы RESTful - более гибкие, могут использовать несколько разных MIME- типов. Обычно используется для обмена данными XML или обмена данными JSON (JavaScript Object Notation) ...

## 46. Платформа Spring. Сходства и отличия с Java EE.

### Платформа Spring

Что такое Spring?

Несмотря на то, что Spring не обеспечивал какую-либо конкретную модель программирования, он стал широко распространённым в Java-сообществе главным образом как альтернатива и замена модели Enterprise JavaBeans. Spring предоставляет бо́льшую свободу Java-разработчикам в проектировании; кроме того, он предоставляет хорошо документированные и лёгкие в использовании средства решения проблем, возникающих при создании приложений корпоративного масштаба.

Между тем, особенности ядра Spring применимы в любом Java-приложении, и существует множество расширений и усовершенствований для построения веб-приложений на Java Enterprise платформе. По этим причинам Spring приобрёл большую популярность и признаётся разработчиками как стратегически важный фреймворк.

Пожалуй, наиболее трудной частью объяснения технологии Spring является точная классификация того, что она собой представляет. Обычно Spring описывают как облегченную платформу для построения Jаvа-приложений, но с этим утверждением связаны два интересных момента.

Во-первых, Spring можно применять для построения любого приложения на языке Java (например, автономных, веб-приложений или приложений Java Enterprise Edition (JEE)) в отличие от многих других платформ (таких как Apache Struts, которая ограничена созданием только веб-приложений).

Во-вторых, характеристика облегченная в действительности не имеет никакого отношения к количеству классов или размеру дистрибутива, а вместо этого определяет принцип всей философии Spring — минимальное воздействие. Платформа Spring является облегченной в том смысле, что для использования всех преимуществ ядра Spring вы должны вносить минимальные (если вообще какие-либо) изменения в код своего приложения, а если в какой-то момент вы решите прекратить пользоваться Spring, то и это сделать очень просто.

Обратите внимание, что речь идет только о ядре Spring - многие дополнительные компоненты Spring, такие как доступ к данным, требуют более тесной привязки к Spring Framework. Однако польза от такой привязки вполне очевидна.

Spring, вероятно, наиболее известен как источник расширений (features), нужных для эффективной разработки сложных бизнес-приложений вне тяжеловесных программных моделей, которые исторически были доминирующими в промышленности. Ещё одно его достоинство в том, что он ввел ранее неиспользуемые функциональные возможности в сегодняшние господствующие методы разработки, даже вне платформы Java.

Этот фреймворк предлагает последовательную модель и делает её применимой к большинству типов приложений, которые уже созданы на основе платформы Java. Считается, что Spring реализует модель разработки, основанную на лучших стандартах индустрии, и делает её доступной во многих областях Java.

#### Преимущества: 

Spring Framework обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности.

- Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения.
- Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д..
- Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI  lookup (поиска).
- Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.

#### Все про Spring:

- https://jsehelper.blogspot.com/2016/02/spring-framework-1.html
- https://jsehelper.blogspot.com/2016/03/spring-framework-2.html
- https://jsehelper.blogspot.com/2016/03/spring-framework-3.html

#### Важные заметки для себя:
- Аспектно-ориентированное программирование (АОП) — это парадигма программирования являющейся дальнейшим развитием процедурного и объектно-ориентированного программирования (ООП). Идея АОП заключается в выделении так называемой сквозной функциональности.
Т.е. есть функциональность которая затрагивает несколько модулей, но она не имеет прямого отношения к бизнес коду, и ее хорошо бы вынести в отдельное место, это и показано на рисунке выше.
- Prototype scope creates a new instance every time getBean method is invoked on the ApplicationContext. Where as for request scope, only one instance is created for an HttpRequest

### Отличие Spring от JavaEE
Проще говоря, Java EE — для легко масштабируемого монолитного приложения, Spring — для совсем маленьких приложений с GUI на Front-end или для микросервисной архитектуры.

https://dou.ua/lenta/articles/javaee-vs-spring/

Конкурентном Java EE считается Spring Framework. Если взглянуть на развитие двух данных платформ, выходит интересная картина. Первые версии Java EE были созданы при участии IBM. Они вышли крутыми, но неповоротливыми, тяжеловесными, неудобными в использовании. Разработчики плевались из-за необходимости поддерживать большое количество конфигурационных файлов и из-за прочих причин, усложняющих разработку.

В то же время на свет появился Spring IoC. Это была маленькая, красивая и приятная в обращении библиотека. В ней также использовался конфигурационный файл, но в отличии от Java EE, он был один. Простота Spring привела к тому, что практически все стали использовать данный фреймворк в своих проектах. 

А далее Spring и Java EE начали свой путь к одному и тому же, но с разных концов. Компания Pivotal Software, разработчик Spring, стали выпускать проект за проектом, чтобы покрыть все возможные и невозможные потребности Java-разработчиков. Постепенно то, что раньше называлось Spring, сначала стало одним из проектов, а потом и вовсе слилось с несколькими другими проектами в Spring Core. Все это привело к неминуемому усложнению Spring по сравнению с тем, каким он был изначально. Со временем следить за всем клубком зависимостей спринга стало уж совсем сложно, и возникла потребность в отдельной библиотеке, которая стала бы загружать и запускать все сама (сейчас где-то икнул так горячо любимый Spring Boot).

Все это время JCP работал над одним — добиться максимального упрощения всего, что только можно внутри Java EE. В итоге в современном EJB для описания бина достаточно указать одну аннотацию над классом, что предоставляет разработчику доступ ко всей мощи технологии Enterprise Java Beans. И подобные упрощения затронули каждую спецификацию внутри Java EE. 

В итоге по функционалу Spring и Java EE примерно разделяют паритет. Где-то что-то лучше, где-то что-то хуже, но если смотреть глобально, больших различий нет. То же самое касается сложности работы. И Spring, и Java EE являются превосходными инструментами. Пожалуй, лучшими из того, что сейчас есть, для построения корпоративных сетевых приложений на языке Java. 

!! Однако, Java EE может работать в общем случае только в рамках Enterprise Application Server’a (Tomcat таковым не является), а приложение на Spring стеке может работать на чем угодно (на том же Tomcat), и даже вообще без сервера (так как запустит его внутри себя самостоятельно).

!! Это делает Spring идеальным инструментом для разработки небольших приложений с GUI на Front-end или для микросервисной архитектуры. Но отказ от зависимости от серверов приложений отрицательно сказался на масштабируемости Spring-приложений.

А Java EE хорошо подходит для реализации масштабируемого монолитного кластерного приложения.

#### Детальное сравнение

1. Spring DI (Dependency Injection) vs CDI (Context Dependency Injection)

   Даже из названия понятно, что ядра в обоих стеках совершенно идентичны по характеристикам. Так и есть. Фактически в Java EE стеке изначально и использовался спринговый DI. Но после того как его включили прямо в Core, использовать его отдельно стало невозможно. Пришлось делать свой DI с аннотациями и программистками.
   
2. Spring Beans vs EJB (Enterprise Java Beans)

   Тут, скажем, ситуация прямо противоположная. Spring beans — это просто обычные джава бины, которые можно куда-то заинжектить и ничего больше. EJB — достаточно мощная штуковина, в которую встроена поддержка распределенного (мультинодного) исполнения, включая распределенный сборщик мусора, аутентификацию, поддержку транзакций и черти что еще. Другой разговор, если все это вам не надо... Ну вы поняли :)
   
3. Spring Service Locator vs JNDI

   Тут тоже ситуация аналогичная. Служба, помогающая найти в том же JVM сервис, и служба, которая может работать на распределенной системе и находить соответствие между чем угодно. Включая привязку к LDAP компании... Формально, предназначены они для одного и того же, однако согласитесь — разница на лицо.
   
4. @Async vs JMS

   Асинхронность также реализована в обоих стеках на разном уровне. В стеке Java EE это отдельная, да, вы правильно догадались, распределенная служба, поддерживающая передачу сообщений не только точка-точка, но и многим получателям. Естественно, отказоустойчивая, персистентная и так далее. В общем, ситуация аналогичная с предыдущими пунктами. Простое и быстрое против распределенной навороченной фиговины.
   
   ![alt text](resources/JMS.png "JMS API")
   
5. Spring MVC vs Java Server Faces (JSF)
    
    Проблема этого сравнения в том, что SpringMVC в качестве темплейтного движка обычно используется Thymeleaf или в более современном варианте — какой-либо Front-end движок (React, Angular & etc). В то время, как JSF — полноценное GUI решение с поддержкой AJAX из коробки и даже SPA приложений с помощью дополнительных библиотек, включая такие гиперудобные и красивые, как PrimeFaces и IceFaces.

    Примерчик из жизни:  
    И тут оказалось, что нативной поддержки AJAX в Spring MVC + Thymeleaf просто нет. Надо каждую операцию писать руками. А у нас практически каждый элемент требует AJAX поведения, причем в разных ситуациях — разного. И писать эту тонну JavaScript мои джаверы вообще не горят желанием. Ну что же. Скрепя сердце были вынуждены выкинуть весь написанный интерфейс и переделать все приложение на Angular (для чего взять еще и Front-end разработчика). И заняло это переписывание где-то больше месяца. Вот и считайте, в какие деньги вышло заказчику наше решение использовать стек Spring.
    
6. Spring Data vs JPA  

   Это единственный пункт, в котором Spring кроет как бык овцу стек Java EE. Spring Data — прекрасна, великолепна, быстра и удобна. Снимаю шляпу. Очень жаль, что аналога в Java EE стеке нет...
   
7. Spring Security vs JAAS

   Что хотел я сказать... Spring Security — фреймворк, который мне создал на моих проектах проблем больше, чем все остальные вместе взятые. Возможно, документация фиговая (это единственный Spring фреймворк с фиговой документацией). Возможно, сама тема сложная, но мои программисты традиционно мучаются с ней очень много. Полномасштабного использования JAAS у нас пока не было, но то, что простейшее — прилепляется легко.
   
   Отличия фреймворков вы понимаете и сами. JAAS, естественно, поддерживает распределенность.
   
8. Spring Boot vs Enterprise Server

   Все фанаты спрингового стека любят превозносить Spring Boot со словами «он прекрасен, с ним так все легко», забывая, что этот фреймворк — настоящие костыли, без которых связать воедино весь тот ад, который нафигачили ребята из проекта Spring просто очень сложно.
   
   Напоминаю, что аналогом Spring Boot для стека Java EE является просто любой Enterprise server. Там уже есть все нужные фреймворки нужных и консистентных версий, уже настроенные для работы друг с другом.
   

#### Java EE:

1. Java EE промышленности утверждены типовые основы API
2. Он преимущественно основан на аннотациях и CDI
3. JFC MVC framework для веб-разработки
4. JPA спецификация для обработки операции DB
5. JTA API с внедрением
6. EJB контейнерная и POJO основанная реализация
7. Oracle лицензия

#### Spring:

1. На основе IOC и AOP
2. На основе конфигурации XML (теперь они используют аннотацию)
3. Использует фреймворк Spring DAO (основанный на шаблоне дизайна шаблона) для подключения к базе данных
4. Предоставляет уровень абстракции для поддержки различных реализаций JTA.
5. Интегрируется с различными поставщиками Java для поддержки различных возможностей, таких как struts и т. д
6. Обеспечивает платформу end-to-end для построения веб-приложения, достигая свободной связи с использованием DI и AOP
7. Лицензия с открытым исходным кодом

## 47. Модули Spring. Архитектура Spring Runtime. Spring Security и Spring Data.

Spring потенциально может быть универсальным магазином для всех ваших корпоративных приложений. Однако Spring является модульным, позволяя вам выбирать, какие модули вам подходят, без необходимости вносить остальные. В следующем разделе приведены сведения обо всех модулях, доступных в Spring Framework.

#### Основной контейнер

Базовый контейнер состоит из модулей Core, Beans, Context и Expression Language, подробности которых следующие:

- Модуль Core обеспечивает основные части платформы, включая функции IoC и Dependency Injection.
- Модуль Bean предоставляет BeanFactory, которая представляет собой сложную реализацию фабричного шаблона.
- Модуль Context основан на прочной основе, предоставляемой модулями Core и Beans, и является средой для доступа к любым объектам, определенным и настроенным. Интерфейс ApplicationContext является координационным центром модуля Context.
- Модуль SpEL предоставляет мощный язык выражений для запросов и манипулирования графом объектов во время выполнения.

Уровень доступа к данным / интеграции состоит из модулей JDBC, ORM, OXM, JMS и Transaction, подробности которых следующие:

- Модуль JDBC предоставляет уровень абстракции JDBC, который устраняет необходимость в утомительном кодировании, связанном с JDBC.
- Модуль ORM предоставляет слои интеграции для популярных API объектно-реляционного отображения, включая JPA, JDO, Hibernate и iBatis.
- Модуль OXM предоставляет уровень абстракции, который поддерживает реализации отображения объектов / XML для JAXB, Castor, XMLBeans, JiBX и XStream.
- Модуль JMS Java Messaging Service содержит функции для создания и потребления сообщений.
- Модуль Transaction поддерживает программное и декларативное управление транзакциями для классов, которые реализуют специальные интерфейсы, и для всех ваших POJO.

Веб-слой состоит из модулей Web, Web-MVC, Web-Socket и Web-Portlet, подробности которых приведены ниже:

- Веб- модуль обеспечивает базовые функции веб-интеграции, такие как функция многоэтапной загрузки файлов и инициализация контейнера IoC с использованием прослушивателей сервлетов и контекста веб-ориентированного приложения.
- Модуль Web-MVC содержит реализацию Spring-Model-View-Controller (MVC) для веб-приложений.
- Модуль Web-Socket обеспечивает поддержку двусторонней связи на основе WebSocket между клиентом и сервером в веб-приложениях.
- Модуль Web- портлета предоставляет реализацию MVC для использования в среде портлета и отражает функциональность модуля Web-Servlet.

## 48. Реализация IoC и CDI в Spring. Сходства и отличия с Java EE.

### Описание работы IoC контейнера

Ниже представлена диаграмма, отражающая, как работает Spring. Ваши классы приложения совмещаются с метаданными конфигурации, в результате чего будет создан и инициализирован ApplicationContext, а на выходе вы получите полностью настроенное и готовое к выполнению приложение.

![alt text](resources/IoC_Spring.png "IoC in Spring")

ApplicationContext представляет собой Spring IoC контейнер и необходим для инициализации, настройки и сборки бинов для построения приложения.

В метаданных конфигурации разработчик описывает как инициализировать, настроить IoC контейнер и собрать объекты в вашем приложении. В данном и других уроках этого цикла везде, где возможно, будет использоваться подход на основе аннотаций и Java-конфигурации. Если вы сторонник XML-конфигурации, либо хотите посмотреть как делать тоже самое через XML, обратитесь к оригинальной документации по Spring Framework или соответствующего модуля/проекта.

Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией @Configuration и методы с аннотацией @Bean. Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках). Класс с аннотацией @Configuration говорит о том, что он является источником определения бинов. Самая простейшая из возможных конфигураций выглядит следующим образом:

```java
package lessons;

import org.springframework.context.annotation.Configuration;

/**
 * Конфигурационный класс Spring IoC контейнера
 */
@Configuration
public class LessonsConfiguration {
}
```
Для того, чтобы приступить к настройке и изучению Spring IoC контейнера, вы должны инициализировать ApplicationContext, который поможет также с разрешением зависимостей. Для обычной Java-конфигурации применяется AnnotationConfigApplicationContext, в качестве аргумента к которому передается класс, либо список классов с аннотацией @Configuration, либо с любой другой аннотацией JSR-330, в том числе и @Component

```java
public class Starter {

    private static final Logger logger = LogManager.getLogger(Starter.class);

    public static void main(String[] args) {
        logger.info("Starting configuration...");

        ApplicationContext context = new AnnotationConfigApplicationContext(LessonsConfiguration.class);
    }
}
```
```java
package lessons.services;

public interface GreetingService {
    String sayGreeting();
}
```
```java
package lessons.services;

public class GreetingServiceImpl implements GreetingService {

    @Override
    public String sayGreeting() {
        return "Greeting, user!";
    }
}
```

```java
@Configuration
public class LessonsConfiguration {
    @Bean
    GreetingService greetingService() {
        return new GreetingServiceImpl();
    }
}
```

```java
public class Starter {

    private static final Logger logger = LogManager.getLogger(Starter.class);

    public static void main(String[] args) {
        logger.info("Starting configuration...");

        ApplicationContext context = new AnnotationConfigApplicationContext(LessonsConfiguration.class);
        GreetingService greetingService = context.getBean(GreetingService.class);
        logger.info(greetingService.sayGreeting());  // "Greeting, user!"
    }
}
```

Полезная ссылка: https://spring-projects.ru/guides/lessons/lesson-2/

### Сходства и отличия с Java EE


CDI (контексты и внедрение зависимостей) — это спецификация внедрения зависимостей (DI), связанная с Java EE 6 и выше. Он реализует основанную на аннотациях структуру DI, облегчая полную автоматизацию управления зависимостями и позволяя разработчикам сосредоточиться на кодировании, а не на работе с DI во всех его различных направлениях.
  
Есть IoC - инверсия контроля, IoC это просто концепция (подход), а вот DI (в Spring) и CDI (в Java EE) - это реализации этого подхода.
  
Напоминание: Фактически в Java EE стеке изначально и использовался спринговый DI. Но после того как его включили прямо в Core, использовать его отдельно стало невозможно. Пришлось делать свой DI с аннотациями и программистками.

Но почему в Spring DI, а в Java EE CDI? Я могу предположить, что сязано это с тем, что для Java EE обязательно нужен Enterprise Application Server’a (Tomcat таким не является), поэтому Context всегда уже реализован в нем и содержится в этом сервере.

А что касается Spring, там используется DI, так как Context всегда реализуется самим програмистом (ApplicationContext)



## 49. Реализация REST API в Java EE и Spring.
  
Spring Framework предоставляет богатый набор инструментов, упрощающий разработку REST API: инструменты для маршрутизации запросов, классы-кодеки для преобразования JSON/XML в объекты требуемых типов и т.д.

HTTP-методы
В отличии от классических веб-приложений, в которых используются только методы GET и POST, в REST API используются практически все HTTP-методы, например:

GET — для получения объекта или списка объектов
HEAD — проверка существования объекта
OPTIONS — проверка доступных методов для указанного пути
POST — для создания нового объекта
PUT — для полного изменения объекта или помещения объекта в список
PATCH — для частичного изменения объекта
DELETE — для удаления объекта
Стоит помнить, что хорошей практикой является использование GET только для запросов, которые не изменяют состояние объекта. Если запрос должен изменить состояние объекта, то должен использоваться соответствующий HTTP-метод, хотя бы POST.

Для маршрутизации запросов в Spring Framework используется аннотация @RequestMapping с указанием HTTP-метода при помощи свойства method или более простые аннотации вроде
@GetMapping, @PostMapping, @DeleteMapping и т.д.
  
Очень важными при разработке REST API являются и HTTP-заголовки. Например, клиент может, указывать MIME-тип содержимого отправляемого запроса при помощи заголовка Content-type или ожидаемый MIME-тип ответа или даже его версию при помощи заголовка Accept.

Возможности Spring Framework WebMVC позволяют маршрутизировать запросы в зависимости не только от их пути или методов, но и в зависимости от заголовков
  
@RestController
@RequestMapping("api/todo")
public final class TodoRestController {

    @PostMapping(consumes = {"application/vnd.example.todo_payload+json;v=2"})
    public ResponseEntity<Todo> createTodoV2(@RequestBody TodoPayload payload) {
        //
    }

    @PostMapping(consumes = {"application/vnd.example.todo_payload+json"})
    public ResponseEntity<Todo> createTodo(@RequestBody TodoPayload payload) {
        //
    }
}
Используется Spring Boot, из которого нам понадобятся стартеры:

Web — для поддержки веб
JDBC — для работы с базой данных
H2 — в качестве тестовой базы данных
  
Теперь, когда у нас есть вся необходимая структура, мы можем приступить непосредственно к разработке REST API. Для этого создадим заготовку класса TodoRestController:

@RestController
@RequestMapping("api/todo")
public final class TodoRestController {

    private final JdbcOperations jdbcOperations;
}

  Контекст приложения создаст и зарегистрирует экземпляр класса, поскольку указана аннотация @RestController. Кроме этого аннотация подсказывает, что возвращаемые методами значения являются телом ответов на запросы. Эта аннотация заменяет собой пару @Controller + @ResponseBody.
  Аннотация @RequestMapping указывает на маршрутизацию запросов: все запросы, начинающиеся с api/todo будут обрабатываться этим контроллером.
  Объект типа JdbcOperations будет внедрён через конструктор.
  
  Метод получения одной задачи по её идентификатору должен быть вызван при GET-запросе по пути /api/todo/{todoId}; он должен обратиться к базе данных и вернуть задачу с HTTP-кодом 200 OK или 404 Not Found, если задачи нет в БД.
  
  @GetMapping("{todoId}")
public ResponseEntity<Todo> getTodo(@PathVariable UUID todoId) {
    try {
        return ResponseEntity.ok(this.jdbcOperations
                .queryForObject("select * from todo where id = ? limit 1",
                (resultSet, i) ->
                        new Todo(UUID.fromString(resultSet.getString("id")),
                                resultSet.getTimestamp("date_created").toLocalDateTime(),
                                resultSet.getBoolean("done"),
                                resultSet.getString("task")), todoId.toString()));
    } catch (IncorrectResultSizeDataAccessException e) {
        return ResponseEntity.notFound().build();
    }
}
  
  @GetMapping указывает, что метод getTodoList должен обрабатывать GET-запросы с путём /api/todo. Альтернативно может быть использована аннотация @RequestMapping(method = RequestMethod.GET).
  При помощи объекта типа ResponseEntity, возвращаемого методом, можно тонко настроить ответ, включая коди заголовки ответа. Фактически можно просто вернуть список задач, не оборачивая его в ResponseEntity.
  @GetMapping(«{todoId}») указывает, что метод getTodo должен обрабатывать GET-запросы с путём /api/todo/{todoId}. Фигурные скобки в данном случае указывают, что todoId — переменная пути (Path variable) и может быть использована в аргуметах метода. Можно задать более строгие правила валидации пути, добавив после todoId через двоеточие регулярное выражение, которое будет использоваться для валидации пути.
  @PathVariable указывает, что значение аргумента todoId должно браться из пути запроса. По умолчанию все значения являются строковыми, но при помощи классов-конвертеров строка преобразуется в объект класса java.util.UUID. Обратите внимание, что имя аргумента соответствует плейсхолдеру, указанному в @GetMapping, в противном случае нам пришлось бы указать плейсхолдер в свойстве name аннотации @PathVariable.
Исключение IncorrectResultSizeDataAccessException выбрасывается в случае, если база данных вернула в ответ на запрос количество строк неравное 1. Если актуальное количество строк рано 0, то соответствующая запись в БД отсутствует, и мы можем вернуть ответ с HTTP-кодом 404 Not Found; если строк больше 1, то мы имеем дело с какой-то ошибкой и можем вернуть ответ с HTTP-кодом 500 Internal Server Error.
  
Метод создания задачи должен быть вызван при POST-запросе по адресу /api/todo; он должен сохранить в БД полученные данные и вернуть сохранённую задачу в ответ.
  
@PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE,
        "application/vnd.example.todo_payload+json"})
public ResponseEntity<Todo> createTodo(@RequestBody TodoPayload payload) {
    var todo = new Todo(payload.isDone(), payload.getTask());
    jdbcOperations.update("insert into todo (id, date_created, done, task) values (?, ?, ?, ?)",
            todo.getId().toString(), Timestamp.valueOf(todo.getDateCreated()),
            todo.isDone(), todo.getTask());

    return ResponseEntity.ok(todo);
}

Аннотация @PostMapping указывает, что данный метод обрабатывает все POST-запросы с путём /api/todo. Свойство consumes задаёт список MIME-типов, которые может обрабатывать данный метод.
Аннотация @RequestBody указывает, что отмеченный аргумент является телом запроса. Тело запроса преобразуется в объект нужного класса при помощи конвертеров.
Тело запроса автоматически преобразуется в объект типа TodoPayload при помощи класса-кодека.
  
Метод изменения задачи должен быть вызван при PUT-запросе по адресу /api/todo/{todoId}; он должен сохранить изменения в БД и вернуть ответ со статусом 204 No Content, либо вернуть ответ со статусом 404 Not Found, если задача не найдена.
  
@PutMapping(
        path = "{todoId}",
        consumes = {
            MediaType.APPLICATION_JSON_VALUE, 
            "application/vnd.example.todo_payload+json"
            }
)
public ResponseEntity<Void> modifyTodo(@PathVariable UUID todoId, 
                                       @RequestBody TodoPayload payload) {
    if (this.jdbcOperations.update("update todo set done = ?, task = ? where id = ?", 
            payload.isDone(), payload.getTask()) == 1) {
        return ResponseEntity.noContent().build();
    }

    return ResponseEntity.notFound().build();
}
  
Этот метод может возвращать ответ, содержащий какую-то информацию, например, изменённую задачу, но клиент и так знает о внесённых изменениях.
  
REST API на Java без фреймворков
  
Сначала создайте новый Maven-проект со следующим pom.xml.
  
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
   <modelVersion>4.0.0</modelVersion>

   <groupId>com.consulner.httpserver</groupId>
   <artifactId>pure-java-rest-api</artifactId>
   <version>1.0-SNAPSHOT</version>

   <properties>
       <java.version>11</java.version>
       <maven.compiler.source>${java.version}</maven.compiler.source>
       <maven.compiler.target>${java.version}</maven.compiler.target>
   </properties>

   <dependencies></dependencies>
</project>

Добавьте в зависимости java.xml.bind и Jackson для JSON-сериализации

Первый эндпоинт

В основе нашего веб-приложения будет класс com.sun.net.httpserver.HttpServer. И простейший эндпоинт (endpoint) /api/hello может выглядеть следующим образом:
  
package com.consulner.api;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;

import com.sun.net.httpserver.HttpServer;

class Application {

   public static void main(String[] args) throws IOException {
       int serverPort = 8000;
       HttpServer server = HttpServer.create(new InetSocketAddress(serverPort), 0);
       server.createContext("/api/hello", (exchange -> {
           String respText = "Hello!";
           exchange.sendResponseHeaders(200, respText.getBytes().length);
           OutputStream output = exchange.getResponseBody();
           output.write(respText.getBytes());
           output.flush();
           exchange.close();
       }));
       server.setExecutor(null); // creates a default executor
       server.start();
   }
}

Веб-сервер запускается на порту 8000 и предоставляет эндпоинт, который просто возвращает Hello!.. Это можно проверить, например, используя curl:

curl localhost:8000/api/hello
 
Парсинг параметров запроса

Парсинг параметров запроса — это еще одна «функция», которую нам нужно реализовать самостоятельно.

Допустим, мы хотим, чтобы наш hello api получал имя в параметре name, например:

curl localhost:8000/api/hello?name=Marcin

Hello Marcin!

Мы могли бы распарсить параметры следующим образом:

public static Map<String, List<String>> splitQuery(String query) {
   if (query == null || "".equals(query)) {
       return Collections.emptyMap();
   }

   return Pattern.compile("&").splitAsStream(query)
           .map(s -> Arrays.copyOf(s.split("="), 2))
           .collect(groupingBy(s -> decode(s[0]), mapping(s -> decode(s[1]), toList())));
}

и использовать, как показано ниже:

Map<String, List<String>> params = splitQuery(exchange.getRequestURI().getRawQuery());
String noNameText = "Anonymous";
String name = params.getOrDefault("name", List.of(noNameText)).stream().findFirst().orElse(noNameText);
String respText = String.format("Hello %s!", name);
  
Часто нам нужно защитить доступ к некоторым эндпоинтам. Например, это можно сделать, используя базовую аутентификацию (basic authentication).
Значение “myrealm” в конструкторе BasicAuthenticator — это имя realm. Realm — это виртуальное имя, которое может быть использовано для разделения областей аутентификации. 
  
Текст после «Basic» — это кодированный в Base64 текст admin:admin, который представляет собой учетные данные, жестко закодированные в нашем примере.
Для аутентификации в реальном приложении вы, вероятно, получите учетные данные из заголовка и сравните их с именем пользователя и паролем, хранящимися в базе данных.
Если вы не укажете заголовок, то API ответит статусом

JSON, обработка исключений и прочеe
  Теперь пришло время для более сложного примера.
Из моего опыта в разработке программного обеспечения наиболее распространенным API, который я разрабатывал, был обмен JSON.
Мы собираемся разработать API для регистрации новых пользователей. Для их хранения будем использовать базу данных в памяти.

  
## 50. React JS. Архитектура и основные принципы разработки приложений.

### React JS
Начнем с того, что React - это JS библиотека(!!!). Обратите внимание, что именно
библиотека, а не фреймворк (отличаются инверсией управления), которая
предназначена для создания пользовательских интерфейсов. 

У него открытый исходный код. Если говорить о популярности, то у
реакта 160 тысяч звездочек. К примеру, у Ангуляра 68 тысяч.

На слайде есть картиночка вольного сравнения популярности Vue, Angular и
React с помощью гугл трендов. Реакт достаточно популярен сейчас, но это не в
коем случае не значит, что нужно использовать только реакт. Например, Angular
имеет более mvc - шную архитектуру, а у Vue гораздо субъективно меньше порог
вхождения.

Также React предназначен в основном для создания одностраничных
приложений или Single Page Application.

### SPA

#### SPA — подход, в котором:

- Используется один html-документ
- Динамическое обновление благодаря JavaScript
- Быстрый отклик
- Простота разработки
- Возможность работы в offline режиме

Что это вообще такое? Это такой подход к созданию веб-приложения, при
котором используется только один html-документ. Все нужные ресурсы
загружаются при первом запросе. Далее все взаимодействие осуществляется с
помощью javascript подгрузки необходимых частей данных.  
Ощутимое преимущество данного подхода - это достаточно высокая скорость
работы веб-приложения, что очень напоминает десктопное приложение так как
нет перезагрузок и подгрузки новых страниц. Благодаря этому можно создать
пользовательский интерфейс достаточно сложным, затратив минимальное
количество усилий.  
Также важной особенностью является возможность продолжения работы в offline
режиме благодаря кэшированию данных. Яркий пример, почему это хорошо -
допустим, листаете вы ленту в инстаграмме в метро и тут у вас пропадает
интернет, было бы круто, если при этом часть данных подгрузилась и вы смогли
бы еще какое-то время листать эту ленту

#### Минусы

- Долгая первая загрузка
- Нет поддержки javascript == нет приложения
- SEO
- Большая часть взаимодействия на клиенте

Но при этом у данного подхода есть определенные недостатки.
Самый очевидный из них - если в браузере отключена поддержка javascript, то
тут ничего не сделать кроме как просить пользователя включить его.  
Ну и конечно, первая загрузка у вас будет несколько дольше. Может вы
замечали когда-нибудь, что сайт сначала грузится очень долго, а потом
переходы на его другие страницы происходят достаточно быстро. Есть
вероятность, что скорее всего вы столкнулись с SPA приложением, которое
вначале просто загрузил все ему нужные скрипты, а дальше только
подхватывал нужные ему данные и встраивал в страницу.  
Также у SPA есть определенные проблемы с SEO в ввиду наличия только одной
html страницы.  
Так как большая часть взаимодействия с пользователем
переложена на SPA, то это влечет за собой некоторые проблемы с
безопасностью.

### Основные принципы разработки веб-приложения

![alt text](resources/reactComponents.png)

Начнем с того, что реакт основан на компонентах. Все ваше приложение
разделено на компоненты. Компонент - это некоторый инкапсулированный
элемент. На слайде есть пример интерфейса, разбитого на компоненты. Каждый
компонент предназначен для определенной цели. Например, отобразить имя,
аватарку и статус работника.  
И главное удобство заключается в том, что
компоненты можно переиспользовать - для того, чтобы показать список
работников, нам нужно взять шесть EmployeeListItem, а точнее использовать
один компонент и тот же компонент шесть раз, которому нужно сказать, какие
имя, статус и аватарку ему показывать. Это удобно, когда у вас в интерфейсе
много одинаковых элементов, которые вы не пишите каждый раз с нуля.  
Также здесь можно заметить свое дерево компонентов. В компоненте App
находятся HomePage и EmployeePage, дальше в HomePage лежит Header,
SearchBar и тд.

Это первая важная особенность React

### Архитектура приложения

#### VDOM

![alt text](resources/VDOM.png)

Cледующая - это Virtual DOM. DOM -
объектная модель документа. У реакта достаточно интересное взаимодействие
с DOM.  
Каждое изменение DOM - достаточно дорогостоящая операция. Поэтому
в реакте есть такая концепция как Virtual DOM. По сути изначально это полная
копия DOM. Однако, если вы взаимодействуете с каким-нибудь элементом,
реакт изменяет не реальный DOM, а только виртуальный. Далее он сравнивает
виртуальный дом с реальным - этот процесс называется сверкой или патчем и
происходит с помощью библиотеки ReactDOM - и если они различаются, то
реакт изменяет только ту часть DOMа, где он различается с виртуальным. в
каком-то смысле виртуальный дом - некоторая прослойка между вашим
приложением и DOM.

#### Как строит дерево React

![alt text](resources/reactTree.png)

Есть два типа элементов - ReactComponentElement и ReactDOMElement.
- ReactComponentElement - ссылка на соответствующую функцию(класс) этого
компонента.
- ReactDOMElement - виртуальное представление DOM-элементов.


## 51. Компоненты React. State & props. "Умные" и "глупые" компоненты.

### Компоненты React 

Проще всего описывать компонент как функцию - пример функции. Однако
можно использовать и классы, но это достаточно устаревший подход. С точки
зрения React - оба подхода эквивалентны.

Чтобы отрендерить элемент используем функцию ReactDom.render(element,
document.getElementById(‘root’);
Clean Code:
Название компонента - всегда с большой буквы

```javascript
ReactDOM.render(
            <App/>,
    document.getElementById('root')
)
```

#### Жизненный цикл 

1. инициализация — создание экземпляра класса компонента
2. монтирование — компонент вставляется в DOM
3. обновление — компонент обновляется новыми данными через состояние или свойства
4. размонтирование — компонент удаляется из DOM

У всех компонентов в реакте есть жизненный цикл. Его важно понять и
осмыслить - это одно из основополагающих знаний хорошего реакт
разработчика. На начальном этапе, конечно, вам не нужно помнить абсолютно
все этапе, но основные - точно. Давайте их рассмотрим.

![alt text](resources/lifecycleComponent.png)

Updation:

shouldComponentUpdate - говорим, следует отрисовывать заново элемент или нет

props - componentWillReceiveProps - перед тем, как обновялются props, предыдущее состояние props'ов можно сохранить с помощью этой функции

Unmouting:

componentWillUnmount - что-то хотим сделать перед размонтированием (pop up открылся и нужно закрыть pop up и закрыть красиво и накинуть анимацию) 

### Props

```javascript
const EmployeeListItem = (props) =>
    <div>
        {props.name} - {props.status}
    </div>
);
```
```javascript
<EmployeeListItem name=”James King” status=”President and CEO”/>
```

Теперь нам нужно передать трем элементам разные фамилии и статус. Сделать мы это
можем через пропсы. Пропсы - это входные данные, которые мы передаем
функции - пример.  
Очень важное замечание - пропсы можно только читать. Другими словами, все
реакт компоненты должны вести себя как чистые функции. Это правило ни в
коем случае нельзя нарушать при написании React приложения.

### State

```javascript
const EmployeeListItem = (props) =>
    const [age, setAge] = useState(1) //Задается начальное состояние
        <div>
            {props.name} - {props.status}
            <br/>
            {age} //Будет выведено: 1
        </div>
);
```

Компонент может хранить в себе свое состояние и изменять его. В
функциональных компонентах для объявления переменной состояния
используется хук useState. Хук - это специальная функция, расширяющая
возможности функциональных компонентов. Хуки можно использовать только
внутри функциональных компонентов.  
Состояние компонента меняется только через предоставленную функцию, так
как реакт может сам заменить значение переменной, если вы изменяете ее
напрямую, а также он не будет в курсе сделанному вами изменению.   
Также в реакте данные передаются только в одном направлении - вы не
сможете обратиться к переменной родителя из ребенка. Единственный способ -
это сделать - передать в пропсы специальную функцию от родителя,
предоставляющую доступ к переменной.

### Events

```java
const EmployeeListItem = (props) =>
    const clickHandler = (e) => {console.log(e)}
    const [age, setAge] = useState(1) //Задается начальное состояние
        <div>
            <button onClick={clickHandler}>Click!</button>
            <br/>
            {age} //Будет выведено: 1
        </div>
     );
```

Работа с событиями - пример. e - синтетическое событие. Не нужно добавлять
addEventListener (привет jquery)

### Циклы

```javascript
const List = () =>
    <div>
        {[1,2,3].map((el,index)=><span key={index}>{el}</span>)}
    </div>
```

Работа с циклами в реакте аналогично обычному javascript - пример рендера
несколько элементов.

## 52. Разметка страниц в React-приложениях. JSX.

### React.createElement(...)

![alt text](resources/reactCreateElement.png)

У реакта одна из главных функций - React.createElement(component, props,
children). С помощью нее можно создать элемент. Давайте посмотрим на
практике, как она работает:

На основе данной структуры реакт рекурсивно обходит дерево компонентов и
строит VDOM.

Естественно, описывать каждый элемент подобным способом - особый вид
извращения, это выглядит явно сложно читаемым, поэтому был придуман
синтаксический сахар - JSX.

### JSX

![alt text](resources/JSX.png)

JSX - расширение Javascript, которое позволяет писать код, похожий на HTML.
Препроцессор JSX (К примеру, Babel), анализирует весь ваш код и преобразует
его в обычный javascript.


## 53. Навигация в React-приложениях. ReactRouter.

### React-router

React-router специально вынесен в отдельную библиотеку, потому что у нее есть опред свой функционал

Она позволяет реализовывать навигацию между компонентами  

![alt text](resources/react-router.png)

history - объект, сохраняющий историю и позволяющий вручную переходить на какие-нибудь компоненты


## 54. Управление состоянием интерфейса. Redux.

Redux - менеджер состояния. Чаще всего используется с React, но не
привязан к нему. 

![alt text](resources/redux.png)

Redux - хранилище для всего нашего приложения и мы можем из любого компонента получить состояние переменной, который находится в общем хранилище и подписаться на ее изменение, либо кинуть экшен на ее изменение

### Важная особенность Redux:

Данные напрямую в store обновить НЕЛЬЗЯ  
Чтобы оновить данные, мы отправляем action  
Который кидает запрос на обработку какого типа был action  
И только потом изменяется значение в store 

### Особенности

- Общее, одно состояние данных, доступное из любого компонента
- Состояние изменяется только с помощью action, но не напрямую
- В компоненте можно подписаться на изменения определенного
значения
- Компоненты могут иметь свое состояние(state), но только если оно
важно только для данного компонента


… кода становится в несколько раз больше :(

### Store

Похож на state компонента, только он глобальный

Объект, который содержит состояние приложения и является
уникальным.

Является неизменяемым - обновляется путем создания нового объекта. (удаляем прошлое значение)

const store = createStore( initialState, reducer)

- getState()
- dispatch(action) - генерация события
- subscribe(listener) - подписка на изменения
- replaceReducer(nextReducer)

### Reducer

Чистая функция, которая вычисляет новое состояние.

Мы отправляем ей действие, проверяется тип действия

```javascript
function counterReducer(state = initialState, action) {
    if (action.type === 'counter/increment') {
        return {
            ...state,
            value: state.value + 1
        }
    }    
   
    return state
}
```

Возвращаем дефолтное состояние стейта, так как он проходит еще одну итерацию

### Action

Некоторое событие, которое должно привести к изменению состоянию.

С точки зрения js - это любой объект, имеющий идентификатор события
(type)

Action передается в reducer


```javascript
const addToDo = (name) => ({
    type: ‘ADD_TO_DO’,
    payload: { name }
})

```
### Dispatch

Функция redux, которая генерирует события.

dispatch(addToDo);

### Redux схема

![alt text](resources/reduxScheme.png)

### Middleware

Усилители. Главная их суть - принять входные данные действия, обработать и отправить дальше. Часто используются для работы с api

Например, мы хотим, чтобы при клике на кнопку отправился запрос на сервер, после запроса на сервер в зависимости от ответа мы обновили состояние store.
Тут и используется middleware. Мы синхронно отправляем запрос, ожидаем ответа, в зависимости от ответа (состояния промиса) она вызывает опрделенный action 

![alt text](resources/middleware.png)

## 55. Angular: архитектура и основные принципы разработки приложений.

Angular - в отличие от react это фреймворк

В общем случае написан на TypeScript. За 4 года 9 релизов.

Angular - развитие библиотеки AngularJS. Т. е в 2016 году Angular=fork AngularJS. Дальше они развивались независимо

### Особенности Angular

Так как Angular -  это фреймворк, поэтому, чтобы начать разрабатывать приложение на нем, нужно сделать некую предварительную работу. Какую?

- Для разработки нужно настроить соборочное окружение (на базе node.js и npm). Ну и в этом окружении клиентскую часть нашего приложения собирать 
- Приложения состоят из модулей ( наследники класса NgModules) 
- Модули обеспечивают контекст для компонентов (components)
- Из компонентов строятся представления (views)
- Компоненты взаимодействуют с сервисами (элементы, реализующие логическую составляющую нашего фронта) (services) с помощью DI

### Архитектура приложения на базе Angular

![alt text](resources/architectureAngular.png )

- Шаблон и комонент циклически обмениваются (путем биндинга пропертей и событий)
- В компонент встраиваются сервисы путем использования Injector'a (он отвечает за DI в Angular)
- Template (шаблон) использует метаданные заданной директивы, связывая себя с пропертями.

## 56. Angular: модули, компоненты, сервисы и DI.

### Модули

- Не совсем то же самое, что модули в ES6 (хотя и похожи)
- Каждый модуль обеспечивает контекст компиляции для одного или группы компонентов
- Модули могут связывать компоненты с сервисами, необходимыми для работы этих компонентов
- Группировка компонентов по модулям - на усмотрение программиста 
- Каждое приложение обязательно включает в себя корневой модуль (root module) под названием AppModule (файл app.module.ts)
- Модули могут ссылаться друг на друга (возможны импорт и экспорт модулей)
- Могут быть использованы для реализации ленивой загрузки (загрузка по требованию) lazy loading

#### Структура модуля

- Каждый модуль - класс TS с декоратором @NgModule() (декоратор - подобие аннотации)
- Содержит секции
    - declarations - компоненты, директивы, фильтры, содержащиеся в этом модуле
    - exports - то, что объявлено в этой секции, будет видно и доступно для использования в других модулях
    - imports - список внешних модулей, содержимое секции exports которых используется в текущем модуле
    - providers - сервисы, реализованные в этом модуле, видимые в глобальном контексте приложения
    - bootstrap - главное предсталвение приложения (объявляется только в корневом модуле). С него начинается рендеринг интерфейса приложения
    
#### Пример модуля

![alt text](resources/moduleExampleAngular.png)


### Компоненты 

- У всех компонентов внутри одного модуля общий _контекст компиляции_. При компиляции они друг друга видят и компилятор видит все компоненты этого модуля
- Каждый компонент - отдельный класс
- Контролирует область экрана, называемую представлением (div-чик или блок)
- Ангуляр управляет жизненным циклом компонентов


 ![alt text](resources/componentAngular.png)

### Представления (views)

- Компоненты и их шаблоны (templates) формируют представления (views)
- Комонент может содержать иерархию представлений (view hierarchy)
- Каждый компонент содержит корневое представление, с которого начинается рендеринг интерфейса (host view)
 
### Метаданные компонента

- Задаются с помощью декоратора @Component
- Сообщает рантайму о том, что это за компонент и где искать его составляющие

 ![alt text](resources/metadataOfComponentAngular.png)

### Фильтры

 ![alt text](resources/pipes.png)

### Директивы

 ![alt text](resources/directives.png)

### Сервисы и DI

- Сервисы (services) реализуют какие-либо действия, не формируя представление (логика средствами сервиса не отражается на интерфейс, потом она как-то в интерфейсе может отразиться, но не прямым путем)
- Реализуются в виде отдельых классов в соответствии с принципами ООП
- Компонент может делигировать какие-либо из своих задач сервисам 
- Доступ компонентов к сервисам реализуется с помощью DI

 ![alt text](resources/servicesExample.png)

### DI - осуществляется элементом Angular Injector' ом

- Компоненты могут использовать сервисы с помощью DI
- Для того, чтобы класс можно было использовать с помощью DI, он должен содержать декоратор @Injectable()

#### Основные принципы реализации DI

- Приложение содержит как минимум один глобальный Injector, который занимается DI (Injector'ов может быть >1)
- Injector создает зависимости и передает их экземпляры контейнеру (container)
- Провайдер (provider) - это объект, который сообщает Injector'у, как получить или создать экземпляр зависимости
- Обычно провайдером сервиса является сам его класс 
- Зависимости компонентов указываются в качестве параметров их конструкторов 

#### Провайдеры для сервисов

 ![alt text](resources/providers.png)



## 57. Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.

### Шаблоны и представления

- Представление (view) компонента задается с помощью шаблона (template) - та самая разметка, которая будет сформирована при просмотре компонента (в браузере)
- Представления часто группируются иерархически (складываются друг в друга)
- Компонент может содержать иерархию представлений (view hierarchy), которая содержит встроенные представление (embedded views) из других компонентов

#### Синтаксис шаблонов

- Похож на обычный HTML 
- Взаимодействие с классом компонента осуществляется с помощью ссылок на его свойства (data binding) {{hero.name}}
- Также можно использовать фильтры (pipes) и директивы (directives) 

 ![alt text](resources/syntaxOfTemplate.png)

#### Связь

Связь между шаблоном и компонетом работает в обе стороны:
- Шаблон(реализация компонента) отображает данные с компонента через property binding ({{hero.name}})
- Компонент принимает данные шаблона через event binding ((click) = "selectHero(hero)")

#### Три вида связи

 ![alt text](resources/3typesOfBinding.png)


## 58. Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.

### Взаимодействие с back-end'ом

 ![alt text](resources/interactionWithBackend.png)

### Использование HttpClient

 ![alt text](resources/UsageHttpClient.png)

### Пример получения JSON с сервера 

 ![alt text](resources/GettingJsonFromServer.png)

 ![alt text](resources/GettingJsonFromServer2.png)


## Концепция Single Page Application

### SPA

Одностраничное приложение — это веб-приложение или веб-сайт, использующий единственный HTML-документ как оболочку для всех веб-страниц и организующий взаимодействие с пользователем через динамически подгружаемые HTML, CSS, JavaScript, обычно посредством AJAX

Single Page Application – сокращенно SPA, в переводе на русский язык означает “Приложение одной страницы”. Другими словами SPA – это web-приложение, размещенное на одной web-странице, которая для обеспечения работы загружает весь необходимый код вместе с загрузкой самой страницы. Приложение такого типа появились сравнительно недавно, с началом эры HTML5 и SPA является типичным представителем приложений на HTML5.

Получается немного скомкано: “Одна страница.. другая станица, третья страница… одностраничный портал”. Расставим все точки над “Ё”. Страница сайта, на котором размещены все ссылки на все CSS, и ссылки на скрипты, необходимые для работы SPA мы назовем “Web-страница”. Файл с такой странице обычно называется “index.html” (в ASP.NET MVC может быть index.cshtml или index.vbhtml или даже index.aspx) А страницы, которые переключает пользователь внутри одностраничного портала назовем “модули”.

#### Плюсы

1) Приложения на SPA отлично работают на устройствах как стационарных, так и мобильных. “Большие” компьютеры, планшеты, смартфоны, и, в конце-концов, простые телефоны (некоторые) могут беспрепятственно работать с сайтами построенных по принципу SPA. Итак, первый “плюс” – работа на большом количестве устройств, а значит, создав одно приложение, вы получаете гораздо большую аудиторию пользователей нежели при использовании стандартного подхода.
(Создать мобильное приложение проще, потому что разработчик может повторно использовать один и тот же внутренний код для веб-приложения и собственного мобильного приложения.)

2) Богатый пользовательский интерфейс, так называемый User Experience. Так как web-страница одна, построить богатый, насыщенный пользовательский интерфейс гораздо проще. Проще хранить информацию о сеансе, управлять состояниями представлений (views) и управлять анимацией (в некоторых случаях).

3) SPA существенно (в разы) сокращает так называемые “хождения по кругу”, то есть загрузку одного и того же контента снова и снова. Если ваш портал (сайт) использует шаблон, то вместе с основным содержанием какой-либо страницы посетитель сайта обязательно загружает разметку шаблона. Да, кэширование данных на данном этапе развития WWW достигло высочайших результатов, но если нечего кэшировать, то и время, и ресурсы на это не тратятся.

4) SPA работает быстро, поскольку большинство ресурсов (HTML + CSS + Scripts) загружаются только один раз за время существования приложения. Только данные передаются туда и обратно.

5) Кэширование данных — приложение отправляет всего один запрос, собирает данные, а после этого может функционировать в offline-режиме.

#### Минусы

1) Плохая SEO оптимизация. SPA работает на основе javascript и загружает информацию по запросу со стороны клиента. Поисковые системы с трудом могут имитировать данное поведение. Потому большинство страниц попросту недоступны для сканирования поисковыми ботами, поэтому продвижение сайта в 2020 может быть усложнено.

2) Неактивный javascript. Некоторые пользователи отключают javascript в своих браузерах, а без него ваше приложение не будет работать.

3) Низкий уровень безопасности. (По сравнению с «традиционным» приложением, SPA менее безопасен. Благодаря межсайтовому скриптингу (XSS) злоумышленники могут внедрять клиентские скрипты в веб-приложение другими пользователями.)

Принципы любого фреймворка (о них поговорим позже), который реализует парадигму SPA должны придерживаться следующих понятий и определений:

- SPA поддерживает клиентскую навигации. Все “хождения” пользователя по модулям-страницам однозначно фиксируются в истории навигации, причем навигация при этом является “глубокой”, то есть если пользователь скопирует и откроет ссылку на внутреннюю модуль-страницу в другом браузере или окне, он попадет на соответствующую страницу.
- SPA размещается на одной web-странице, значит всё необходимое для работы сайта (портала) скрипты и стили должны быть определены в одном месте проекта – на единственной web-странице.
- SPA хранит постоянно состояние (важные переменные) работы клиента (клиентского скрипта) в кэше браузера или в Web Storage.
- SPA загружает все скрипты требующиеся для старта приложения при инициализации web-страницы.
- SPA постепенно подгружает модули по требованию.

### MPA

Многостраничные приложения имеют более классическую архитектуру. Каждая страница отправляет запрос на сервер и полностью обновляет все данные. Даже если эти данные небольшие. Таким образом тратится производительность на отображение одних и тех же элементов. Соответственно это влияет на скорость и производительность.

#### Плюсы 

1) Легкая SEO оптимизация. Архитектура MPA позволяет достаточно легко оптимизировать каждую страницу под поисковые системы.

2) Легкая разработка. Как правило для разработки многостраничного приложения требуется меньший стек технологий.

3) Это идеальный подход для пользователей, которым нужна наглядная карта того, куда идти в приложении. Прочная, многоуровневая навигация по меню - неотъемлемая часть традиционного многостраничного приложения.

4) Множество решений.

#### Минусы

1) Для разработки мобильных приложений потребуется намного больше времени. В большинстве случаев потребуется написание back-end с нуля.

2) Сложно разделить front-end и back-end. Как правило они очень тесно взаимодействуют друг с другом. Усложняется работа front-end и back-end разработчиков.

3) Развитие становится довольно сложным. Разработчик должен использовать фреймворки как на стороне клиента, так и на стороне сервера. Это приводит к увеличению времени разработки приложения.

### Наглядные примеры 

__MPA__. Возьмём среднестатистический сайт, например, воображаемый интернет-магазин плюшевых игрушек MimimiShop. Вы заходите на главную страницу mimimi-shop.ru и видите много-много карточек с мягкими мишками. Чтобы вы смогли их увидеть, браузер послал запрос на сервер и получил файл index.php.

Один мишка очень вам нравится, и вы по нему кликаете. Ссылка меняется на mimimi-shop.ru/teddy-bears/92, страница перезагружается, браузер получает другой файл – product.php. Здесь совершенно другая информация – мишка только один, зато подробно описан.

В классическом Multi Page Application каждый url – это отдельный запрос к серверу с получением нового шаблона.

__SPA__. Перепишем MimimiShop как SPA. Вы заходите на главную страницу mimimi-shop.ru, и браузер загружает всего один файл index.html и большой скрипт mimimi.spa.js. После загрузки скрипт выводит на страницу компонент каталога – множество карточек с мягкими игрушками. Когда вы кликаете на понравившегося мишку, компонент каталога реактивно заменяется на компонент одного товара. Страница при этом не перезагружается, всё происходит красиво и плавно.

В итоге браузер отдал только одну страницу – index.html.

Требования к маршрутизации SPA:

- Переход между страницами должен происходить без перезагрузки.
- Каждый переход должен сохраняться в истории браузера (кнопки Назад/Вперед должны функционировать).
- При вводе в адресную строку некоторого маршрута должен выводиться тот контент, который этому маршруту соответствует, как в мультистраничном приложении.

### Выводы 

Каждая архитектура имеет свои преимущества и недостатки и хорошо подходит для определенного типа проекта. SPA отличается своей скорость и возможностью на базе готового кода разработать мобильное приложение. Но в тоже время, SPA имеет плохую SEO оптимизацию. Таким образом данная архитектура отлично подход для SaaS платформ, социальных сетей, закрытых сообществ, где поисковая оптимизация не имеет значения.

MPA больше подходит для создания крупных интернет магазинов, бизнес сайтов, каталогов, маркетплейсов и т.п. Хорошо оптимизированная MPA имеет высокую скорость и производительность, но все же не позволяет легко разработать мобильное приложение. MPA и SPA с правильной архитектурой хорошо подходят для разработки масштабируемых веб приложений.


## Вопросы к себе

1) Зачем export default в файлах js
2) Отличие react-router от react-router-dom
3) When using Webpack you need to require images in order for Webpack to process them, which would explain why external images load while internal do not, so instead of <img src={"/images/resto.png"} /> you need to use <img src={require('/images/image-name.png')} /> replacing image-name.png with the correct image name for each of them. That way Webpack is able to process and replace the source img.
4) rest easy что це такое
5) Лучше деплоить вместе или раздельно 
6) Отличие Spring от JavaEE тщательнее
7) Как связаны JNDI c IoC, CDI, Location Transparency 
8) Middleware who is it (thunk)
9) 12 вопрос
10) принцип работы redux (dispatch, reducer, store, actions)

Концепция Single Page Application

- конспект видео про Spring (2 часа)
- конспект семинара с Цопой 
- 12 вопрос

# Spring Data (пахнет плохо)

Spring Data — дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без имплементации.

Миссия Spring Data состоит в том, чтобы предоставить знакомую и последовательную модель программирования на основе Spring для доступа к данным, сохраняя при этом особые черты базового хранилища данных.

Он упрощает использование технологий доступа к данным, реляционных и нереляционных баз данных, фреймворков с сокращением карт и облачных служб данных. Это зонтичный проект, который содержит множество подпроектов, специфичных для данной базы данных. Проекты разрабатываются в сотрудничестве со многими компаниями и разработчиками, стоящими за этими захватывающими технологиями.

Что умеет: https://habr.com/ru/post/435114/#:~:text=Spring%20Data%20%E2%80%94%20%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9%20%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D1%8B%D0%B9%20%D0%BC%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC,%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2%20%D0%B8%D0%B7%20%D0%B8%D0%BC%D0%B5%D0%BD%D0%B8%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0

data access object (DAO) — абстрактный интерфейс к какому-либо типу базы данных или механизму хранения. Определённые возможности предоставляются независимо от того, какой механизм хранения используется и без необходимости специальным образом соответствовать этому механизму хранения.

В стеке Spring существует проект Spring Data, реализующий большую часть тривиальных задач и упрощающий работу с источниками данных. В качестве источников данных могут использоваться как стандартные реляционные базы данных, так и NoSQL-хранилища вроде MongoDB или Redis.  
Spring Data - это проект, управляемый Spring, который направлен на обеспечение согласованного уровня доступа к данным для различных хранилищ данных, от реляционных баз данных до баз данных без sql.  
Spring Data НЕ является спецификацией или стандартом . Данные Spring - это абстракция . Это зонтичный проект, в котором есть несколько модулей (например, spring-data-redis, spring-data-mongo и т. Д.) И основной модуль, называемый spring-data-commons. Эта абстракция пытается обеспечить согласованность между способами доступа к данным в нескольких хранилищах данных.

В мире Java EE стандартом дефакто для работы с базами данных является JPA (Java Persistence API). Spring Data JPA, будучи частью Spring Data, реализует взаимодействие с реляционными СУБД, основываясь на JPA.

## Основные модули
Spring Data Commons - основные концепции Spring, лежащие в основе каждого модуля Spring Data.

Spring Data JDBC - поддержка репозитория Spring Data для JDBC.

Spring Data JDBC Ext - Поддержка расширений стандартного JDBC для конкретных баз данных, включая поддержку быстрого переключения при отказе соединения Oracle RAC, поддержку AQ JMS и поддержку использования расширенных типов данных.

Spring Data JPA - поддержка репозитория Spring Data для JPA.

Spring Data KeyValue - на Map основе хранилища и модули SPI легко построить модуль Spring данных для значения ключа магазинов.

Spring Data LDAP - поддержка репозитория Spring Data для Spring LDAP .

Spring Data MongoDB - основанная на Spring объектно-документационная поддержка и репозитории для MongoDB.

Spring Data Redis - Простая настройка и доступ к Redis из приложений Spring.

Spring Data REST - экспортирует репозитории Spring Data как ресурсы RESTful, управляемые гипермедиа.

Spring Data для Apache Cassandra - Простая настройка и доступ к Apache Cassandra или крупномасштабным высокодоступным приложениям Spring, ориентированным на данные.

Spring Data для Apache Geode - Простая настройка и доступ к Apache Geode для высоконадежных, ориентированных на данные приложений Spring с низкой задержкой.

Spring Data для Pivotal GemFire - Простая настройка и доступ к Pivotal GemFire ​​для ваших согласованных, ориентированных на данные приложений Spring с низкой задержкой / высокой пропускной способностью.

## Spring Data JPA

Spring Data JPA  является одним из многих  Spring Data  проектов и направлено в направлении обеспечения согласованности в доступе к данным для реляционных хранилищ данных. Многие люди считают Spring Data JPA реализацией JPA. На самом деле это ложь. Spring Data JPA использует реализацию JPA по умолчанию, называемую Hibernate . Реализация JPA по умолчанию является настраиваемой, и при желании мы можем использовать и другие реализации.

### Что такое Spring Data JPA, если не реализация JPA?
Точнее говоря, Spring Data JPA - это надстройка для JPA. он предоставляет структуру, которая работает вместе с JPA и обеспечивает полную абстракцию на уровне доступа к данным в проекте.

Spring Data JPA включает в себя концепцию  репозиториев JPA  - набор  интерфейсов,  которые определяют методы запроса . Repository и Entity Bean представляют уровень DAO в приложении. Больше не нужно писать собственные запросы. Иногда нам нужно писать запросы или их часть, но это запросы JQL, а не собственные запросы к базе данных.

 ____
 
 Spring Data is a high level SpringSource project whose purpose is to unify and ease the access to different kinds of persistence stores, both relational database systems and NoSQL data stores.  
 Spring Data - это высокоуровневый проект SpringSource, целью которого является унификация и упрощение доступа к различным типам хранилищ постоянства, как системам реляционных баз данных, так и хранилищам данных NoSQL.
 
 
 ![alt-text](resources/SpringData.png)
 
 Со всеми типами постоянных хранилищ ваши репозитории (также известные как DAO или объекты доступа к данным) обычно предлагают операции CRUD (создание-чтение-обновление-удаление) для объектов одного домена, методов поиска, сортировки и разбивки на страницы. Spring Data предоставляет универсальные интерфейсы для этих аспектов (CrudRepository, PagingAndSortingRepository), а также конкретные реализации хранилища сохраняемости.
 
 Хотя объекты-шаблоны мощные, мы можем добиться большего. В репозиториях Spring Data вам нужно только написать интерфейс с методами поиска, определенными в соответствии с заданным набором соглашений (которые могут варьироваться в зависимости от типа используемого вами хранилища постоянства). Spring Data предоставит соответствующую реализацию этого интерфейса во время выполнения. Например:
 
 ```java
public interface UserRepository extends MongoRepository<User, String> { 
        @Query("{ fullName: ?0 }")
        List<User> findByTheUsersFullName(String fullName);

        List<User> findByFullNameLike(String fullName, Sort sort);
}
...

Autowired UserRepository repo;
```

# REST 

REST (от англ. Representational State Transfer — «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.

В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является альтернативой RPC.
 
В сети Интернет вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют «REST-запрос»), а необходимые данные передаются в качестве параметров запроса[2][3].
 
Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTful».
 
В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом. Несмотря на то, что REST не является стандартом сам по себе, большинство RESTful-реализаций используют такие стандарты, как HTTP, URL, JSON и XML (но XML зачастую не принято использовать).

## Ресурс

Ресурс — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:

- Конкретный пользователь
- Конкретная задача
- Список задач

### URI ресурса

Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например:

- Создать пользователя: POST /users
- Удалить пользователя: DELETE /users/1
- Получить всех пользователей: GET /users
- Получить одного пользователя: GET /users/1

## Вот как обычно реализуется служба REST:
   
- Формат обмена данными: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML
- Транспорт: всегда HTTP. REST полностью построен на основе HTTP.
- Определение сервиса: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger.

____

REST (RESTful) - это общие принципы организации взаимодействия приложения/сайта с сервером посредством протокола HTTP. Особенность REST в том, что сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции.

Всё взаимодействие с сервером сводится к 4 операциям (4 - это необходимый и достаточный минимум, в конкретной реализации типов операций может быть больше):
1. получение данных с сервера (обычно в формате JSON, или XML)
2. добавление новых данных на сервер
3. модификация существующих данных на сервере
4. удаление данных на сервере

___
API, использующие протокол HTTP для передачи запросов и ответов, рассматриваются как «веб-сервисы». В случае веб-сервисов клиент, делающий запрос на ресурс, и сервер API, предоставляющий ответ, могут использовать любой язык программирования или платформу. Не имеет значения, какой ЯП или платформа будут использоваться, потому что запрос сообщения и ответ сделаны через общий веб-протокол HTTP.

Веб-протокол является частью прекрасного веб-сервисов: они независимы от языка и поэтому совместимы между различными платформами и системами. При документировании REST API не имеет значения, строят ли инженеры API с помощью Java, Ruby, Python или какого-либо другого языка. Запросы выполняются через HTTP, и ответы возвращаются через HTTP.

## SOAP

До того, как REST стал самым популярным веб-сервисом, SOAP (Simple Object Access Protocol) был гораздо более распространенным. Чтобы лучше понять REST, полезно иметь некоторое понимание SOAP. Заодно и увидеть, что отличает SOAP и REST.

SOAP - это стандартизированный протокол, который требует XML в качестве формата сообщений для запросов и ответов. Как стандартный протокол, формат сообщения обычно определяется с помощью файла WSDL (язык описания веб-служб).

Файл WSDL определяет разрешенные элементы и атрибуты в обмениваемых сообщениях. Файл WSDL является машиночитаемым и используется серверами, взаимодействующими друг с другом для облегчения связи.

Сообщения SOAP заключены в «конверт», который включает в себя заголовок и тело, используя определенную схему XML и пространство имен. Пример формата запроса и ответа SOAP см. SOAP против REST 101: понимание различий.

Основная проблема с SOAP заключается в том, что формат сообщений XML слишком многословный и тяжелый. Особенно это проблематично в мобильных сценариях, где размер файла и пропускная способность играют решающее значение. Многословный формат сообщения замедляет время обработки, что делает взаимодействия SOAP вялым.

SOAP по-прежнему используется в enterprise приложениях (особенно в финансовых учреждениях) со связью server-to-server, но в последние годы SOAP вымещается REST, особенно для API открытых сетей.

___

                                                                                                                                                                                                                                                                                                                                          
SOAP - простой протокол доступа к объектам - вероятно, наиболее известная из двух моделей.

SOAP в значительной степени полагается на XML и вместе со схемами определяет структуру обмена сообщениями с очень строгим контролем типов.

Каждая операция, предоставляемая службой, явно определяется вместе со структурой XML запроса и ответа для этой операции.

Каждый входной параметр аналогичным образом определяется и привязан к типу: например, целому числу, строке или другому сложному объекту. 

Все это кодифицировано на языке WSDL - описания веб-службы (или определения в более поздних версиях). WSDL часто объясняется как договор между поставщиком и потребителем услуги. С точки зрения программирования WSDL можно рассматривать как сигнатуру метода для веб-службы.      

## Критика SOAP

Хотя на первый взгляд WSDL может показаться отличным - он самодокументируется и содержит почти полную картину всего, что требуется для интеграции с сервисом, - он также может стать обузой.

Помните, что WSDL - это контракт между вами (поставщиком услуги) и каждым из ваших клиентов (потребителей услуги).

Изменения WSDL также означают изменения клиента.

Если вы хотите внести изменения в свой API, даже такие небольшие, как добавление необязательного параметра, WSDL должен измениться. И изменения WSDL также означают изменения клиентов - все ваши потребители должны перекомпилировать свое клиентское приложение с этим новым WSDL.

Это небольшое изменение значительно увеличивает нагрузку на команды разработчиков (по обе стороны коммуникации), а также на команды тестирования. По этой причине WSDL рассматривается как привязка к версии, и большинство провайдеров очень сопротивляются обновлению своего API.

Более того, хотя SOAP предлагает некоторую интересную гибкость, такую ​​как возможность передачи по любому транспортному протоколу, на самом деле никто не воспользовался большинством из них.

Благодаря развитию Интернета все, что имеет значение, работает через HTTP.

Есть новые достижения, но большинству из них мешает то, что маршрутизаторы инфраструктуры отказываются маршрутизировать нестандартный HTTP-трафик. Только подумайте: сколько времени мир пытается перейти на IPv6?

Определенно существует потребность в более легкой и гибкой модели.

В любой ситуации, когда размер передаваемого сообщения не имеет значения или где вы контролируете все от начала до конца, протокол SOAP почти всегда является лучшим ответом.

Это в первую очередь относится к прямому обмену данными между серверами, обычно используемым для внутреннего взаимодействия только в рамках одной компании.

Однако существует потребность в мире, в котором почти каждый человек на планете имеет несколько устройств с низким объемом памяти и малой вычислительной мощностью, постоянно подключенных к нескольким службам, определенно существует потребность в более легкой и гибкой модели.


## Особенности REST

- Как и SOAP, REST (Representational State Transfer) использует HTTP в качестве протокола передачи данных для запросов и ответов. Однако, в отличие от SOAP, REST является архитектурным стилем, а не стандартным протоколом. Вот почему REST API иногда называют RESTful API - REST - это общий стиль, которому следует API.
  
  API-интерфейс RESTful может не соответствовать всем официальным характеристикам REST, указанным доктором Роем Филдингом, который впервые описал эту модель. Следовательно, API являются «RESTful» или «REST-подобными». (Некоторые разработчики настаивают на использовании термина «RESTful», когда API не соответствует всем характеристикам REST, но большинство людей просто называют их «REST API»)
  
- В архитектурном стиле нет ограничений XML в качестве формата сообщения. API REST могут использовать любой формат сообщений, который хотят использовать разработчики API, включая XML, JSON, Atom, RSS, CSV, HTML и другие.

  Несмотря на разнообразие параметров формата сообщений, большинство API REST используют JSON (нотацию объектов JavaScript) в качестве формата сообщений по умолчанию. Они используют JSON, потому что он обеспечивает легкий, простой и более гибкий формат сообщений, который увеличивает скорость связи. Облегченная природа JSON также позволяет выполнять сценарии мобильной разработки и легок для парсинга в Интернете с помощью JavaScript.

- REST фокусируется на ресурсах, доступ к которым осуществляется через URL   

  Другой отличительной чертой REST является то, что API-интерфейсы REST фокусируются на ресурсах (то есть вещах, а не действиях) и способах доступа к ресурсам. Ресурсы, как правило, являются разными типами информации. Вы получаете доступ к ресурсам через URL (Uniform Resource Locators), так же как переход к URL-адресу в вашем браузере позволяет подключиться к информационному ресурсу. URL-адреса сопровождаются методом, который указывает, как вы хотите взаимодействовать с ресурсом.
  
  Общие методы включают GET (чтение), POST (создание), PUT (обновление) и DELETE (удаление). Конечная точка обычно включает параметры запроса, которые определяют более подробную информацию о представлении ресурса, который нужно увидеть. Например, можно указать (в параметре запроса) ограничение на отображение 5 экземпляров ресурса.Другой отличительной чертой REST является то, что API-интерфейсы REST фокусируются на ресурсах (то есть вещах, а не действиях) и способах доступа к ресурсам. Ресурсы, как правило, являются разными типами информации. Вы получаете доступ к ресурсам через URL (Uniform Resource Locators), так же как переход к URL-адресу в вашем браузере позволяет подключиться к информационному ресурсу. URL-адреса сопровождаются методом, который указывает, как вы хотите взаимодействовать с ресурсом.
                                                                                                                                                                                                                                                                                                                                            
- API REST не сохраняют состояния запроса, но ответы могут кэшироваться

  REST API не сохраняют свои состояния и могут кэшироваться. Отсутствие состояния означает, что каждый раз, когда вы обращаетесь к ресурсу через конечную точку, API предоставляет один и тот же ответ. Он не запоминает ваш последний запрос и не учитывает его при предоставлении нового ответа. Другими словами, нет ранее запомненных состояний, которые API учитывает при каждом запросе.
  
  Ответы могут кэшироваться для повышения производительности. Если кэш браузера уже содержит информацию, запрашиваемую в запросе, браузер может просто вернуть информацию из кэша вместо того, чтобы снова стучаться на сервер.
  
  Кэширование API REST аналогично кешированию веб-страниц. Браузер использует значение времени последнего изменения в заголовках HTTP, чтобы определить, нужно ли ему снова получать ресурс. Если содержимое не было изменено с момента последнего извлечения, вместо него можно использовать кэшированную копию. Кэширование увеличивает скорость ответа.
  
- API REST не используют файлы WSDL, но некоторые спецификации все же существуют

  Важным аспектом API REST, особенно в контексте документации, является то, что они не используют файл WSDL для описания элементов и параметров, разрешенных в запросах и ответах.
  
  Хотя и существует возможный файл WADL (Web Application Description Language), который можно использовать для описания API-интерфейсов REST, им используются редко, поскольку там неадекватно описываются все ресурсы, параметры, форматы сообщений и другие атрибуты API-интерфейса REST. , (Помните, что REST API - это архитектурный стиль, а не стандартизированный протокол.)
                    
## Критика REST

Небольшой размер и использование широко распространенного стандарта HTTP делает REST очень привлекательным вариантом для общедоступных API.
                    
В сочетании с JSON, который делает что-то вроде добавления необязательного параметра очень простым, делает его очень гибким и позволяет частые выпуски, не затрагивая ваших потребителей.
                    
Возможно, самым большим недостатком является WADL - необязательный и не имеющий некоторой необходимой информации. Чтобы устранить этот недостаток, на рынке есть несколько платформ, которые помогают документировать и создавать RESTful API, например Swagger , RAML или JSON-home . Swagger был подарен инициативе Open API Iniative и теперь называется OpenAPI (OAS). Перейдите на Swagger.io, где вы можете узнать больше об этом стандарте, спецификации и о том, как инструменты Swagger играют роль.
                                                                                                                                                                                                                                                                                                                                               
## Разница между SOAP и REST

Термин веб-API обычно относится к обеим сторонам компьютерных систем, взаимодействующих по сети: к службам API, предлагаемым сервером, а также к API, предлагаемому клиентом, таким как веб-браузер.

Серверная часть веб-API представляет собой программный интерфейс для определенной системы сообщений «запрос-ответ» и обычно называется веб-службой. Существует несколько моделей проектирования веб-сервисов, но две наиболее распространенные - это SOAP и REST.

SOAP предоставляет следующие преимущества по сравнению с REST:

- Независимость от языка, платформы и транспорта (REST требует использования HTTP)     
- Хорошо работает в распределенных корпоративных средах (REST предполагает прямую связь точка-точка)
- Стандартизированный
- Обеспечивает значительную расширяемость перед сборкой в ​​форме стандартов WS *
- Встроенная обработка ошибок
- Автоматизация при использовании с определенными языковыми продуктами

REST по большей части проще в использовании и более гибок. Он имеет следующие преимущества по сравнению с SOAP:

- Использует простые для понимания стандарты, такие как swagger и OpenAPI Specification 3.0.
- Меньшая кривая обучения
- Эффективность (SOAP использует XML для всех сообщений, REST в основном использует меньшие форматы сообщений, такие как JSON)
- Быстро (не требуется обширной обработки)
- Ближе к другим веб-технологиям в философии дизайна

### Примерчик

Как сказано в одном руководстве по REST API: SOAP похож на конверт, а REST - это просто открытка.

Конечно, открытку быстрее и дешевле отправить, чем конверт, но ее все равно можно обернуть чем-то другим, даже конвертом.

Вы также можете просто прочитать открытку, в то время как конверт требует нескольких дополнительных действий, таких как открытие или разворачивание, чтобы получить доступ к тому, что внутри
   
# REST Кратко 

Representational State Transfer = «представление данных в удобном для клиента формате»

- Все является ресурсами с уникальным идентификатором (URL)
- Все операции клиента с сервером stateless, т.е. сервер не должен хранить вообще никакой информации о клиенте – никакой сессии
- Все запросы можно поделить на 4 типа в соответствии с CRUD, причем каждому типу сопоставляется HTTP метод – Post, Get, Put и Delete
- Вся логика крутится вокруг ресурсов, а не операций

## Принципы 

Важно понимать, что REST – это не протокол и не стандарт, а архитектурный стиль. У этого стиля есть свои принципы. Позволю себе скопировать их с понравившегося источника и прокомментировать:

- Give every “thing” an ID.  
  Очччень желательно.
  
- Link things together.  
  Например, в страницу (представление) о Mercedes C218 хорошо бы добавить ссылку на страницу конкретно о двигателе данной модели, чтобы желающие могли сразу туда перейти, а не тратить время на поиск этой самой страницы.
  
- Use standard methods.  
  Имеется в виду, экономьте свои силы и деньги заказчика, используйте стандартные методы HTTP, например GET
  http://www.example.com/cars/00345
  для получения данных вместо определения собственных методов вроде getCar?id=00345.
  
- Resources can have multiple representations.  
  Одни и те же данные можно вернуть в XML или JSON для программной обработки или обернутыми в красивый дизайн для просмотра человеком.
  
- Communicate statelessly.  
  Да, RESTful сервис должен быть как идеальный суд – его не должно интересовать ни прошлое подсудимого (клиента), ни будущее – он просто выносит приговор (отвечает на запрос).
  
## Сравнение SOAP и REST

1. SOAP – это целое семейство протоколов и стандартов, откуда напрямую вытекает, что это более тяжеловесный и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.
2. SOAP используют HTTP как транспортный протокол, в то время как REST базируется на нем. Это означает, что все существующие наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование, продолжают так же работать в REST архитектуре, а для SOAP необходимо искать другие средства. Взамен этого SOAP сервисы получают такое мифическое свойство, как возможность работать с любым протоколом транспортного уровня вместо HTTP, однако практической пользы от него зачастую не больше, чем сотрудникам Челябинского трубопрокатного завода от большого количесва статей в википедиях на мертвых языках.
3. Есть мнение, что разработка RESTful сервисов намного проще. Наверное, это правда, если использовать Notepad в качестве основной среды разработки, но вот с использованием наших чудесных средств разработки, я позволю себе усомниться в верности этого утверждения.
4. В первом гугловском результате по запросу «REST vs SOAP» акцентируется внимание на том, что ответ REST может быть представлен в различных форматах, а SOAP привязан к XML. Это действительно важный фактор, достаточно представить себе вызов сервиса из javascript, ответ на который мы определенно хотим получать в JSON.
5. «REST vs SOAP» можно перефразировать в «Простота vs Стандарты», что проявляется в том, что для SOAP мы имеем протокол WSDL для исчерпывающего описания веб-сервиса, который с использованием все тех же чудесных средств разработки прото-таки волшебным образом делает почти всю работу за нас. Со стороны REST мы имеем загадочный и неиспользуемый протокол WADL, который, в принципе, и не нужен – он мешает простоте.
6. Второй аспект предыдущего пункта – обработка ошибок. В SOAP она полностью стандартизована, а REST может использовать давно известные коды ошибок HTTP (если здесь Вас посетила мысль, что это же очевидно и зачем я это пишу, то значит Вы внимательно читаете статью).
7. То, с чего можно было бы начать, но я припас напоследок. Это одна из ключевых мыслей. SOAP работает с операциями, а REST – с ресурсами. Этот факт в совокупности с отсутствием клиентского состояния у RESTful сервисов приводит нас к тому, что такие вещи как транзакции или другая сложная логика должна реализовываться «SOAP-но».

## Пример REST

Букмекерская контора заказала сервис для работы с футбольной статистикой. Пользовательский функционал – получить список матчей, получить детали о матче. Для редакторов – редактировать (Create, Edit, Delete) список матчей, редактировать детали матча. Для такой задачи однозначно надо выбирать подход REST и получать бенефиты от его простоты и естественности во взаимодействии с HTTP. Не нужны нам здесь SOAP-конверты, SOAP-главпочтамты и SOAP-авиапочта, которая может использовать любую марку самолета

## Пример SOAP

Та же букмекерская контора захотела API для ставок на live матчи. Эта процедура включает в себя многочисленные проверки, например, продолжает ли ставка быть актуальной, не изменился ли коэффициент, не превышена ли максимальная сумма ставки для маркета. После этого происходит денежная транзакция, результаты которой записываются в основную и в резервные базы данных. Лишь после этого клиенту приходит ответ об успешности операции. Здесь явно прослеживается ориентация на операции, имеются повышенные требования к безопасности и устойчивости приложения, поэтому целесообразно использовать SOAP.

## Выводы
Филдинг со своими принципами REST ничего не изобрел, а просто собрал в одну диссертацию то, что уже существовало в каком-то виде и изложил то, как можно получать максимальную выгоду из уже сформировавшейся архитектуры сети.

SOAP и REST – не конкуренты. Они представляют разные весовые категории и вряд ли найдется задача, для которой будет сложно сказать, какой подход рациональнее использовать – SOAP или REST. Поэтому «религиозные» убеждения в вопросах выбора архитектуры для веб-сервиса вряд ли будут полезны. Для тех, кто не знает, с чего начать анализ задачи, могу
                    
REST против SOAP можно перефразировать как “Простота против Стандарта”. В случае REST (простота) у вас будет скорость, расширяемость и поддержка многих форматов. В случае с SOAP у вас будет больше возможностей по безопасности (WS-security) и транзакционная безопасность (ACID).
                    
## JAX-WS и JAX-RS

JAX-WS -is Java API для XML-Based Web Services-стандартный способ разработки Web-сервисов в нотации SOAP (Simple Object Access Protocol).

Вызов веб-служб осуществляется с помощью удаленных вызовов процедур. Для обмена информацией между клиентом и веб-сервисом используется протокол SOAP. Обмен сообщениями между клиентом и сервером осуществляется через XML - основанные SOAP сообщения.

Клиенты веб-службы JAX-WS нуждаются в файле WSDL для генерации исполняемого кода, который клиенты могут использовать для вызова веб-службы.

JAX-RS -Java API для веб-служб RESTful. RESTful веб-службы представлены как ресурсы и могут быть идентифицированы с помощью унифицированных идентификаторов ресурсов ( URI ). Удаленный вызов процедуры в этом случае представляется HTTP-запросом и необходимые данные передаются в качестве параметров запроса. Веб-сервисы RESTful-более гибкие, могут использовать несколько различных MIME - типов. Обычно используется для обмена данными XML или JSON (обозначение объекта JavaScript)...

## RPC и REST

- RPC API думает в терминах «глаголы», обнажая функциональность ресторана , как вызовы функций , которые принимают параметры, и вызывает эти функции с помощью HTTP глагол , который кажется наиболее подходящим - это «получить» для запроса, и так далее, но имя глагола является чисто случайным и не имеет реального отношения к реальной функциональности, поскольку вы каждый раз вызываете другой URL-адрес . Коды возврата кодируются вручную и являются частью контракта на обслуживание.

- REST API , в отличии от модели различных объектов в пределах проблемной области как ресурсы и использование HTTP глаголов для представления операций против этих ресурсов - POST для создания, PUT для обновления и GET для чтения. Все эти команды, вызываемые по одному и тому же URL-адресу , обеспечивают разную функциональность. Общие коды возврата HTTP используются для передачи статуса запросов.

## RPC и SOAP

Во-первых, очевидно, что дизайн отличается. Структурная архитектура SOAP более сложна по сравнению с RPC. Он содержит сообщения XML , которые преобразуются с помощью SOAP-Envelope. RPC, с другой стороны, использует XML как для кодирования, так и для декодирования вызовов удаленных процедур в пределах своих параметров. У него более простая архитектура по сравнению с SOAP.

Во-вторых, в SOAP порядок не имеет значения, и процедуры в основном принимают именованные параметры. В XML-RPC все наоборот. Порядок имеет значение, и процедуры не должны принимать именованные параметры.

SOAP считается более мощным; со спецификациями 1.2 умещается на 44 страницы, а RPC умещается на 6 страницах.  
Также следует учитывать, что протокол SOAP, как известно, более подробен, но зачастую более эффективен, чем RPC. Однако с точки зрения поддержки python в стандартной библиотеке RPC значительно поддерживается по сравнению с SOAP.

## Когда выбирать REST и SOAP

Теперь имейте в виду, что использование SOAP 1.2 сопряжено с некоторыми дополнительными накладными расходами, которых нет в подходе REST, но эти накладные расходы также имеют преимущества. Во-первых, SOAP использует XML (расширяемый язык разметки) тремя способами; Конверт - определяет, что находится в сообщении и как его обрабатывать, набор правил кодирования для типов данных и, наконец, макет собранных вызовов процедур и ответов. Этот конверт отправляется через транспорт (HTTP / HTTPS), выполняется RPC (удаленный вызов процедуры), и конверт возвращается с информацией в документе в формате XML.

Важно отметить, что одним из преимуществ SOAP является использование «универсального» транспорта. В то время как REST сегодня использует HTTP / HTTPS, SOAP может использовать практически любой транспорт для отправки запроса, используя все, от вышеупомянутого до SMTP (Simple Mail Transfer Protocol) и даже JMS (Java Messaging Service). Однако одним очевидным недостатком является использование XML из-за его многословности и времени, необходимого для анализа.

Но неописуемая история заключается в том, что обе технологии можно смешивать и сочетать. REST очень прост для понимания и чрезвычайно доступен, но ему не хватает стандартов и он считается архитектурным подходом. Для сравнения: SOAP - это отраслевой стандарт с четко определенным протоколом и набором четко установленных правил, которые необходимо реализовать, и он используется как в больших, так и в малых системах.

### Когда выбирать REST

Это означает, что REST действительно хорошо работает в следующих областях:

- Ограниченная пропускная способность и ресурсы; помните, что структура возврата действительно в любом формате (определенном разработчиком). Кроме того, можно использовать любой браузер, потому что подход REST использует стандартные команды GET , PUT , POST и DELETE . Опять же, помните, что REST также может использовать объект XMLHttpRequest, который сегодня поддерживают большинство современных браузеров, что добавляет дополнительный бонус AJAX.

- Операции без сохранения состояния; если операцию необходимо продолжить, тогда REST - не лучший подход, и SOAP может подойти ему лучше. Однако, если вам нужны операции CRUD без сохранения состояния (создание, чтение, обновление и удаление), тогда REST - это то, что вам нужно.

- Кеширование ситуаций; если информация может быть кэширована из-за полностью не имеющего состояния операции подхода REST, это прекрасно.

### Когда выбирать SOAP

Это охватывает множество решений из трех вышеупомянутых. Так зачем мне вообще рассматривать SOAP? Опять же, SOAP является достаточно зрелым и четко определенным и поставляется с полной спецификацией. Подход REST - это всего лишь подход, который широко открыт для разработки, поэтому, если у вас есть следующее, SOAP - отличное решение:

- Асинхронная обработка и вызов; если вашему приложению требуется гарантированный уровень надежности и безопасности, то SOAP 1.2 предлагает дополнительные стандарты для обеспечения такого типа работы. Такие вещи, как WSRM - надежный обмен сообщениями WS.

- Официальные контракты; если обе стороны (поставщик и потребитель) должны согласовать формат обмена, тогда SOAP 1.2 дает жесткие спецификации для этого типа взаимодействия.

- Операции с отслеживанием состояния ; если приложению требуется контекстная информация и управление диалоговым состоянием, тогда SOAP 1.2 имеет дополнительную спецификацию в структуре WS * для поддержки этих вещей (безопасность, транзакции, координация и т. д.). Для сравнения, подход REST заставил бы разработчиков построить эту нестандартную сантехнику.
  
  
### 59.LESS / SASS / SCSS. Особенности, отличия, поддержка браузерами

#### LESS

__LESS__ - это динамический язык стилей, который является надстройкой над CSS (Поэтому любой CSS код будет валидный LESS).

Приемущества LESS:

1. Переменные (и области видимости переменных).
2. Операции (в том числе и для управления цветом, т.е можно смешивать цвета: #941f1f + #222222).
3. И другие функции для работы с цветом (осветление, затемнение и т.п.)
4. Вложенность (можно вложить одно правило в другое, article.post p {} <=> article.post { p{ }}).
5. Объединение аргуметов.

LESS-файл конвертируется в CSS при помощи js (для этого необходимо скачать less.js с сайта LESS).

#### SASS

__Sass__ - это метаязык на основе CSS, предназначенный для увеличения уровня абстракции CSS кода и упрощения файлов каскадных таблиц стилей.

Приемущества Sass:

1. Вложенные правила.
2. Переменные.
3. Возможность создавать миксины, позволяющие создавать многоразовые CSS-правила - группы деклараций, для многократного использования. (LESS в это не может)
4. Расширения. Одиночный селектор может быть расширен больше, чес одним селектором с помошью @extend.
5. Есть логика. (if/then/for). (Этого в LESS тоже нет)


Не может компилироватся на сервере в CSS (LESS использует js).
Браузер не распознает файлы Sass, так что сначала их нужно скомпилировать в обычный CSS.

#### SCSS

__SCSS__ — "диалект" языка SASS. Отличие SCSS от SASS заключается в том, что SCSS больше похож на обычный CSS код.

1. @import - @import "template" подключит template.scss.
2. Вложенность.
3. $переменные.
4. Математика чисел и цветов.
5. Строки (умеет складвать строки, поддерживает конструкцию #{$var})

Файлы, заканчивающиеся на .scss представляют собой стандартный синтаксис, поддерживаемый Sass. SCSS - это надмножество CSS. Файлы, заканчивающиеся на .sass представляют собой "старый" синтаксис, поддерживаемый Sass, происходящим в мире ruby.

### 60.Java SE, Java EE, Java ME. Платформа Java EE, понятие контейнера и компонента

- Java SE — основные инструменты и библиотеки языка
- Java EE — платформа для enterprise серверных приложений (JSP, JSF, сервлеты и т.д.)
- Java ME — урезанная платформа для мобильных устройств (в основном использовалась до появления iOS/Android)

#### Контейнер
Сервлеты — серверные сценарии, жизненным циклом которых управляет веб-контейнер. Существует несколько веб-контейнеров (Apache Tomcat, GlassFish, Jetty, др.); они все реализуют определенный стандарт Java EE (6/7/8).

__Сервлет-контейнер__ поддерживает только API сервлета (включая JSP, JSTL).
Сервер приложений поддерживает весь JavaEE - EJB, JMS, CDI, JTA, API сервлета (включая JSP, JSTL) и т.д.

#### Архитектура JavaEE
1. При запуске веб-контейнер читает манифест (web.xml) приложения и создает для него ServletContext. Для каждого класса сервлета и фильтра из манифеста создается объект. Контекст и объекты фильтров/сервлетов будут жить на протяжении работы приложения, т.е. одна и та же инстанция будет использоваться для всех запросов и сессий.

2. При поступлении HTTP запроса веб-контейнер создает новые объекты HttpServletRequest и HttpServletResponse и передает их фильтрам, потом сервлету.

#### Компонент
Компонент пользовательского интерфейса JSF является основным строительным блоком для создания пользовательского интерфейса JSF. Конкретный компонент представляет собой настраиваемый и многоразовый элемент в пользовательском интерфейсе, который может варьироваться от простой (например, кнопки или текстового поля) до составного (например, дерева управления или таблицы).

### Структура HTTP запроса, передающего логин и пароль пользователя
```http request
POST /login.cgi HTTP/1.1
Host: www.vk.com

login=hello&password=chmo
```


### 61. ESMAScript - особенности, типы данных, инструкции.

__ECMAScript__ — это встраиваемый расширяемый не имеющий средств ввода-вывода язык программирования, используемый в качестве основы для построения других скриптовых языков. Стандартизирован международной организацией ECMA в спецификации. (ECMAScript это стандарт, а JavaScript его реализация).

Имеет 5 примитивных типов данных — Number, String, Boolean, Null и Undefined; Объектный тип данных — Object и 15 различных видов инструкций.

В особенности можно добавить то, что блок не ограничивает область видимости функции. Если переменная объявляется вне функции, то она попадает в глобальную область видимости. Функция — это тоже объект.

#### ES6
Это обновление добавило новый синтаксис для написания классов и модулей, добавились итераторы и циклы for/of, Python-style генераторы, двоичные данные, лямбда-выражения, типизированные массивы, коллекции, обещания (promises), рефлексию и прокси, усовершенствовали числа и математику. Добавлено ключевое слово let (которое помогает объявить переменной область видимости - блок) и const.

#### ES7
Добавлена операция возведения в степень (**), Array.prototype.includes().

### Правила трансляции JSP

При загрузке в веб-контейнер страницы JSP транслируются компилятором (jasper) в сервлеты.

Во время фазы трансляции контейнер локализует или создаёт класс реализации JSP-страницы, соответствующий данной JSP-странице. Этот процесс определяется семантикой JSP-страницы. Контейнер интерпретирует имеющиеся на этой странице стандартные директивы и акции и специальные акции, ссылающиеся на библиотеки тэгов. Библиотека тэгов может по выбору представлять метод проверки корректности использования на JSP-странице данной библиотеки.

### 62. Методы HTTP

#### Методы запросов:

- Метода GET в HTTP используется для получения информации от сервера по заданному URI (URI в HTTP). Запросы клиентов, использующие метод GET должны получать только данные и не должны никак влиять на эти данные. Сервер кэширует ответы

- HTTP метод HEAD работает точно так же, как GET, но в ответ сервер посылает только заголовки и статусную строку без тела HTTP сообщения. (используется для получения метаинформации об объекте без пересылки тела HTTP сообщения) (Метод HEAD часто используется для тестирования HTTP соединений и достижимости узлов и ресурсов, так как нет необходимости гонять по сети содержимое, тестирование HTTP методом HEAD производится гораздо быстрее.) Сервер может кэшировать ответы

- HTTP метод POST используется для отправки данных на сервер, например, из HTML форм, которые заполняет посетитель сайта. Сервер НЕ кэширует ответы

- HTTP метод PUT используется для загрузки содержимого запроса на указанный в этом же запросе URI. (метод POST и метод PUT выполняют совершенно разные операции. Метод POST обращается к ресурсу (странице или коду), которая содержит механизмы обработки сообщения метода POST, а вот метод PUT создает какой-то объект по URI, указанному в сообщение с HTTP методом PUT.)

- HTTP метод PUTCH Аналогичен PUT, но применяется к фрагменту ресурса

- HTTP метод DELETE удаляет указанный в URI ресурс.

- HTTP метод CONNECT преобразует существующее соединение в тоннель. (HTTP метод CONNECT используется для преобразования HTTP соединения в прозрачный TCP/IP туннель. Пожалуй, это всё, что можно сказать про HTTP метод CONNECT в контексте рассматриваемого протокола, разве что стоит добавить, что данный метод используется в основном для шифрования соединения (не путайте с кодировкой сообщений).)

- HTTP метод OPTIONS используется для получения параметров текущего HTTP соединения.

- HTTP метод TRACE создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи. (HTTP метод TRACE применяется для диагностики, он позволяет видеть клиенту, что происходит в каждом звене цепочки между компьютером клиента и конечным получателем)

### 63. Жизненный цикл сервлета

- Жизненным циклом сервлета управляет вебконтейнер.
- Методы, управляющие жизненным циклом, должен вызывать только веб-контейнер.

1. Загрузка класса сервлета.
( Проверяются пути: /WEB-INF/classes/, WEB-INF/lib/*.jar, стандартные
классы Java SE и классы веб-контейнера )

2. Создание экземпляра сервлета.

3. Вызов метода init.

4. Обработка HTTP-запросов.

5. Вызов метода destroy.

Для каждого сервлета движок сервлетов создает только одну копию. Вне зависимости от того, сколько запросов будет отправлено сервлету, все запросы будут обрабатываться толькой одной копией сервлета. Объект сервлета создается либо при запуске движка сервлетов, либо когда сервлет получает первый запрос. Затем для каждого запроса запускается поток, который обращается к объекту сервлета.

При работе с сервлетом движок сервлетов вызывает у класса сервлета ряд методов, которые определены в родительском абстрактном классе HttpServlet.

Когда движок сервлетов создает объект сервлета, у сервлета вызывается метод init().

public void init(ServletConfig config) throws ServletException { 
}
Этот метод вызывается только один раз - при создании сервлета. Мы можем переопределить этот метод, чтобы определить в нем некоторую логику инициализации.

Когда к сервлету приходит запрос, движок сервлетов вызывает метод service() сервлета. А этот метод, исходя из типа запроса (GET, POST, PUT и т.д.) решает, какому методу сервлета (doGet, doPost и т.д.) обрабатывать этот запрос.

public void service(HttpServletRequest request, HttpServletResponse response) 
        throws IOException, ServletException{
        }
Этот метод также можно переопределить, однако в этом нет смысла. В реальности для обработки запроса переопределяются методы onGet, onPost и т.д., которые обрабатывают конкретные типы запросов.

Если объект сервлета долгое время не используется (к нему нет никаких запросов), или если происходит завершение работы движка сервлетов, то движок сервлетов выгружает из памяти все созданные экземпляры сервлетов. Однако до выгрузки сервлета из памяти у сервлета вызывается метод destroy().

public void destroy()
При необходимости мы также можем его переопределить, например, определить в нем логику логгирования или что иное. В то же время следует учитывать, что если сервер вдруг упадет по какой-то причине, например, отключится электричество и т.д., тогда данный метод естественно не будет вызван и его логика не сработает.

Поскольку для обработки всех запросов создается один экземпляр сервлета, и все обращения к нему идут в отдельных потоках, то не рекомендуется в классе сервлета объявлять и использовать глобальные переменные, так как они не будут потокобезопасными.

### 64. Написать на JS функцию, которая на странице заменяет все текстовые поля ввода на кнопки

```js
// замена всех текстовых полей ввода на кнопку
function replaceAllTextInputs(){
    Array.from(document.querySelectorAll("input[type=text], textarea"))
        .forEach(input => {
        	var button = document.createElement('button');
    		button.innerHTML = "I am button";
        	input.replaceWith(button);
         });
}
```

### 65. Коды состояния HTTP 

__Код ответа (состояния) HTTP__ показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:

1. Информационные 100 - 199
2. Успешные 200 - 299
3. Перенаправления 300 - 399
4. Клиентские ошибки 400 - 499
5. Серверные ошибки 500 - 599

### 66. Фильтры запросов. Реализация пред и пост обработки запросов

Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут:

- Перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
- Определить содержание запроса прежде, чем сервлет будет инициирован;
- Модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
- Модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ; 
- Перехватывать инициацию сервлета после обращения к сервлету. Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:

```xml
<filter>
    <filter-name>FilterName</filter-name>
    <filter-class>common.FilterConnect</filter-class>
    <init-param>
        <param-name>active</param-name>
        <param-value>true</param-true>
    </init-param>
</filter>
 
<filter-mapping>
    <filter-name>FilterName</filter-name>
    <servlet-name>ServletName</servlet-name>
</filter-mapping>
```
```java

public void init (FilterConfig config) throws ServletException {};

public void destroy () {};

public void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;
```

Пример предобработки:

```java
if (userAuthorized()) {
    chain.doFilter(request, response);  
} else { 
    httpResponse.sendRedirect("login.jsp");
}
```

Пример постобработки Чтобы манипулировать ответами от сервера, прежде чем они будут отправлены обратно клиенту.

### 67. Написать css правило, которое повернёт все картинки в форме с id=sampleForm на 90 градусов по часовой стрелке

```css
#sampleForm img {
transform: rotate(90deg);
}
```

### 68. Структура Html-документа

DOM – это объектное представление исходного HTML-документа, попытка преобразовать его структуру и содержимое в объектную модель, с которой смогли бы работать различные программы.

В ближайшем приближении DOM – это "дерево узлов" (node tree). У него единый корень, который разветвляется на множество дочерних ветвей, каждая из которых может ветвиться сама и заканчивается "листьями". Корень – это элемент html, а ветви – вложенные элементы.

Модификация с помощью JavaScript DOM позволяет не только просматривать содержимое страницы, но и взаимодействовать с ним, изменять. Это не статичное отображение, а живой ресурс.

Например, с помощью JavaScript можно создать дополнительные элементы:

```js
var newParagraph = document.createElement("p"); 
var paragraphContent = document.createTextNode("I'm new!"); 
newParagraph.appendChild(paragraphContent); 
document.body.appendChild(newParagraph);
```

Document метод querySelector() возвращает первый элемент (Element) документа, который соответствует указанному селектору или группе селекторов. Если совпадений не найдено, возвращает значение null.

Основные характеристики объектной модели:

- основана на валидном HTML-коде;
- может быть модифицирована из JavaScript;
- не включает псевдоэлементы, созданные из CSS;
- включает скрытые элементы (display: none).
- Объектная модель документа – очень полезная штука. Благодаря ей JavaScript может взаимодействовать со страницей, изменять ее содержимое, структуру и стили. Именно благодаря DOM вы можете отслеживать клиентские события.

DOM – понятие, специфичное для браузерной среды выполнения кода. Это не JavaScript, а лишь API, которым JavaScript может пользоваться.

### 69. Servlet - особенности, отличия от CGI/ FastCGI

Servlet – в первую очередь это простой Java интерфейс, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.

__Что же такое сервлет ? В двух словах описать работу сервлета можно так:__

На сервер приходит запрос от клиента, запрос содержит внутри себя URL и параметры. Сервер имеет специальный конфигурационный файл, который ему сообщает о том, какой сервлет надо выполнить в случае прихода определенного URL. Сервлет выполняется (там вы можете использовать параметры) и создает HTML-страницу, которая отсылается клиенту. Сервер по сути является контейнером (теперь уже не визуальных компонентов), который загружает сервлеты, выполняет их, вызывая определенные методы и получив от них результат, отправляет его клиенту.

Таким образом сервлет — это Java-класс, который наследуется обычно от класса • HttpServlet и переопределяет часть методов:

- doGet — если мы хотим, чтобы сервлет реагировал на GET запрос.
- doPost — если мы хотим, чтобы сервлет реагировал на POST запрос.
- doPut, doDelete — если мы хотим, чтобы сервлет реагировал на PUT и DELETE запрос (есть и такие в HTTP). Эти методы реализуются крайне редко, т.к. сами команды тоже очень редко встречаются.
- init, destroy — для управления ресурсами в момент создания сервлета и в момент его уничтожения.

Если же необходимо перехватывать все команды, то проще переопределить метод service. Именно этот метод вызывается при приходе запроса от клиента. В HttpServlet происходит разбор запроса и в соответствии с указанной командой вызывается метод doGet, doPost и т.д.

Важно 

- ServletContext живет до тех пор, пока живет веб-приложение. Он является общим для всех запросов во всех сеансах.
- HttpSession живет до тех пор, пока клиент взаимодействует с веб-приложением с одним и тем же экземпляром браузера, а время ожидания сеанса на стороне сервера не истекло. Он является общим для всех запросов в одном сеансе.
- HttpServletRequest и HttpServletResponse живут с момента получения сервлетом запроса HTTP от клиента, пока не будет получен полный ответ (веб-страница). Он не разделяется в других местах.
- Все экземпляры Servlet , Filter и Listener живут до тех пор, пока живет веб-приложение. Они являются общими для всех запросов во всех сеансах.
- Любой attribute , определенный в ServletContext, HttpServletRequest и HttpSession , будет жить до тех пор, пока живет рассматриваемый объект. Сам объект представляет собой "scope" в рамках управления бобами, таких как JSF, CDI, Spring и т.д. Эти фреймворки хранят свои ограниченные бобы как attribute из своей ближайшей совпадающей области.

#### 70. Преимущества и недостатки относительно CGI и FastCGI

Преимущества:

- Выполняются быстрее, чем CGI-сценарии.
- Хорошая масштабируемость.
- Надежность и безопасность (реализованы на JAVA)
- Платформенно-независимы
- Множество инструментов мониторинга и отладки
- Поскольку для каждого запроса существует новый процесс, это означает, что CGI не может агрегировать данные из нескольких запросов в памяти.

Недостатки:

- Слабое разделение уровня представления и бизнес-логики.
- Возможны конфликты при параллельной обработке запрос
ов.

### 71. Написать CSS правило, которое будет обводить все картинки в классе news в рамку при наведении мышю

```css
.news img:hover {
border: 3px solid red;
}
```

### 72. Super Agent 

Библиотека Superagent, как и Axios, подходит для Node.js и для современных браузеров. Она предоставляет разработчику простое и понятное API, с которым удобно работать.

#### 73. Что такое Node.js?
Node.js (или просто Node) — это серверная платформа для работы с JavaScript через движок V8. JavaScript выполняет действие на стороне клиента, а Node — на сервере. С помощью Node можно писать полноценные приложения. Node умеет работать с внешними библиотеками, вызывать команды из кода на JavaScript и выполнять роль веб-сервера.

#### В чём преимущество Node?
C Node проще масштабироваться. При одновременном подключении к серверу тысяч пользователей Node работает асинхронно, то есть ставит приоритеты и распределяет ресурсы грамотнее. Java же, например, выделяет на каждое подключение отдельный поток.

#### Откуда Node вообще взялся?
Node появился в 2009 году благодаря Райану Далу. До этого в серверах царил подход «один поток на каждое соединение», а Дал придумал использовать систему, которая ориентирована на события. То есть реагирует на действие или бездействие и выделяет под это ресурс. Главная цель Node — построение масштабируемых сетевых серверов.

SuperAgent позиционируется разработчиками как легковесная и расширяемая библиотека для работы с AJAX. Для того чтобы выполнить HTTP-запрос средствами Superagent, достаточно вызвать подходящий метод объекта request:

```js
request.post('/api/pet') 
.send({ name: 'Manny', species: 'cat' }) 
.set('X-API-Key', 'foobar') 
.set('Accept', 'application/json') 
.then(res =>{ console.log('I got: ' + JSON.stringify(res.body)); })
.catch(error => { console.log("Something wrong", errror); });
```

#### ▍Сильные стороны
- Поддерживает плагины.
- Поддаётся конфигурированию.
- Имеет приятный интерфейс для выполнения HTTP-запросов. 
- Поддерживает объединение в цепочку нескольких вызовов для выполнения запросов. 
- Работает в среде Node.js и в браузерах. 
- Поддерживает индикацию прогресса для выгрузки и загрузки данных. 
- Поддерживает механизм chunked-transfer encoding.
- Поддерживает коллбэки. 
- Для этой библиотеки разработано множество плагинов.

Плагин - это расширение, которое улучшает возможности приложения, а библиотека - это набор классов и функций, которые помогают разрабатывать программное обеспечение.

#### ▍Слабые стороны
Имеет своеобразное API, не придерживающееся каких-либо стандартов.

### 74. Шаблоны проектирования, архитектурные, для чего нужны, разница

__Шаблон проектирования или паттерн__ — повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста (© Wikipedia).

- Описывает подход к решению типовой задачи.

- Одну и ту же задачу часто можно решить с использованием разных шаблонов.

- Существует много литературы с описанием различных шаблонов проектирования.

#### Зачем нужно

- Позволяют избежать «типовых» ошибок при разработке типовых решений.
- Позволяют кратко описать подход к решению задачи; программистам, знающим шаблоны, проще обмениваться информацией.
- Легче поддерживать код — его поведение более предсказуемо.
- GoF-паттерны Описаны в книге 1994 г. «Design Patterns: Elements of Reusable Object-Oriented Software» («Приёмы объектно-ориентированного проектирования. Паттерны проектирования»).

__Архитектурные шаблоны__

- Более высокий уровень по сравнению с шаблонами проектирования.
- Описывают архитектуру всей системы или приложения.
- Обычно имеют дело не с отдельными классами, а с целыми компонентами или модулями.
- Компоненты и модули могут быть построены с использованием различных шаблонов проектирования.

### 75. Jquery ajax запрос на сервлет, ответ от сервлета - объект json, вывести на страницу firstname, lastname, img_url

```js

var userObj = {
    "userName": "vlad"
}

var userJson = JSON.stringify(userObj);


$.ajax({
    url: url,
    method: "post",
    data: userObj,
    error: function(message) {
        console.log(message);
    },
    success: function(data) {
        console.log(data.firstname);
        console.log(data.lastname);
        console.log(data.img_url);
    }
});

```

### 76. DOM и BOM

__DOM__ - программный интерфейс для HTML и XML документов, описывающий структурированное представление документа и определяющий, как это структура может быть доступна из программ, которые могут изменять ее содержимое.

Согласно DOM документ может быть представлен в виде объектов, с которыми можно производить манипуляци:

1. генерация и добавление узлов
2. получение узлов
3. изменение узлов
4. изменение связей между ними
5. удаление узлов

__BOM__ - объектная модель браузера. Основное предназначение — управление окнами браузера и обеспечение их взаимодействия. BOM специфична для каждого браузера. Может создавать системные диалоги, управлять информацией о параметрах монитора и браузера и т.д.

Обращение к узлам происходит с помощью элементов document (DOM) или window (BOM).

```js
var contentsWindow;
contentsWindow = window.open("http://cs.ifmo.ru","contents");
```
__Возможности BOM:__

- управление фреймами,
- поддержка задержки в исполнении кода изацикливания с задержкой,
- системные диалоги,
- управление адресом открытой страницы,
- управление информацией о браузере,
- управление информацией о параметрах монитора,
- ограниченное управление историей просмотра страниц,
- поддержка работы с HTTP cookie

### 77. Управление сессией. HttpSession.

__Сеанс (сессия)__ – соединение между клиентом и сервером, устанавливаемое на определенное время, за которое клиент может отправить на сервер сколько угодно запросов. Сеанс устанавливается непосредственно между клиентом и Web-сервером. Каждый клиент устанавливает с сервером свой собственный сеанс.

Чтобы открыть новый сеанс, используется метод getSession() интерфейса HttpServletRequest. Метод извлекает из переданного в сервлет запроса объект сессии класса HttpSession, соответствующий данному пользователю.

Чтобы сохранить значения переменной в текущем сеансе, используется метод setAttribute(), прочесть – getAttribute(), удалить – removeAttribute(). Список имен всех переменных, сохраненных в текущем сеансе, можно получить, используя метод Enumeration getAttributeNames().

Есть 3 способа отслеживания сессии: cookies, переопределяемый URL (используется response.encodeURL() для каждой ссылки, который вставляет идентификатор сессии в каждый URL.), cкрытые поля форм.

### 3. Написать JS-функцию, которая запрещает вводить любые символы, кроме цифр и букв латинского алфавита

```js
function fixValue(){                                                                                                                     
        if (this.value.match(/[^a-z0-9]/ig) !== null)                                                                                     
                this.value = '';                                                                                                         
}                                                                                                                                        
                                                                                                                                         
function setValidation(){                                                                                                                
        let inputs = document.querySelectorAll('input[type=text], input[type=email], input[type=password], textarea');                   
        Array.from(inputs).forEach(                                                                                                      
                input => {                                                                                                               
                        input.addEventListener('input', fixValue)                                                                        
                }                                                                                                                        
        );                                                                                                                               
}
```

### 79. CSS : назначение, правила, приоритеты

CSS - формальный язык описания внешнего вида документа с помощью языка разметки.

Каскадные таблицы стилей используются создателями веб-страниц для задания цветов, шрифтов, расположения и других аспектов представления веб-документа. Основной целью разработки CSS являлось разделение содержимого (написанного на HTML или другом языке разметки) и оформления документа (написанного на CSS). Это разделение может увеличить доступность документа, предоставить большую гибкость и возможность управления его представлением, а также уменьшить сложность и повторяемость в структурном содержимом. Кроме того, CSS позволяет представлять один и тот же документ в различных стилях или методах вывода, таких как экранное представление, печать, чтение голосом (специальным голосовым браузером или программой чтения с экрана), или при выводе устройствами, использующими шрифт Брайля.

Селекторы - элемент, к которому применяется правило.

Основные виды селекторов:
- \* - любые элементы
- div элементы с тегом div
- \#id - элемент по id
- .class - элементы с классом class
- [name="value"] - селекторы по атрибуту
- :visited - псевдоклассы
- div p - элементы p, являющиеся потомками div
- div > p – только непосредственные потомки
- div ~ p – правые соседи: все p на том же уровне вложенности, которые идут после div
- div + p – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div

Структура - правила, селекторы

- Селектор (Selector). Селектор — это элемент, к которому будут применяться назначаемые стили. Это может быть тег, класс или идентификатор объекта гипертекстового документа.
- Свойство (Property). Свойство определяет одну или несколько характеристик селектора. Свойства задают формат отображения селектора: отступы, шрифты, выравнивание, размеры и т.д.
- Значение (Value). Значения — это фактические числовые или строковые константы, определяющие свойство селектора.
- Описание (Declaration). Совокупность свойств и их значений.
- Правило (Rule). Полное описание стиля (селектор + описание).

Таким образом, таблица стилей — это набор правил, задающих значения свойств селекторов, перечисленных в этой таблице.

Приоритеты правил.

- !important позволяет повысить приоритет стиля
- Самый высокий приоритет имеет атрибут style.
- Второе по приоритету - присутствие ID в селекторе.
- Все атрибуты (включая class и псевдоклассы)
- Самый низкий - селекторы с именами элементов и псевдоэлементами.

### 80. MVC : назначение, элементы, примеры реализации

__Model-View-Controller__ — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.

- Модель (Model) предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность (не зависит от представления (не знает как данные визуализировать) и контроллера (не имеет точек взаимодействия с пользователем).
- Представление (View) отвечает за получение необходимых данных из модели и отправляет их пользователю (не обрабатывает введённые данные пользователя).
- Контроллер (Controller) обеспечивает «связи» между пользователем и системой. Контролирует и направляет данные от пользователя к системе и наоборот.

Пример: JSF

### 3. Реализовать функцию на JavaScript, которая будет закрывать текущее окно, если в нем открыт https://www.google.ru

```js
function close(){
    let url = window.location.href;
	let isGoogle = url.match(/https:\/\/www.google.ru/ig);
    if (isGoogle)
    	window.close();     
}
```

### 80. AJAX и DHTML - описание, сходства и различия

__Asynchronous Javascript and XML__ - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером и динамическом обновлением контента.

Реализация AJAX с подощью JQuery:

```js
$.ajax({
  type: "POST",
  url: "some.php",      // обращение к some.php
  data: {name: 'John', location: 'Boston'},   //с какими-то параметрами
  success: function(msg){
    alert( "Data Saved: " + msg );  // получный результат выводится в alert
  }
}); 
```

__DHTML__ - технология создания интерактивных динамических веб-страниц с использованием стандартных средств: html, css, DOM и js. Построен на DOM.

```html
<html>
<head>
    ...
</head>
<body>
<H2>Всплывание события</H2>
<b>Для получения информации можно нажать на изображение или текст</b><br>
<a href="kuda.htm"><img src="be.gif" align="left">Кто это?</a> 
</body>
</html>
```


AJAX позволяет не перезагружать открытую пользователем страницу целиком при внесении в неё каких-либо небольших изменений сервером, а ограничиться загрузкой только небольшого фрагмента.

AJAX-страницы для придания им большей интерактивности реализуются с использованием DHTML, однако DHTML-страницы совершенно не обязательно используют AJAX.

DHTM это различные выпадающие меню на сайтах, разворачивающиеся по клику пользователя панели и древовидные списки, и т. п. Технически Dynamic HTML реализуется с помощью JavaScript, CSS и DOM.

### 81. Какие проблемы возникают при параллельной обработке запросов в JSP, как этого можно избежать?

Согласно спецификации сервлетов, web контейнер по умолчанию позволяет одному и тому же экземпляру сервлета параллельно обрабатывать запросы сразу от нескольких клиентов. При этом каждому из запросов выделяется отдельный трэд.

За это отвечает директива isThreadSafe, дефолтное значение которого - true. Для того, чтобы запретить параллельную обработку запросов необходима директива isThreadSafe со значением false.

```jsp
<%@ page isThreadSafe=false %>
```

### 82. Написать js функцию, которая заменяет содержимое \<div> с именем класса “nyan” на изображение по ссылке: http://www.example.com/nyancat.gif 

```js
function replaceWithNyan(){                                                       
        let img = document.createElement('img');                                  
        img.src = 'http://www.example.com/nyancat.gif';                           
        Array.from(document.querySelectorAll('.nyan')).forEach(                   
                div => {                                                          
                        div.innerHTML = '';                                       
                        div.appendChild(img);                                     
                }                                                                 
        );                                                                        
}
```

### 83. Rest и RPC

REST - архитектурный стиль взаимодействия компонентов приложения в сети.

В приложениях, которые поддерживают использование различных клиентов (коды клиентов мб на разных яхыках) пригодится REST. Т.к. Клиенты очень разные, но нам нужно, чтобы они понимали друг друга.

REST - набор правил: как программисту организовать написание кода серверного веб-приложения, чтобы все системы легко обменивались данными и прилржение могло было масштабироваться

Требования к архитекруте REST:

- Модель клиент-сервер
- Отсутствие состояния (в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится)
- Кэширование (клиенты могут выполнять кэширование ответов с сервера, ответы должны иметь обозначения как кэшируемые или нет для избежания получения неверных последующих ответов)
- Единообразие интерфейса
- Слои (сервера, какие-то промежуточные сервера и узлы)

RPC - удалённый вызов процедур. 

- Нацелен на передачу управления и данных через сеть (т.е. используются разные машины) -> будет полезен в типах приложений, в кот. присутсвуют удаленные компоненты (разные машины), которые необходимо связать интерактивно

Что-то вроде совокупности клиент-серверного приложения с сериализацей объектов.

### 84. RequestDispatcher

#### Диспетчеризация запросов в сервлетах

- Сервлеты могут делегировать обработку запросов другим ресурсам (сервлетам, JSP и HTML-страницам).
- Диспетчеризация осуществляется с помощью реализаций интерфейса javax.servlet.RequestDispatcher.
- Два способа получения RequestDispatcher — через ServletRequest (абсолютный или относительный URL) (RequestDispatcher view = request.getRequestDispatcher(“result.jsp”);) и ServletContext (только абсолютный URL). (RequestDispatcher reqDispObj = getServletContext().getRequestDispatcher("/ContextRoot/home.jsp");)
- Два способа делегирования обработки запроса — forward и include (include используется чтобы вставить вывод другого сервлета в текущий. forward позволяет провести предварительную обработку запроса и потом полностью передать управление другому сервлету)

#### Отличие include от forward:

Assume you have two pages, pageA, and pageB. In pageA you wrote the include tag. In this case the control was in pageA til you called the include tag. At this point the full control goes to pageB. When It's done, control is returned to pageA starting from the next point of coding after the include tag and continuing to the rest of pageA.

Well, to get things much clearer, let's say that we have the same pages, pageA and pageB, but this time we will use the forward tag in pageA, not the include tag. Again, the control will begin in pageA till we call the forward tag in pageA, at this point, control is transfered to pageB, just like the include tag. But the difference is what happens when pageB completes. In case of the forward tag, control doesn't go back to pageA again.

#### Отличие redirect от forward:

response.sendRedirect(""); используется для перенаправления ресурсов на разные серверы или домены. Эта передача задачи управления делегируется браузеру контейнером. То есть, перенаправление отправляет заголовок обратно в браузер/клиент. Этот заголовок содержит URL-адрес ресурса, который будет перенаправлен браузером. Затем браузер инициирует новый запрос к указанному URL-адресу.

request.getRequestDispathcer("login.jsp").forward(request, response); используется для пересылки ресурсов, доступных на сервере, с которых выполняется вызов. Эта передача управления осуществляется контейнером внутри, а браузер/клиент не задействован.

мы должны использовать forward() при доступе к ресурсам в том же приложении, потому что это быстрее, чем метод sendRedirect(), который требовал дополнительного сетевого вызова.

### 85. Правило css, меняющее цвет фона на желтый, если ссылка посещена и не лежит в классе “news” 

```css
/* Правило css, меняющее цвет фона на желтый, если ссылка посещена и не лежит в классе "news": */
*:not(.news)>a:visited {
	color: yellow;
}


```


### 86. javascript, особенности, что для чего и тд

__JavaScript__ является объектно-ориентированным языком.

#### Основные архитектурные черты:

- динамическая типизация; (автоматическое приведение типов)
- слабая типизация;
- автоматическое управление памятью; (автоматическая сборка мусора)
- прототипное программирование; (отсутствует понятие класса, а наследование производится путём клонирования существующего экземпляра объекта — прототипа.)
- функции как объекты первого класса. (т.е. мб сохранены в переменную, переданны в функцию как аргумент, созданы во время выполнения программы и т.п.)

### 87. JSP actions

JSP actions могут воздействовать на стандартный поток вывода, использовать, модифицировать и создавать объекты используя конструкции XML для управления сервлетом.

JSP - XML-элементы, позволяющие управлять поведением сервлета.

```jsp
<jsp:action_name attribute = "value" />
```
- jsp:include - включает файл при запросе
- jsp:useBean - Добавляет на страницу экземпляр Java Bean с заданным контекстом.
- jsp:setProperty - Получение и установка свойств Java Bean
- jsp:forward - пересылает на другую страницу
- jsp:declaration – объявление, аналогично <%! … %>
- jsp:scriptlet – скриптлет, аналогично <% … %>
- jsp:expression – скриптлет, аналогично <%= … %>
- jsp:text – вывод текста
...

### 88. PHP скрипт, который достаёт из get запроса имя и фамилию и приветствует пользователя, выводя html страницу

```php
<?php                                         
$name = $_GET['name'];  
$lastname = $_GET['lastname'];                      
echo 'Hello ' . ($name?$name:'noname') . ' ' . ($lastname?$lastname:'nolastname') . '!'; 
?> 

```

### 89. Cтруктура протокола http, характеристики

HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser).

Браузер (клиент) отправляет серверу HTTP запросы, а сервер отправляет клиенту HTTP ответы. Эти запросы и ответы оформляются по определенным правилам. Есть, что-то вроде синтаксиса, как и в какой последовательности, должно быть написано. Должна быть строго определенная структура.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. 

Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.

1. Строка запроса (Request Line) - указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
2. Зголовки (Message Headers) - описывают тело сообщений, передают различные параметры и др. сведения и информацию.
3. Пустая строка (разделитель)

4. тело сообщения (Entity Body) – сами данные, которые передаются в запросе. необязательный параметр. 
Когда мы получаем ответный запрос от сервера, тело сообщения, чаще всего представляет собой содержимое веб-страницы. Но, при запросах к серверу, оно тоже может иногда присутствовать, например, когда мы передаем данные, которые заполнили в форме обратной связи на сервер.

#### Характеристики

- Протокол прикладного уровня
- Основа — технология «клиент-сервер»
- Может быть использован в качестве «транспорта» для других протоколов прикладного уровня
- Основной объект манипуляции — ресурс, на который указывает URI
- Обмен сообщениями идёт по схеме «запрос-ответ»
- Stateless-протокол (один запрос — одно соединение). Для реализации сессий используются cookies.

### 90. Жизненный цикл jsp

1. Translation – Трансляция jsp в код сервлета
2. Compilation – Компиляция сервлета
3. Class Loading – Загрузка класса сервлета
4. Instantiation – Создание экземпляра сервлета 
5. Initialization – Вызов метода jspInit()
6. Request Processing – длительный жизненный цикл обработки запросов клиента JSP страницей. Обработка является многопоточной и аналогична сервлетам — для каждого запроса создается новая нить, создаются объекты ServletRequest и ServletResponse и происходит внедрение сервис методов JSP.
7. Destroy – последняя фаза жизненного цикла JSP на которой JSP класс удаляется из памяти. Обычно это происходит при выключении сервера или андеплое приложения.

### 91. Написать на php класс

```php
<?php
// сделать класс на php
class User{
    private $userName;
    private $age;
 
    function __constuctor($userName, $age){
        $this->userName = $userName;
        $this->age = $age;
    }
 
    function whois(){
        return 'Name: ' . $this->userName . '\nAge: ' . $this->age;
    }
}
?>
``` 

### 92. Преимущества и недостатки ajax

__Asynchronous Javascript and XML__ - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером.

Пользователь что-то делает -> скрипт определяет с чем там надо работать -> браузер отправляет запрос на сервер -> сервер возвращает только то, от чего ожидаются изменения -> скрипт вносит изменения обратно (без перезагрузки страницы).

#### Преимущества 

- Экономия трафика пользователя (вместо обновления всей страницы, загружается ее небольшая изменившаяся часть);
- Снижение нагрузки на сервер. К примеру, на странице личных сообщений форума при выделении пользователем прочитанных писем сервер вносит изменения в БД и отправляет скрипту клиента ответ о выполнении операции без повторного создания страницы и ее передачи;
- Ускорение реагирования интерфейса на команды пользователя.
      
#### Недостатки 

- Не всегда возможна интеграция со стандартным набором инструментов браузера. Так как интернет-обозреватели не регистрируют в истории переходы по страницам, нельзя воспользоваться кнопкой «Назад». В некоторых случаях нет возможности добавить в закладки нужный материал;
- Контент, загружаемый динамически, не доступен поисковым системам, поэтому необходимо обеспечить альтернативный доступ к содержимому ресурса;
- Неправильный учет статистики перемещения пользователя по сайту
- Усложнение проекта;
- Требуется включенный JavaScript в браузере.

### 93. Директива page: назначение, особенности, атрибуты

#### Назначение
Позволяет задавать параметры, используемые контейнером при управлении жизненным циклом страницы.

#### Особенности
- Обычно расположена в начале страницы.
- На одной странице может быть задано несколько директив page с разными указаниями контейнеру.
- Синтаксис:
<%@ page attribute="value" %>

#### Атрибуты

- buffer -  Задаёт параметры буферизации и размер буфера для потока вывода сервлета.
- autoFlush - Указывает, автоматически ли выгружается содержимое буфера при его переполнении.
- contentType - Позволяет задать Content Type и кодировку страницы.
- errorPage - Позволяет задать страницу, на которую будет осуществлено перенаправление при возникновении Runtime Exception.
- isErrorPage - Указывает, является ли текущая страница Error Page.
- extends -  Позволяет задать имя родительского класса, от которого будет наследоваться сервлет.
- import -  Импорт классов или пакетов.
- info - Задаёт строку, которую будет возвращать метод getServletInfo().
- isThreadSafe - Если isThreadSafe == false, то контейнер блокирует параллельную обработку нескольких запросов страницей.
- language - Позволяет задать язык программирования, на котором пишутся скриптовые элементы на странице (по умолчанию — Java).
- session - Указывает контейнеру, создавать ли ему предопределённую переменную session.
- isELIgnored - Указывает, вычисляются EL-выражения контейнером, или нет.
- isScriptingEnabled Указывает, обрабатываются ли скриптовые элементы.
    
### 94. Написать конфигурацию сервлета (org.xxx.MyServlet) с помощью аннотации. Сервлет должен принимать все запросы от файлов .html .xhtml

```java
@WebServlet(urlPatterns = {"*.xhtml", "*.html"})
public class MyServlet {
}
```

### 95. Cтруктура http запроса

HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser).

Браузер (клиент) отправляет серверу HTTP запросы, а сервер отправляет клиенту HTTP ответы. Эти запросы и ответы оформляются по определенным правилам. Есть, что-то вроде синтаксиса, как и в какой последовательности, должно быть написано. Должна быть строго определенная структура.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. 

Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.

1. Строка запроса (Request Line) - указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
2. Зголовки (Message Headers) - описывают тело сообщений, передают различные параметры и др. сведения и информацию.
3. Пустая строка (разделитель)

4. тело сообщения (Entity Body) – сами данные, которые передаются в запросе. необязательный параметр. 
Когда мы получаем ответный запрос от сервера, тело сообщения, чаще всего представляет собой содержимое веб-страницы. Но, при запросах к серверу, оно тоже может иногда присутствовать, например, когда мы передаем данные, которые заполнили в форме обратной связи на сервер.


### 96. Типы данных php

PHP - яп с динамической типизацией. Преобразования меджду скалярными типами происходят неявно.

Скалярные типы: integer, float, double, boolean, string.

Нескалярные: array, object, resource, null

Псевдотипы: mixed (любой тип), number, callback (string или анонимная фунуция), void.

### 97. Сервлет перенаправляющий все запросы на страницу google 

```java
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import java.io.IOException;
 
// Написать сервлет, который будет возвращать все запросы на переадресацию на сайт google.com
 
class ToGoogleServlet extends HttpServlet{
        public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{
                response.sendRedirect("http://google.com");
        }
}

```

### 98. Php, особенности и запуск

__PHP__ (PHP: Hypertext Preprocessor) — скриптовый язык, часто используемый для написания вебприложений.

- Конфигурационные параметры хранятся в файле php.ini.
- Можно подключать дополнительные модули, расширяющие возможности языка (например, добавляющие поддержку взаимодействия с СУБД).
 
Способы использования интерпретатора PHP:
- С помощью SAPI / ISAPI (например, mod_php для
Apache).
- С помощью CGI / FastCGI.
- Через интерфейс командной строки.


### 99. Long Polling vs WebSockets

__Long Polling__ — это технология, которая позволяет получать данные о новых событиях с помощью «длинных запросов». Сервер получает запрос, но отправляет ответ на него не сразу, а лишь тогда, когда произойдет какое-либо событие (например, придёт новое сообщение), либо истечет заданное время ожидания.

- Клиент запрашивает страницу у сервера, используя обычный http
- Запрошенная страница выполняет JavaScript, который запрашивает файл от сервера.
- Сервер НЕ реагирует на запрошенную информацию и ждет, пока не появится новой информации
- Когда появляется новая информация, сервер отсылает ее клиенту
-  лиент получает новую информацию и сразу отсылает другой запрос серверу, запуская процесс ожидания на нем снова.

__WebSocket__ — протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и вебсервером в режиме реального времени.

- Клиент запрашивает страницу у сервера, используя обычный http
- Открывается соединение с сервером
- Сервер и клиент могут посылать друг другу сообщения

__Обмен данными ведётся через отдельное TCPсоединение.__

#### Преимущества WebSocket:
- Поддерживается всеми современными браузерами (даже IE).
- Не требуется рвать соединение при доставки сообщения.
- (Следствие второго) можно отправлять больше сообщений пользователю в секунду
- Можно самостоятельно отправлять серверу сообщения по WebSockets, то есть, общение двустороннее.

### 100. Написать JSP страницу, которая будет возвращать количество сессий, обратившихся к ней за последние 60 секунд и формировать вывод в HTML

```java
public class var6 extends HttpServlet {
 Date d;
 ArrayList<HttpSession> s = new
 ArrayList<HttpSession>();
 Predicate<HttpSession> isOld = new Predicate<HttpSession>() {
  @Override
  public boolean test(HttpSession t) {
   try {
      return ((d.getTime()-t.getLastAccessedTime())) > 6000;
   }
  catch(IllegalStateException e) {
  return true;
  }}
 };

protected void srvice(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
 response.setContentType("text/html;charset=UTF8");
 int i;
 d = new Date();
 s.removeIf(isOld);
 if((i = s.indexOf(request.getSession())) > -1)
 s.remove(i);
 s.add(request.getSession());
 try (PrintWriter out = response.getWriter()) {
 out.println("<!DOCTYPE html>");
 out.println("<html>");
 out.println("<head>");
 out.println("<title>Servlet var6</title>");
 out.println("</head>");
 out.println("<body>");
 out.println("<b>Count Sessions:" +
 Integer.toString(s.size()) + "</b>");
 out.println("</body>");
 out.println("</html>");
 } 
 }}
```

### 101. Элементы JSP

2 варианта синтаксиса — на базе HTML и XML.

- Обозначаются тегами <% %> (HTML-вариант):
<html>
<%-- scripting element --%>
</html>
        
- Существует 5 типов JSP-элементов:
- Комментарий — <%-- Comment --%>;

  Поддерживаются 3 типа комментариев:
  * HTML-комментарии:
  <!-ч- This is an HTML comment.
  It will show up in the response. -ч->
  * JSP-комментарии:
  <%-- This is a JSP comment.
  It will only be seen in the JSP code.
  It will not show up in either the servlet code
  or the response.
  --%> 
  * Java-комментарии:
  <%
  /* This is a Java comment.
  It will show up in the servlet code.
  It will not show up in the response. */
  %>

- Директива — <%@ directive %>;

  Управляют процессом трансляции страницы в сервлет.
    * Директива страницы (Директива страницы используется для предоставления инструкций контейнеру. Эти инструкции относятся к текущей странице JSP.)
    <%@ page session=”false” %>
    <%@ page import="java.util.ArrayList" %>
    <%@ page import="helpers.Point" %>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    (buffer, contentType, language, isThreadSafe)
    * Директива включения (Директива include используется для включения файла на этапе перевода. Эта директива указывает контейнеру объединять содержимое других       внешних файлов с текущим JSP на этапе трансляции.)
    <%@ include file=”incl/copyright.html” %> 
    Эквивалент на XML:<jsp:directive.include file="url"\>.
    URL должен быть относительным . Для подключения файла в процессе запроса а не в ходе трансляции используйте действие jsp:include.
       1) Директива include :
       <%@ include file="header.html" %>
       Статический : добавляет содержимое из значения атрибута файла на текущую страницу во время перевода . Директива изначально предназначалась для статических          шаблонов макета, таких как заголовки HTML.

      2) <jsp:include> Стандартное действие :
      <jsp:include page="header.jsp" />
      Динамический : добавляет содержимое из значения атрибута страницы на текущую страницу во время запроса . Был предназначен больше для динамического контента,       поступающего из JSP.

      3) <c:import>Тег JSTL:
      <c:import url=”http://www.example.com/foo/bar.html” />
      Динамический : добавляет содержимое из значения атрибута URL на текущую страницу во время запроса . Он работает примерно так же <jsp:include>, но он более         мощный и гибкий: в отличие от двух других включений, <c:import> URL-адрес может быть извне веб-контейнера !
    
    * Директива taglib ( Библиотеки тегов-это фрагменты кода Java, которые могут использоваться в JSP, но которые соответствуют определенному API и которые             выглядят как теги HTML в JSP. Файл описания библиотеки тегов (TLD) описывает имена этих тегов, какие атрибуты они могут иметь и какие классы Java реализуют их)
    
    Директива taglib имеет следующий синтаксис: 
    <%@ taglib uri="URI включаемой библиотеки тегов" prefix="имяПрефикса" %>
    Префикс "имяПрефикса" используется при обращении к библиотеке. Пример использования библиотеки тегов mytags:
    <%@ taglib uri="http://www.taglib/mytags" prefix="customs" %>
    . . .
    <customs:myTag>
    
- Объявление — <%! decl %>;(declarations не производят никакого вывода в стандартный выходной поток out. Переменные и методы, декларированные в объявлениях, инициализируются и становятся доступными для скриптлетов и других объявлений в момент инициализации страницы JSP.)

    Позволяют объявлять поля и методы:
    * Синтаксис:
    ```jsp
    <%! JavaClassDeclaration %>
    ```
    * Примеры:
    ```jsp
    <%!
    public static final String DEFAULT_NAME = “World”;
    %>
    <%!
    public String getName(HttpServletRequest request) {
    return request.getParameter(“name”);
    }
    %>
    <%! int counter = 0; %>
    ```
    
- Скриптлет — <% code %>; (Позволяют задать Java-код, который будет выполняться при обработке запросов (при вызове метода _jspService).)
    * Синтаксис:
    ```jsp
    <% JavaCode %>
    ```
    * Примеры:
    ```jsp
    <% int i = 0; %>
    <% if ( i > 10 ) %>
    I am a big number
    <% } else { %>
    I am a small number
    <% } %>
    ```

- Выражение — <%= expr %>. (Позволяют вывести результат вычисления выражения.)
    * Синтаксис:
    ```jsp
    <%= JavaExpression %>
    ```
    * Примеры:
    ```
     <B>Ten is <%= (2 * 5) %></B>
     Thank you, <I><%= name %></I>, for registering for the soccer league.
     The current day and time is: <%= new java.util.Date() %>
     ```

### 102. CGI - обработка запроса, преимущества и недостатки

__CGI__ (Common Gateway Interface — общий интерфейс шлюза) — стандарт интерфейса, используемого для связи внешней программы с веб-сервером. Программу, которая работает по такому интерфейсу совместно с веб-сервером, принято называть шлюзом (оно же скрипт или CGI-программа). По сути позволяет использовать консоль ввода и вывода для взаимодействия с клиентом.

__Обобщенный алгоритм работы через CGI можно представить в следующем виде:__

- Клиент запрашивает CGI-приложение по его URI.
- Веб-сервер принимает запрос и устанавливает переменные окружения, через них приложению передаются данные и служебная информация.
- Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
- CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
- Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.
- Веб-сервер передает результаты запроса клиенту.

#### Преимущества CGI
- Процесс CGI скрипта не зависит от Веб-сервера и, в случае падения, никак не отразится на работе последнего
- Может быть написан на любом языке программирования
- Поддерживается большинством Веб-серверов
#### Недостатки
- Самым большим недостатком этой технологии являются повышенные требования к производительности веб-сервера. Дело в том, что каждое обращение к CGI-приложению вызывает порождение нового процесса, со всеми вытекающими отсюда накладными расходами. Если же приложение написано с ошибками, то возможна ситуация, когда оно, например, зациклится. Браузер прервет соединение по истечении тайм-аута, но на серверной стороне процесс будет продолжаться, пока администратор не снимет его принудительно.

### 103. Написать сервлет, который принимает из http запроса параметр name и выводит его. Если параметр не обнаружен то вывести Anonymous user 

```java
import java.io.PrintWriter;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServleResponse;
 
 
class HelloServlet extends HttpServlet{
        public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{
            response.setContentType("text/html; charset=UTF-8");
 
                String name = request.getParameter("name");
                PrintWriter out = response.getWriter();
 
                name = name==null?"Anonymous user":name;
                out.println("<h1>Hello " + name + "</h1>");
                out.close();
        }
}
```

### 104. FastCGI. Плюсы, минусы, отличия от CGI

Дальнейшее развитие технологии CGI, является более производительным и безопасным, снимает множество ограничений CGI-программ.

CGI — устаревшая технология, позволяющая взаимодействовать веб-серверу с сервером приложений. Для каждого запроса запускается процесс с интерпретатором PHP, после возвращения ответа он завершается. Поскольку это очень неэффективно, был создан FastCGI, в котором процесс интерпретатора не завершается, а используется для последующих запросов.

#### Особенности технлогии
FastCGI программа работает следующим образом: программа единожды загружается в память в качестве демона (независимо от HTTP-сервера), а затем входит в цикл обработки запросов от HTTP-сервера. Один и тот же процесс обрабатывает несколько различных запросов один за другим, что отличается от работы в CGI-режиме, когда на каждый запрос создается отдельный процесс, "умирающий" после окончания обработки.

#### Недостатки
Написание FastCGI программ-демонов сложнее чем CGI, нужны дополнительные библиотеки, зависящие от языка.


### 105. Суперглобальные массивы в PHP (SuperGlobal massive)

Есть предопределенные (не надо явно указывать global $var) массивы (и переменные), которые доступны в любом месте скрипта.

- $GLOBALS : ссылки на все переменные глобальной области видимости
- $_SERVER : заголовки, пути и местоположения скриптов.
- $_GET : переменные GET-запроса
- $_POST : переменные POST-запроса
- $_FILES : переменные файлов, загруженных по HTTP
- $_COOKIE : переданные скрипту через HTTP Cookies.
- $_SESSION : переменные сессии
- $_REQUEST : по умолчанию содержит данные переменных $_GET, $_POST и $_COOKIE
- $_ENV : переменные окружения

### 106. Страница JSP, проверяющая есть ли /какой-то параметр/ в запросе и если нету - выводящая сообщение об ошибке 

```jsp
<%-- Страница JSP, проверяющая есть ли /какой-то параметр/ в запросе и если нету - выводящая сообщение об ошибке  --%>
 
<%@ page contentType="text/html; charset=UTF-8" language="java"%>
<%= request.getParameter("parameterName")==null?"400 - your did not set parameter":request.getParameter("parameterName")  %>

``` 
### 107. ООП в PHP

PHP поддерживает все три основных механизма ООП — инкапсуляцию, полиморфизм подтипов и наследование (с помощью extend). Поддерживаются интерфейсы (с помощью implements). Есть абстрактные и final методы и классы. Множественное наследование не поддерживается, но класс может реализовывть несколько интерфейсов или с помощью механизма особенностей (trait), который имеет средства для разрешения конфликтов.

Методы: __construct() -- конструктор __destruct() -- для деинициализации объекта __get(), __set() __sleep(), __wakeup() __clone()


### 108. Предопределенные переменные JSP

В процессе трансляции контейнер добавляет в метод _jspService ряд объектов, которые можно использовать в скриптлетах и выражениях:

- request : HttpServletRequest -- позволяет обращаться к параметрам запроса (через метод getParameter), типу запроса (GET, POST, HEAD) и входящим HTTP заголовкам (cookies, Referer)
- response : HttpServletResponse
- out : PrintWriter -- для отправки вывода клиенту
- session : HttpSession
- application : ServletContext
- config : ServletConfig -- для текущей страницы
- page : синоним this
- pageContext
- exception: java.lang.Throwable ( используется только на страницахперенаправлениях с информацией об ошибках (Error Pages).)


### 109. Код фильтра запросов, запрещающий доступ к приложению неавторизированным пользователям(у неавт пол в запросе отсутствует заголовок x-application-user)

```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
 
// Код фильтра запросов, запрещающий доступ к приложению неавторизированным
// пользователям(у неавт пол в запросе отсутствует заголовок x-application-user)
 
class AuthFilter extends ServletFilter{
        public void init(FilterConfig config){}
 
        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException{
                String auth = request.getHeader("x-application-user");
                if (auth == null || auth.equals("")){
                        PrintWriter out = response.getWriter();
                        response.setContentType("text/html; charset=UTF-8");
                        out.println("WTF?! You are not authorized");
                }else{
                        chain.doFilter(request, response);
                }
 
        }
 
        public void destroy(){}
}
``` 

### 110. Конфигурация PHP-интеррпретатора, способы интеграции PHP-интеррпретатора с веб-сервером

__PHP__ (PHP: Hypertext Preprocessor) — скриптовый язык, часто используемый для написания вебприложений.

- Конфигурационные параметры хранятся в файле php.ini.
- Можно подключать дополнительные модули, расширяющие возможности языка (например, добавляющие поддержку взаимодействия с СУБД).
 
Способы использования интерпретатора PHP:
- С помощью SAPI / ISAPI (например, mod_php для
Apache).
- С помощью CGI / FastCGI.
- Через интерфейс командной строки.


### 111. ServletContext - особенности, для чего нужен

ServletContext живет до тех пор, пока живет веб-приложение. Он является общим для всех запросов во всех сеансах.

### 112. Код jsp-страницы показывающий содержимое корзины юзера. Содержимое корзины - коллекциия объектов класса ShoppingItem который содержит имя, стоимость и количество заказанного товара - хранится в отдельном managed bean. 

```jsp
<%@ import="my.package.ShoppingItem" %>
<%@ import="java.util.Collection" %>
<%@ contentType="text/html;charset=UTF-8" language="java"%>
<jsp:useBean id="managed" class="my.package.ManagedBean" scope="session">
<html>
<head>
        <meta charset="utf-8">
</head>
<body>
<table>
        <tr>
                <th>name</th>
                <th>price</th>
                <th>count</th>
        </tr>
<%
        Collection<ShoppingItem> basket = mananged.getBasket();
        for (ShoppingItem position: basket){%>
                <tr>
                        <td><%= position.getName() %></td>
                        <td><%= position.getPrice() %></td>
                        <td><%= position.getCount() %></td>
                </tr>
        <%}%>
</table>
</body>
```

## 113. HTML формы

Форма предназначена для обмена данными между пользователем и сервером.

Задается с помощью тега и могут содержать в себе атрибуты: action, содержищий URI обработчика формы (обязательный атрибут), method (по умолчанию, GET), enctype (тип кодирования), accept (MIME-типы для загрузки файлов), name, onsubmit/onreset (обработчик события submit/reset для скриптов), accept-character.

Виды полей:

- Кнопка . Типы кнопок , , , .
- Checkbox.
- Radio.
- Select.
- Text и многострочный textarea.
- Password.
- Hidden (скрытое поле).
- File.


## 114. конфигурация сервлетов. файл web.xml

Java веб-приложения используют файл дескриптора развертывания web.xml для определения какие URL будут передаваться определенному сервлету, какие URL требуют аутентификации. Дескриптор развертывания веб-приложений описывает классы, ресурсы и конфигурацию приложения, а так же как сервер будет использовать их для выполнения веб-запросов.

```xml
 <servlet>
        <servlet-name>redteam</servlet-name>
        <servlet-class>mysite.server.TeamServlet</servlet-class>
        <init-param>
            <param-name>teamColor</param-name>
            <param-value>red</param-value>
        </init-param>
    </servlet>
```
   
Oпределяет соответствие между путями URL и сервлетами

```xml
 <servlet-mapping>
        <servlet-name>redteam</servlet-name>
        <url-pattern>/red/*</url-pattern>
 </servlet-mapping>
```


## 115. написать css правило, которое при клике на ссылку добавляет ей подчеркивание, всем кроме ссылок в теге h1 (Возможный ответ)

```css
/* Написать css правило, которое при клике на ссылку добавляет ей подчеркивание, всем кроме ссылок в теге h1 */
*:not(h1)>a:active {
	text-decoration: underline;
}
```
### 116. Структура JSF

- JSP или XHTML-страницы, содержащие компоненты GUI. 

Странички, на котрых физически находится разметка. 
То, что мы скомпоновали в виде View. JSP для старых версий, да и сейчас можно, но зачем? Лучше Facelets шаблоны.
На этих самых JSP или XHTML у нас расположены компоненты (раскиданы, иерархически вложены друг в друга и так далее)
XHTML = XML + HTML

- Библиотеки тегов.

Те самые библиотеки, внутри которых лежат доступные нам компоненты. Есть стандартные библиотеки, входящие в комплект поставки любой реализации JSF, а есть различные библиотеки компонентов (дополнительные) IceFaces, PrimeFaces и т.д., которые можно подключить, чтобы увеличить набор доступных тегов (ну и возможности)

Набор тегов = namespace 
Префикс может быть любым

- Управляемые бины.

Ими управляет веб-контейнер через JSF Runtime. 

Класс (приватные поля, публичные геттеры, сеттеры) , который хранит в себе состояние JSF приложения 

свойство = поле + геттер/сеттер

Управляемые бины – классы, содержащие параметры и методы для обработки данных с компонентов. Должны иметь методы get и set/ Используются для обработки UI и валидации данных. Жихненным цикллом управляет JSF Runtime Env. Доступ из JSP-страниц осуществляется с помощью языка выражений (EL). Конфигурация задается либо в faces-config.xml, либо с помощью аннотаций.

- Дополнительные объекты (компоненты,
конвертеры и валидаторы).

Компоненты - кубики, которые едины в двух лицах: с одной стороны, кусочек html (кнопочка, input), а с другой, java код, который занимается обработкой всего этого дела на серверной стороне. Компоненты могут быть простые (input, button), а могут быть сложными (primefaces компонент google карт ?). Все компоненты реализуют базовый интерфейс UIComponent. Можно создаваь собственные компоненты (но это сложнее, чем в React). На странице компоненты объедиены в древовидную структуру - представление.
Это иерархическое предствление, есть корневой элемент - UIViewRoot 

- Дополнительные теги.

PrimeFaces/RichFaces/IceFaces являются компонентами/JSF-библиотеками, которые вы можете использовать поверх JSF

RichFaces: это библиотека компонентов с поддержкой Ajax с открытым исходным кодом для JavaServer Faces

ICEfaces: open-source, Java JSF расширение и богатые компоненты, Ajax без JavaScript

PrimeFaces: Структура Ajax с компонентами JSF

- Дескриптор развёртывания — web.xml.

JSF фактически в плане реализации это обычное Java EE-шное приложение. JSF - Application Java EE, которая представляет собой надстройку над Java EE в виде Runtime для JSF компонентов.

Для JSF в силу того, что это обычное веб-приложение на базе сервлетов, применима схема с дескриптором развертывания. Он использует обычный Java EE-шный дескриптор развертывания web.xml, который им управляет

- Конфигурация — faces-confg.xml (опционально).

В силу того, что у JSF есть собственный RunTime, у него есть и собственный дескриптор. Опционален, так как можно юзать аннотации. Но конфигурационный файл .xml имеет больший приоритет.

### 117. Наследование и полиморфизм в ORM

<a name="orm"></a> 

При объектно-реляционном отображении наследование и полиморфизм тесно связаны.

Понятия наследования в реляционной модели нет, нужно как-то выкручиваться

Три способа реализации:
1. Одна таблица для всех классов. (Тоже используется, когда преформанс критичен)

    Плюсы: простота и производительность (чем меньше связей на уровне реляционной модели, тем быстрее все работает)

    Минусы: отсутствие null ограничений (в одной и той же таблице физически храянтся несколько сущностей. Мы не можем обозначить not null поля BankAccount (даже если они есть всегда), так как у CreditCard не будет никогда полей BankAccount), не нормализованная таблица
    
2. Своя таблица на каждый класс

    Плюсы: возможность not null ограничений (Все поля, которые есть в классе есть и в сущности)
    
    Работает быстро? Все однородные объекты хранятся в своей табличке

    Минусы: плохая поддержка полиморфных записей (неудобно агрегировать данными по BillingDetails(предок), так как они физически по разным таблицам разложены, таблицы друг с другом на уровне реляционной механики не связаны) , не нормализованная таблица (держим данные одной и той же сущности(предок) в разных таблицах), низкая производительность (работаем внутри сущности - все ок, что касается класса предка - проблемы с перформансом)

3. Своя таблица на каждый подкласс (Чаще всего используется)

    Плюсы: нормализованная таблица, лучший вариант для полиморфизма (можем выбрать BillingDetails и куда-то вниз походить, возможность not null ограничений

    Минусы: низкая производительность (выборка всех CreditCard зацепит таблицу BillingDetails, для выборки полного набора данных по одной сущности придется залезть в соседнюю таблицу)
    
### 118. EJB калькулятор для 4-х операций

```java
@Stateless(name = "CalculatorEJB")
public class CalculatorEJB{

    public float add(float a, float b){
        return a + b;
    }
    public float sub(float a, float b){
        return a - b;
    }
    public float mul(float a, float b){
        return a * b;
    }
    public float div(float a, float b){
        return a / b;
    }
}
```

```java
@Stateless(name = "CalculatorEJB")
public class CalculatorEJB{
private double a; 
private double b; 
private double ans;
public getA(){return a;} 
public getB(){return b;}
public setA(double a){this.a=a;} 
public setB(double b){this.b=b;}
public getAns(){return ans;}

public float add(){
    ans= a + b;
}
public float sub(){
    ans= a - b;
}
public float mul(){
    ans= a * b;
}
public float div(){
    ans= a / b;
}
}
```

### 119. Контекст управляемых бинов. Конфигурация контекста.

#### Контекст управляемых бинов

У управляемых бинов есть контекст, который определяет продолжительность жизни. Он задается аннотацией.

Аннотации

- @RequestScoped - используется по умолчанию. Создаётся новый экземпляр managed bean на каждый HTTP запрос (и при отправке, и при получении). Контекст - запрос

- @SessionScoped - экземпляр создаётся один раз при обращении пользователя к приложению, и используется на протяжении жизни сессии. Managed bean обязательно должен быть Serializable. Контекст — сессия.

- @ApplicationScoped - экземпляр создаётся один раз при обращении и используется на протяжении жизни всего приложения. Не должен иметь состояния, а если имеет, то должен синхронизировать доступ, так как доступен для всех пользователей. Контекст — приложение.

- @ViewScoped - экземпляр создаётся один раз при обращении к странице, и используется ровно столько, сколько пользователь находится на странице (включая ajax запросы). Контекст — страница, представление.

- @CustomScoped(value="#{someMap}") - экземпляр создаётся и сохраняется в Map. Программист сам управляет областью жизни.

- @NoneScoped - экземпялр создаётся, но не привязывается ни к одной области жизни. Применяется когда к нему обращаются другие managed bean'ы, имеющие область жизни. Бин без контекста.

#### Something about @ViewScoped and @RequestScoped

A @ViewScoped bean lives exactly as long as a JSF view. It usually starts with a fresh new GET request, or with a navigation action, and will then live as long as the enduser submits any POST form in the view to an action method which returns null or void (and thus navigates back to the same view). Once you refresh the page, or return a non-null string (even an empty string!) navigation outcome, then the view scope will end.

A @RequestScoped bean lives exactly as long a HTTP request. It will thus be garbaged by end of every request and recreated on every new request, hereby losing all changed properties.

A @ViewScoped bean is thus particularly more useful in rich Ajax-enabled views which needs to remember the (changed) view state across Ajax requests. A @RequestScoped one would be recreated on every Ajax request and thus fail to remember all changed view state. Note that a @ViewScoped bean does not share any data among different browser tabs/windows in the same session like as a @SessionScoped bean. Every view has its own unique @ViewScoped bean.

#### Промежуточное между @ViewScoped @RequestScoped - @CustomScoped

Зачем такое может понадобиться - пожалуй, самый простой вопрос. Реальный пример: нужно отображать разные формы на одной и той же шаблонной разметке страницы в зависимости от действий пользователя. Т.е. выглядит это как-то так: слева меню, справа рабочая область (и не одна...). Все это - основная рабочая область. И в зависимости от того, что выбрал пользователь из меню - должна перерисоваться какая-нибудь из нескольких доступных областей страницы. Формы приходят с помощью Ajax, поэтому вид один и тот же (и ViewScope живет все время, пока не перерисуется ВСЯ страница, а не ее части, что нежелательно в данной ситуации).

Казалось бы, решение элементарное - приходящие по Ajax'у куски страниц обслуживаются ViewScope-бинами и профит. Однако не совсем так. Так как вид (основная страница) на самом деле не меняется, то при повторном нажатии на какой-нибудь пункт меню, пользователь увидит страницу в состоянии, которое осталось в памяти (ViewScoped бин НЕ пройдет инициализацию еще раз, он просто есть в памяти и все). Поставить на такие бины RequestScoped тоже не вариант - они будут переинициализироваться от каждого чиха пользователя внутри кусочка формы, который привязан к своему бину с видимостью Request.

Конечно, иногда такое бывает даже нужно, но не всегда. Что, если нужно промежуточное поведение между ViewScoped и RequestScoped? Т.е. если кусочек страницы появился - его бин должен пройти инициализацию, а когда скрылся - бин должен быть удален из области видимости, чтобы новый показ этого же кусочка страницы означал создание соответствующего управляемого бина (а не использование предыдущего состояния).

Вот тут-то нам на помощь и может прийти Custom Scope. (Справедливости ради нужно заметить, что это лишь один из путей достичь желаемого, но путь хороший и правильный.)

#### 120. Конфигурации контекста

Конфиуграция управляемых бинов
faces-config.xml

```xml
<managed-bean>
  <managed-bean-name>customer</managed-bean-name>
  <managed-bean-class>CustomerBean</managed-bean-class>
  <managed-bean-scope>request</managed-bean-scope>
  <managed-property>
    <property-name>areaCode</property-name>
    <value>#{initParam.defaultAreaCode}</value>
  </managed-property>
</managed-bean>
```

С помощью аннотаций

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
  @ManagedProperty(value="#{initParam.defaultAreaCode}" name="areaCode")
  private String areaCode;
}
```

### 121. Связи между сущностями в JPA.

Entity – это сущность которая является отображением в базе данных. Связь между Entity – это зависимость одной сущности от другой. Очень часто используются они в построении больших БД.

- OneToMany
- ManyToOne
- ManyToMany
- OneToOne

двунаправленные - классы хранят ссылки друг на друга
однонаправленные - ссылка хранится только в одном из классов

#### OneToOne

В сущность Author добавляем следующее:
```java
@OneToOne(optional = false)
@JoinColumn(name="book_id", unique = true, nullable = false, updatable = false)
private Book book;
```
а в сущность Book:

```java
@OneToOne(optional = false, mappedBy="book")
public Author author;
```

Обратите внимание на mappedBy, он указывает на имя атрибута сущности Author для связи с ним.

#### OneToMany и ManyToOne
В сущность Author добавляем следующее:

```java
@ManyToOne(fetch = FetchType.EAGER, cascade = {CascadeType.MERGE, CascadeType.PERSIST})
@JoinColumn(name = "book_id", nullable = false)
private Book book;
```
а в сущность Book:

```java
@OneToMany(fetch = FetchType.EAGER, mappedBy = "book")
private Set<Author> users;
```


#### ManyToMany

В сущность Author добавляем следующее:

```java
@ManyToMany
@JoinTable(name="author_book",
        joinColumns = @JoinColumn(name="author_id", referencedColumnName="id"),
        inverseJoinColumns = @JoinColumn(name="book_id", referencedColumnName="id")
)
private Set<Book> books;
```

а в сущность Book:

```java
@ManyToMany(fetch = FetchType.EAGER, mappedBy = "books")
private Set<Author> users;
```

#### CascadeType
Определяет набор каскадных операций, которые распространяются на соответствующие сущности:

cascade=ALL – на все операции

cascade={PERSIST, MERGE, REMOVE, REFRESH, DETACH} – на определенные операции, те что есть в перечислении будут учитываться.

```java
@ManyToOne(fetch = FetchType.EAGER, cascade = {CascadeType.MERGE, CascadeType.PERSIST})
@JoinColumn(name = "book_id", nullable = false)
private Book book;
```

В зависимости от cascade будет либо учитываться связь между сущностями для выполнения операции, либо нет.

#### FetchType
Определение стратегии для извлечения данных из базы данных.

EAGER – стратегия, которая предусматривает получение полной связи между сущностями, и последующих обращениях к связям не будет выполнять запрос на получение данных, так как данные изначально были получены полностью.

```java
@OneToMany(fetch = FetchType.EAGER, mappedBy = "book")
private Set<Author> users;
```

LAZY – стратегия, которая не предусматривает получение полной связи сущностей, и при первом обращении к связи будет выполнятся запрос на получение данных с БД.

```java
@OneToMany(fetch = FetchType.LAZY, mappedBy = "book")
private Set<Author> users;
```

Ссылочка:
- https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-jpa/jpa-otnosheniia-sushchnostei
- http://java-online.ru/hibernate-entities.xhtml

#### Удаление связанных сущностей
Наличие или отсутствие связанной сущности в базе данных определяет способ удаления. Если связанная сущность отсутствует, то можно использовать оператор DELETE в HQL-запросе объекта Query. Но если сущность содержит связанный объект в таблице БД, то при выполнении транзакции удаления с использованием объекта Query будет вызвано соответствующее исключение. Удаление связанных сущностей необходимо выполнять с использованием объекта сессии Session. Подробнее об этом представлено при описании оператора DELETE в HQL-запросе.

#### Однонаправленные/Двунаправленные связи

Если вы используете аннотацию @OneToMany с @JoinColumn , то у вас есть однонаправленная ассоциация.

Если вы используете @OneToMany с набором атрибутов mappedBy , у вас есть двунаправленная Ассоциация, то есть вам нужно иметь ассоциацию @ManyToOne на дочерней стороне, на которую ссылается mappedBy .

Однонаправленная ассоциация @OneToMany работает не очень хорошо, поэтому вам следует избегать ее.

Вам лучше использовать двунаправленный @OneToMany , который более эффективен .

### 3. Реализовать компонент на React, строку поиска с автодополнением. Массив слов для автодополнения получать через GET запрос с использованием REST API.

```javascript 
import React, {Component} from 'react';
import axios from 'axios';
import Autocomplete from 'react-autocomplete';

class AutoSearch extends Component {
    constructor(props) {
        super(props);
        this.state = {
            value: '',
            prompts: []
        };  
        this.getItems();
    }

    getItems() {
        axios({
            url: 'urlStorageWithWords',
            method: 'get',
        }).then (result => {
            this.setState({prompts: result.data});
        }).catch(error => {
            console.log(error);
        })          
    }
    
    render() {
        return(
            <div>
                <input list="options"/>
                <datalist id="options">
                {this.state.list.map((key, item)=>
                 <option key={key} value={item}/>
                 )}
                 </datalist>
            </div>
    )
    }

}
 
```

### 122. FacesServlet. Конфигурация

#### FacesServlet:

FacesServlet(большой сложный монстр) - диспетчиризует запросы к конкретным представлениям и определяет в зависимости от того, что в запросе происходит, какой Managed Bean будет вызван, какая View-шка будет показана.

Это обычный Java класс, реализующий интерфейс сервлета (оыбчный сервлет, но большой и страшный)

Весь JSF-ский RunTime обеспечивается по сути этим Faces сервлетом (он определяет, какая View будет сгенерирована, он определяет, как траснлировать запросы, он определяет, как формировать ответы и т д)

Когда приходит запрос на JSF, обработку этого запроса принимает FacesServlet. Он определяет, что находится в этом запросе (к какому компоненту мы обращаемся) и он же определяет, какой Response должен быть сформирован  

JSF - фреймворк, позволяющий писать в условно десктопном стиле. (Вместо модели request-response у нас модель Event-based(но снизу все равно протокол HTTP с request и response))

Faces Servlet занимается конверсией из request-response модели в event-base и обратно

- Обрабатывает запросы с браузера.

- Формирует объекты-события и вызывает методы-слушатели.

#### Конфигурация Faces Servlet 

Так как Faces Servlet - обычный сервлет, конфигурация задается точно так же в файле web.xml

```xml
  <servlet>
        <servlet-name>Faces Servlet</servlet-name>
        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>Faces Servlet</servlet-name>
        <url-pattern>*.xhtml</url-pattern>
    </servlet-mapping>
```

### 123. Hibernate. Задание сущностей, типы соединений, типы языков

#### Hibernate
Hibernate - ORM framework реализация JPA api, один из основных.

ORM-решением для языка Java, является технология Hibernate, которая не только заботится о связи
Java классов с таблицами базы данных (и типов данных Java в типы данных SQL), но также
предоставляет средства для автоматического построения запросов и извлечения данных и может
значительно уменьшить время разработки, которое обычно тратится на ручное написание SQL и
JDBC кода. Hibernate генерирует SQL вызовы и освобождает разработчика от ручной обработки
результирующего набора данных и конвертации объектов, сохраняя приложение портируемым во
все SQL базы данных.

#### Задание сущностей
Сущности задавать через аннотации или через persistence.xml, где прописывается различное описание сущности, например, к какой таблице относится и т.д.

```java

@Entity
public class Author {

	@Id
	private Long id;

}
```

```xml
<entity-mappings>
    <entity class="org.thoughts.on.java.model.Author" name="Author">        
        <attributes>
            <id name="id">
            </id>
        </attributes>
   </entity>
</entity-mappings>
```

#### Типы соединений
Соединения сущностей бывает OneToMany, ManyToOne, OneToOne, ManyToMany

#### Типы языков
Языки:
HQL - hibernate query language 
Hibernate использует мощный язык запросов (HQL), внешне похожий на SQL. Однако по сравнению с SQL HQL полностью объектно-ориентирован и понимает такие понятия, как наследование, полиморфизм и ассоциация.

### 124. Redux Storage, описывающее состояние CRUD интерфейса к списку студентов


```javascript
import {
    CREATE,
    READ,
    UPDATE,
    DELETE
 } from ‘constants’;

const initialState = {
//массив студентов
    students = []
};

export function studentsReducer(state = initialState, action){
    switch(action.type){
        case CREATE:
            return {...state, state.students: [...state.students, action.payload]}
        case UPDATE:
            return {...state, students[action.payload.index]: action.payload}
        case DELETE:
            return {...state, state.students: [
                    ...state.students.slice(0, action.index),
                    ...state.students.slice(action.index + 1)
                    ] }
        case READ:
            return {...state, readen: “ну прочитай, браток”}
}
}
```

```javascript
import React, { Component } from 'react';

import { connect } from 'react-redux';

import Post from './Post';

class AllPost extends Component {
    render() {
        return (
            <div>
                <h1>All Posts</h1>
                {this.props.posts.map((post) => <Post key={post.id} post={post} />)}
            </div>
        );
    }
}

const mapStateToProps = (state) => {
    return {
        posts: state
    }
}
export default connect(mapStateToProps)(AllPost);
```

## Билет 10

### 1. Валидаторы (все что в слайдах)

Валидаторы это элементы jsf, которые позволяют осуществлять проверки вводимых значений в компоненты jsf. Валидаторы начинают работать после фазы применения значений запроса(после того, как отработали конверторы) или если стоит immediate="true". Есть готовые валидаторы длины, регулярок и т.д. можно писать свои валидаторы, которые должны реализовать интерфейс валидатор

Главной целью конвертации и валидации является подготовка данных для обновления объектов
модели. Таким образом, к моменту вызова методов, реализующих логику приложения, можно
сделать определенные выводы о состоянии модели.

Стандартная валидация

JSF включает в себя три стандартных компонента для валидации:
- DoubleRangeValidator: Проверяет, что значение компонента укладывается в интервал,
определяемый нижней границей, верхней границей или и тем, и другим. Значение должно
быть числом.
- LongRangeValidator: Проверяет, что значение укладывается в интервал, определяемый
нижней границей, верхней границей или и тем, и другим. Значение должно быть числом,
преобразуемым к типу long.
- LengthValidator: Проверяет, что длина значения укладывается в интервал, определяемый
нижней границей, верхней границей или и тем, и другим. Значение должно быть типа String.

Для создания валидатора необходимо сделать следующее:
- класс, реализующий интерфейс Validator (javax.faces.validator.Validator).
- Реализовать метод validate().
- Зарегистрировать валидатор в файле faces-config.xml или аннотацией @FacesValidator
- Использовать тег <f:validator/> на страницах JSP.
Примеры
<f:validateLength minimum="5" maximum="10" />

#### Способы валидации данных:
- С помощью параметров компонента
    ```xhtml
      <h:inputText id="zip" size="10" value="#{customerBean.zip}" required="true"/>
    ```
- С помощью вложенного тега 
     ```xhtml
      <h:inputText id="quality" size="4" value="#{customerBean.quality}" required="true">
          <f:validateLongRange minimum="1"/>
      </h:inputText>
    ```  
-С помощью логики на уровне управляемого бина  (ручками надо будет положить ошибку в FacesContext)  
  
Форма простая - проще валидировать на уровне бина
Форма сложная - проще сделать свой валидатор и валидировать им
  

### 125. Запросы к бд в JPA. jpql и criteria api

#### Запросы к БД:

Используется EntityManager

![alt text](resources/emMethods.png "Entity Manager methods")

Ещё там есть createQuery, createNativeQuery и тому подобное.
Для выполнения запросов используются SQL, JPQL (Java Persistence Query Language - SQL-подобный язык для работы с объектами вместо сущностей) и Criteria API (не SQL-подобные текстовые запросы, а методы).

#### createQuery/createNativeQuery

```java
EntityManagerFactory emfactory = Persistence.
			createEntityManagerFactory("Eclipselink_JPA");
EntityManager entitymanager = emfactory.
				createEntityManager();
	//Scalar function
Query query = entitymanager.
createQuery("Select UPPER(e.ename) from Employee e");
List<String> list=query.getResultList();		
Query query = entitymanager.		
createQuery("Select e.ename from Employee e");		
List<Employee> eList=query.getResultList();						
```
Метод createQuery используется для создания динамических запросов, которые являются запросами, определенными непосредственно в бизнес-логике приложения.
 ```java
public List findWithName(String name) {
return em.createQuery(
"SELECT c FROM Customer c WHERE c.name LIKE :custName")
.setParameter("custName", name)
.setMaxResults(10)
.getResultList();
}
```
Метод createNamedQuery используется для создания статических запросов или запросов, определенных в метаданных с помощью аннотации javax.persistence.NamedQuery. Элемент name @NamedQuery указывает имя запроса, который будет использоваться с методом createNamedQuery. Элемент запроса @NamedQuery является запросом:

Метод createNativeQuery создать экземпляр запроса для выполнения собственного SQL заявление. вот несколько причин для выбора createNativeQuery :

- Доступ низкого уровня, что означает, что вы можете оптимизировать и обрабатывать отображение самостоятельно; с SQL вы фактически получаете доступ к таблице базы данных, а с JPQL-к объектам сущностей;
- Может быть, вы не хотите учиться JPQL, если вы уже знаете SQL
- У вас уже есть запросы, написанные в SQL, и нет ресурсов/времени, чтобы перенести их в JPQL

#### JPQL

JPQL (Java Persistence query language) это язык запросов, практически такой же как SQL, однако
вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В
качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз
данных.

Характерные черты: 
- расширение EJB QL; 
- SQL-подобный синтаксис;
- в запросах указываются объекты/свойства вместо таблиц/колонок; 
- поддерживаются подзапросы.

Синтаксис JPQL очень подобен к синтаксису SQL. Иметь SQL как синтаксис преимущество потому что SQL прост и широко используем. SQL работает сразу против таблиц реляционной базы данных, показателей, и полей, тогда как JPQL работает с типами и примерами Java.

JPQL поддерживает именованные параметры, которые начинаются с символа двоеточия ':'

#### Criteria API

Характерные черты: 
- Объектно-ориентированный API для построения запросов. 
- Есть возможность отобразить любой JPQLзапрос в Criteria. 
- Поддерживает построение запросов в runtime.

- Необходимо указать сущности, участвующие в запросе (query roots).
- Условие запроса задается через where(Predicate p), где аргумент устанавливает необходимые
ограничения.
- Метод select() определяет, что мы получим в результате запроса.
```java
Root customer = qdef.from(Customer.class);
qdef.select(customer).where(queryBuilder .equal(customer.get("customerInfo"), ci));
```
The Criteria API is an API for building queries with Java™ objects, as an alternative to building strings for Java Persistence Query Language (JPQL) queries.

The Criteria API supports building queries dynamically at run time, and also the ability to build type-safe queries that can be verified by the compiler. The correctness of JPQL queries cannot be verified by the compiler, and must be verified at run time during testing.

```jpaql
SELECT e FROM Employee e WHERE e.serviceyears < 5
```

```java
QueryBuilder qb = emf.getQueryBuilder();
CriteriaQuery q = qb.create(Employee.class);
Root e = q.from(Employee.class);
q.where(qb.lt(e.get(Employee_.serviceyears), 5));
TypedQuery tq = em.createQuery(q);
List result = q.getResultList();
```

Two important features are improvements from JPQL:  
- The Criteria API can express queries that are not possible through JPQL. 
- A CriteriaQuery can be edited programmatically. 

### 126. Написать компонент ejb для списания средств со счета клиента и начисления их на счет банка за одну транзакцию

Транза́кция — группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными

```java
@Stateful
@TransactionManagement(BEAN)
public class MySessionBean implements MySession {
@Resource UserTransaction ut;
    public void method() {
        try {
            ut.begin(); // Открываем транзакцию
            //... какие-то действия
            // вызвать метод у database bean для клиента getMoneyAway. Который спишет деьги и вернет их
            // вызвать метод у database bean для банка acceptMoney. Который зачислит деньги
            ut.commit(); // Закрываем транзакцию
        } catch (Exception e) {
            ut.rollback(); // Ошибка — откат транзакции
        }
    }
}       
```
```java
@Stateless
@TransactionManagement(BEAN)
public class MyBean {
   @Resource
   UserTransaction ut;
   public void pay(Bank bank, Client client, double sum) {
       try {
           ut.begin();
           client.setWalletValue(client.getWalletValue - sum);
           bank.setWV(bank.getWV+sum);
           ut.commit();
       } catch (Exception e) {
           ut.rollback();
       }   }
}
```


### 127. Фаза обновления значений компонентов, фаза вызова приложения

#### Фаза обновления значений компонентов 
- Если данные валидны, то значение компонента обновляется. Новое значение присваивается полю
объекта компонента.

- На фазе обновления значений компонентов уже отработали валидаторы, значит данные условно валидны и мы передаем эти данные в проперти бина. 

- Обновление свойства managed bean информацией из дерева компонентов.

#### Фаза вызова приложения

- Управление передается слушателям событий. Формируются новые значения компонентов.

- В процессе обновления мы можем исполнить евенты, на которые кто то подписан. если event listener запустил responseComplete(), то обработка запроса прекращается, если запустили renderResponse() обработка уходит на стадию формирования ответа. На фазе вызова приложения оставшиеся события передаются для обработки приложению

- JSF обрабатывает события, которые были сгенерированы нажатием на кнопки и ссылки. На данном этапе также решаются вопросы, связанные с навигацией приложения, если это необходимо. Если один из компонентов формы имеет свойство immediate="true", то он должен был быть обработан в фазе "Применение значений запроса".

### 128. ЖЦ spring- приложения

1. Парсинг конфигураций, создание объектов BeanDefinition  
beandefinition reader парсит конфиг,( разные типы ридеров парсят разные конфиги) 

2. Настройка объектов BeanDefinition  
и создает beandefinition это метаинформация о бинах, их скоуп, название и т. д

3. Создание объектов собственных FactoryBean<T>   
потом создаются beanfactorypostprocessor которые имеют доступ к beandefinition, которые могут изменить дефинишны

4. Создание экземпляров бинов  
beanfactory вызывает конструкторы бинов, скармливает бины пострпроцессорам

5. Настройка экземпляров бинов  
которые могут например распарсить аннотации и по ним создать динамические прокси от бинов и добавить им функционал, после этого фактори складывает бины в ИОС контейнер.

![alt text](resources/lifecycleSpring.png )

Почтовый процессор Bean Factory (BFPP):

Используется, когда мы хотим переопределить XML / аннотации, потому что Spring читает XML / аннотации для создания bean-компонентов. Если вы хотите предоставить Spring другую конфигурацию во время создания (во время выполнения), вам необходимо использовать BFPP. Создание внутреннего графа зависимостей - это однократный процесс.

Постпроцессор Bean (BPP):

Вышеупомянутый шаг произошел только один раз. Это похоже на создание «меню» из бобов. После создания bean-компонента, если вы хотите изменить свойства bean-компонента, вы не сможете вносить какие-либо изменения в XML / аннотации. Вместо этого вы можете использовать BPP для изменения конфигурации bean-компонента после создания. BPP имеет 2 области выполнения, одну перед @postconstruct и одну после @postconstruct.

postProcessBeforeInitialization
postProcessAfterInitialization

![alt text](resources/BeanConfigurationLifecycle.png )

___________________________________

ЖЦ обработки запросов с браузера?:

Более подробный,

- DispatcherServlet использует обработчики, чтобы решить "which controller" обслуживать этот запрос.

- Контроллеры являются / должны быть "легковесными" - должны быть отделены от сервисные процессы в бэк-энде как хорошая практика проектирования-они содержат ссылки на сервис(Ы) и вызывают правильный(ые). Их "mission" заключается в контроле процесса обслуживания (ов) для построения модели и передачи он вернулся к диспетчеру для следующего шага.

- Компонент View сам по себе состоит из 2 частей: сначала ViewResolver выбирает правильный тип вида поиска, чтобы поместить модель в окончательный формат для пользователя.

С точки зрения разработчика, DispatcherServlet - это behind-the-scenes вещь. Все, что я делаю, это определяю и настраиваю его, если это необходимо, в web.xml. Как разработчик, я создаю экземпляр ApplicationContext (есть много типов ApplicationContext - я выбираю один в зависимости от того, что мне нужно, обычно это WebApplicationContext(?)). AplicationContext-это фабрика, которая создает все сервлеты / бобы, включая DispatcherServlet, используя их описания в файлах .xml. DispatcherServlet затем работает за кулисами и управляет весь процесс-- goes&gets контроллеры, используя аннотации или их .xml описания, представления, обработчики, валидаторы и т.д.

____

BeanFactory предоставляет механизм конфигурации по управлению любым типом объектов. ApplicationContext - наследует нитерфейс BeanFactory и добавляет более специфичную функциональность.

Ниже представлена диаграмма, отражающая, как работает Spring. Ваши классы приложения совмещаются с метаданными конфигурации, в результате чего будет создан и инициализирован ApplicationContext, а на выходе вы получите полностью настроенное и готовое к выполнению приложение.

В метаданных конфигурации разработчик описывает как инициализировать, настроить IoC контейнер и собрать объекты в вашем приложении. 

### Настройка IoC контейнера

Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией @Configuration и методы с аннотацией @Bean. Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках). Класс с аннотацией @Configuration говорит о том, что он является источником определения бинов. Самая простейшая из возможных конфигураций выглядит следующим образом:

```java
package lessons;

import org.springframework.context.annotation.Configuration;

/**
 * Конфигурационный класс Spring IoC контейнера
 */
@Configuration
public class LessonsConfiguration {
}
```

Для того, чтобы приступить к настройке и изучению Spring IoC контейнера, вы должны инициализировать ApplicationContext, который поможет также с разрешением зависимостей. Для обычной Java-конфигурации применяется AnnotationConfigApplicationContext, в качестве аргумента к которому передается класс, либо список классов с аннотацией @Configuration, либо с любой другой аннотацией JSR-330, в том числе и @Component:

```java
public class Starter {

    private static final Logger logger = LogManager.getLogger(Starter.class);

    public static void main(String[] args) {
        logger.info("Starting configuration...");

        ApplicationContext context = new AnnotationConfigApplicationContext(LessonsConfiguration.class);
    }
}
```

### Использование @Bean аннотации

Как упоминалось выше, для того, чтобы объявить Bean-объект(далее просто бин), достаточно указать аннотацию @Bean тому методу, который возвращает тип бина как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках). Например, определим интерфейс какого-нибудь сервиса и его реализацию:

```java
package lessons.services;

public class GreetingServiceImpl implements GreetingService {

    @Override
    public String sayGreeting() {
        return "Greeting, user!";
    }
}
```

```java
@Configuration
public class LessonsConfiguration {
    @Bean
    GreetingService greetingService() {
        return new GreetingServiceImpl();
    }
}
```

```java
public class Starter {

    private static final Logger logger = LogManager.getLogger(Starter.class);

    public static void main(String[] args) {
        logger.info("Starting configuration...");

        ApplicationContext context = new AnnotationConfigApplicationContext(LessonsConfiguration.class);
        GreetingService greetingService = context.getBean(GreetingService.class);
        logger.info(greetingService.sayGreeting());  // "Greeting, user!"
    }
}
```

Однако такой подход не рекомендуется использовать в production-конфигурациях, т.к. для подобных целей существует механизм Dependency Injection (DI), собственно говоря, для чего и предназначен Spring IoC контейнер. Использование DI будет рассмотрено ниже в отдельной главе.

Как было описано выше, Spring IoC контейнеру требуются метаданные для конфигурации. Одну из таких аннотаций мы уже рассмотрели, это @Bean, рассмотрим теперь и другие.

Другой основной аннотацией является @Component, а также её наследники @Repository, @Service и @Controller. Все они являются общими шаблонами для любых компонентов, управляемыми контейнеером. @Repository, @Service и @Controller рекомендуется использовать в тех случаях, когда вы можете отнести аннотируемый класс к определенному слою, например DAO, либо когда вам необходима поддержка функциональности, которую предоставляет аннотация. Также эти аннотации могут иметь дополнительный смысл в будущих версиях Spring Framework. В остальных же случаях достаточно использовать аннотацию @Component.

### Области видимости(scopes) бинов

- singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина. Как правило, используется для бинов без сохранения состояния(stateless)
- prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с сохранением состояния(stateful)
- request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса создается новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext
- session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если вы используете web-aware ApplicationContext
- global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании portlet контекста). Действует, только если вы используете web-aware ApplicationContext
- application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только если вы используете web-aware ApplicationContext

```java
@Component
@Scope("prototype")
public class GreetingServiceImpl implements GreetingService {
    //...
}
```

### 129. JNDI
Для того, чтобы понять, как фактически реализуются принципы IoC и CDI на уровне платформы Java EE и Spring, нужно познакомиться с JNDI
 
JNDI — это набор Java API, организованный в виде службы
каталогов, который позволяет Java-клиентам открывать и
просматривать данные и объекты по их именам (С) Wikipedia.

Служба каталогов - сферическая вакуумная иерархическая БД

Классический вариант использования службы каталогов - LDAP сервер (когда информация о юзерах (логин и пароль), )
Авторизаця на гелиосе происходит через LDAP - это протокол. Он имплементится сервером каталогов. 

Де-факто все наши аккаунты хранятся в опред иерархической базе данных. Есть каталог со студенческими аккаунтами, есть с преподавательскими. 

Все современные серверные ОС поддерживают авторизацию через сервер каталогов, аналогичным образом это поддерживают СУБД, Java и все они на него настроены. => все они используют сквозную базу пользовательских аккаунтов

JNDI - другой аспект использования этих служб каталогов. Мы в ирерархическую структруру объединяем не пользователей, а какие-то ресурсы java. (бины, например, чтобы их потом кто-то мог использовать)

Унифицированное API к реляционной базе данных = JDBC (через драйвер)
Унифицированное API к службе каталогов  = JNDI (драйвер, который по сути адаптер)

Мы ищем в службе каталога какой-то ресурс:
1) Мы делаем из java кода запрос к JNDI API (найди мне какой-то ресурс плиз)
2) Эта штука транслрует его через адаптер-драйвер в синтаксис запроса конкретной иерархической БД, которая используется для хранения нашей иерархии каталогов
3) Получает результат и обратно конвертит на уровень java придложения

Как любое другое Java API, как набор интерфейсов, JNDI не зависит от нижележащей реализации. В
дополнению к этому, он предоставляет реализацию service provider interface (SPI), которая позволяет
службам каталогов работать в паре с каким-либо фреймворком. Это может быть сервер, файл или база

Есть такая штука - JNDI - набор API, позволяющий доставать объекты из контейнера по их именам.
 По сути, это замена обращению по ссылкам, и благодаря этому легко 
 реализуется Dependency Lookup и Dependency Injection. 
 Хранение объектов в таком случае можно представить как Map, 
 где ключи - это имена, а значения - нужные объекты 
 (например, ссылки на них).

![alt text](resources/JNDI.png )

#### 130. JNDI API

Два варианта использования JNDI:
- CDI (аннотации) — работает только в managed компонентах. (де-факто это тоже обращение к JNDI, это такой синтаксический сахар, который позволяет обернуть логику обращения к JNDI, заменить его на некое задание метаинформации. По этой метаинформации сам Application server в итоге обратится к JNDI)
- Прямой вызов API — работает везде. (когда JNDI не локальный, а удаленный)

```java
// Пример получения ссылки на JDBC datasource.
DataSource dataSource = null; // dataSource - ресурс, который лежит в JNDI 
try {
// Инициализируем контекст по умолчанию.
Context context = new InitialContext(); // формирует initial контекст на jndi runtime (на какого-то провайдера, который находится на дефолтной машине на дефолтном порту)
// по сути здесь происходит формирование подключения к БД, которая по дефолту находится на localhost и опред порту
// ручками можно это переопределить и подключиться к удаленному JNDI на другой хост и порт
dataSource =
(DataSource) context.lookup("Database"); // context - оберточка над иерархической БД
} catch (NamingException e) {
 // Ссылка не найдена
}
```

____

JNDI - набор API, позволяющий доставать объекты из контейнера по их именам. По сути, это замена обращению по ссылкам, и благодаря этому легко реализуется Dependency Lookup и Dependency Injection. Хранение объектов в таком случае можно представить как Map, где ключи - это имена, а значения - нужные объекты (например, ссылки на них).
Пример: 
```java
WtfBean example = new InitialContext().lookUp(“wtf_bean’s name”);
```  
Контекст - это, как ни странно, контекст приложения - необходимая часть контейнера, в котором используются IoC и CDI.

### 131. React js

React - это JS библиотека(!!!). Обратите внимание, что именно
библиотека, а не фреймворк (отличаются инверсией управления), которая
предназначена для создания пользовательских интерфейсов. 

У него открытый исходный код. Если говорить о популярности, то у
реакта 160 тысяч звездочек. К примеру, у Ангуляра 68 тысяч.

На слайде есть картиночка вольного сравнения популярности Vue, Angular и
React с помощью гугл трендов. Реакт достаточно популярен сейчас, но это не в
коем случае не значит, что нужно использовать только реакт. Например, Angular
имеет более mvc - шную архитектуру, а у Vue гораздо субъективно меньше порог
вхождения.

Также React предназначен в основном для создания одностраничных
приложений или Single Page Application.

#### Особенности

- Библиотека для построения ui.
- Использует компонентный подход для создания ui.
- Использует jsx для построения дом модели. 
- Использует виртуальный дом для оптимизации рендера компонентов. (не обновляет дом целиком, а обновляет виртуальный дом и сравнивает, что нужно обновить в текущем состоянии дома). 
- Есть умные и глупые компоненты.
- У умных компонентов можно управлять состоянием и методами жизненного цикла компонента
- Однонаправленный поток данных - передача данных от родителей к потомкам через props

____

Умный:
```javascript
class comp extends React{
	constructor(props){// конструктор, можно задавать изначальное состояние, обязательно вызывать супер
			super(props)
			this.state = {
		    id: 0,
		    name: PipSucks
            }
    }
//переопределение методов реакта типа componentDidMount, componentShouldUpdate или свои методы для обработки событий (еще примеров есть в заданиях) 

    render(){
        return(...//Элемент, хтмл код со всякими вставками if и тд
                <CustomElem parentName={this.state.name}>Hello</CustomElem >
                //передача в пропсы потомка чего-нибудь из состояния компонента
        )           
    }
}

```

Глупый: 

```javascript
function Hello(props){
	return <h2>Hello, {props.name}</h2>
}

const element = <Hello name=”qwerty”/>
```
### 133. Написать бин который выводит количество минут, прошедших со старта сервера

```java
@ManagedBean
@ApplicationScoped
public class CounterBean implements Serializable{
    private Date init;

    @PostConsruct
    public void postConstruct() { 
        init = new Date();
    }
    public long getMinutesAfterRestart() { 
        Date currentDate = new Date();
        return (currentDate.getTime()-init.getTime()) / 1000 ; 
    }
    public void setMinutesAfterRestart() {}
}


```

### 134. Обращение к session bean из managed и unmanaged кода

Managed-код находится внутри managed компонентов, то есть компонентов, которыми управляет / о которых знает контейнер, то есть над которыми применимы IoС и CDI. Соответственно, обращение к SessionBean из managed-кода осуществляется с помощью CDI (аннотация @EJB над полем, в котором должен лежать этот бин),   
а из unmanaged - с помощью JNDI. Примеры:

```java
@EJB(name="beanName", beanInterface = Bean.class)

//Unmanaged
Bean beanInstance = (Bean) new InitialContext().lookup("java:comp/env/beanName");
```

___

- Managed - жизненным циклом управляет RunTime. Можно обратиться через аннотации. Пример:
@EJB
- Unmanaged - не управляет RunTime. Можем обратиться через JNDI, то есть к реестру по
определённому имени в реестре:
Context context = InitialContext();
Database database = context.lookup(‘PostgreSQL’)

### 135. Структура в react. Jsx.(может как-то иначе сформулировано)

Структура реакт приложений - древовидная, основанная на прямом потоке данных, где родители могут что то передать детям. по этой структуре строится виртуальный дом, а затем реальный. Jsx  - язык, который выглядит, как смесь js и html, мы можем помечать код как js вставку с помощью {}. Все потом парсится в js с помощью бабеля
___

React представляет собой дерево из компонентов. Точкой входа (корнем) являет index.js который
определяет дальше компоненты. Каждый компонент включает в себя другие компоненты или
являются листьями дерева.

### 136. JSF Manager Bean, после инициализации HTTP-сессии формирующий коллекцию с содержимым таблицы Н_УЧЕБНЫЕ_ПЛАНЫ. Для достпула к БД необходимо использовать JDBC-ресурс jdbc/OrbisPool.

![alt text](resources/23-3.png )

### 136. Проблемы ORM 

- Проблема идентичности. 

    Несколько неидентичных объектов представляют одну строку базы данных

    ![alt text](resources/identicProblem.png )

    Возможны три варианта:  
    1)Обычный уровень хранения без управления
    идентичностью (no identity scope).  (забиваем, кто сохранил, тот и победил. Никакого противоречия нет) (ничего не сонхранизируется никогда)
    2)Уровень хранения с контекстно-управляемой
    (context-scoped) идентичностью .  (гибкий подход) (используется в EJB?)
    3)Уровень хранения с жестким управлением
    идентичностью (process-scoped identity). (все синхронизируется всегда)

- Представление наследования и полиморфизма. 

    [тык](#orm)
    
- Проблема навигации между данными.

Существует фундаментальное различие между способами доступа к данным
в Java и реляционной базе данных. Чтобы получить доступ к платежной информации пользователя в Java, вы вызываете someUser.getBillingDetails().iterator().
next() или что-то подобное. Это наиболее естественный способ доступа к объектно-ориентированным данным, который обычно называется обходом графа объектов. Вы перемещаетесь от одного экземпляра к другому и даже перебираете коллекции, следуя за подготовленными указателями между классами. К сожалению,
это не самый лучший способ получения информации из базы данных SQL.

_____
 
Проблемы в ORM:  
1. Ошибки в реализации трудно найти, отладить и исправить
2. Ограничения в реализации
3. Могут потребоваться дополнительные таблицы для отображения классов в таблицы
4. Медлительность
~~### 2. Vaadin и gwt, сходства и различия~~
### 3. Написать конфиг JSF страницы которая принимает xhtml запросы и все, чей url начинается на /faces/

```xml
<servlet>
<servlet-name>Faces Servlet</servlet-name>
<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
    <servlet-mapping>
        <servlet-name>Faces Servlet</servlet-name>
        <url-pattern>*.xhtml</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>Faces Servlet</servlet-name>
        <url-pattern>/faces/*</url-pattern>
    </servlet-mapping>
```

### 137. JTA

Java Transaction Api - дает возможность управления транзакцией не на уровне орм, а на уровне жава кода. инжектится юзертранзактион от него можно делать бегин, коммит, ролбэк 
Нужно для того, чтобы, когда наше приложение работает сразу с нескольких JVM (и юзаются RemoteBean’ы), транзакции распространялись на все JVM, то есть сохраняли изолированность.

Интерфейс для управления транзакциями в EJB-компонентах.
Позволяет открывать, закрывать и откатывать транзакции.

```java
public interface TransactionInterface {
public openTransaction(UserTransaction trns){}
public closeTransaction(UserTransaction trns){}
public rollbackTransaction(UserTransaction trns){}
}
```

```java
@TransactionManagment(BEAN)
public class Transactions implements TransactionInterface{
    @Resource UserTransaction trns;

    public openTransaction(UserTransaction trns){
        trns.open();
    }

    public closeTransaction(UserTransaction trns){
        trns.close();
    }

    public rollbackTransaction(UserTransaction trns){
        trns.rollback();
    }
}
```

Основываясь на спецификации EJB, вы не можете передать контекст транзакции из боба (в этом случае ваш основной класс ... ) используя программную транзакцию в другой боб (в данном случае, другой) используя программную транзакцию

Для EJB3 вы обычно определяете распространение транзакций с помощью аннотации @TransactionAttribute.

### Отличие @TransactionAttribute от UserTransaction

#### Container Managed Transactions

EJB 3.0 has specified following attributes of transactions, which EJB containers implement −

REQUIRED − Indicates that business method has to be executed within transaction, otherwise a new transaction will be started for that method.

REQUIRES_NEW − Indicates that a new transaction, is to be started for the business method.

SUPPORTS − Indicates that business method will execute as part of transaction.

NOT_SUPPORTED − Indicates that business method should not be executed as part of transaction.

MANDATORY − Indicates that business method will execute as part of transaction, otherwise exception will be thrown.

NEVER − Indicates if business method executes as part of transaction, then an exception will be thrown.

```java
package com.tutorialspoint.txn.required;
 
import javax.ejb.*;
 
@Stateless
@TransactionManagement(TransactionManagementType.CONTAINER)
public class UserDetailBean implements UserDetailRemote {
	
   private UserDetail;

   @TransactionAttribute(TransactionAttributeType.REQUIRED)
   public void createUserDetail() {
      //create user details object
   }
}
```
#### Bean Managed Transactions

```java
package com.tutorialspoint.txn.bmt;
 
import javax.annotation.Resource;
import javax.ejb.Stateless;
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.transaction.UserTransaction;
 
@Stateless
@TransactionManagement(value=TransactionManagementType.BEAN)
public class AccountBean implements AccountBeanLocal {
 
   @Resource
   private UserTransaction userTransaction;

   public void transferFund(Account fromAccount, double fund , 
      Account toAccount) throws Exception{

      try{
         userTransaction.begin();

         confirmAccountDetail(fromAccount);
         withdrawAmount(fromAccount,fund);

         confirmAccountDetail(toAccount);
         depositAmount(toAccount,fund);

         userTransaction.commit();
      }catch (InvalidAccountException exception) {
         userTransaction.rollback();
      }catch (InsufficientFundException exception) {
         userTransaction.rollback();
      }catch (PaymentException exception) {
         userTransaction.rollback();
      }
   }

   private void confirmAccountDetail(Account account) 
      throws InvalidAccountException {
   }

   private void withdrawAmount() throws InsufficientFundException {
   }

   private void depositAmount() throws PaymentException{
   }
}
```

### 137. React Router

Router определяет набор маршрутов и, когда к приложению приходит запрос, то Router выполняет
сопоставление запроса с маршрутами. И если какой-то маршрут совпадает с URL запроса, то этот
маршрут выбирается для обработки запроса.  

Каждый Router создает объект history который хранит путь к текущему location[1] и перерисовывает интерфейс сайта когда происходят какие то изменения пути.
Остальные функции предоставляемые в React Router полагаются на доступность объекта history через context, поэтому они должны рендериться внутри компонента Router.

Для выбора маршрута определен объект Switch. Он позволяет выбрать первый попавшийся
маршрут и его использовать для обработки. Без этого объекта Router может использовать для
обработки одного запроса теоретически несколько маршрутов, если они соответствуют строке
запроса.  
Каждый маршрут представляет объект Route. Он имеет ряд атрибутов. В частности, для маршрута


устанавливаются два атрибута:  
- path: шаблон адреса, с которым будет сопоставляться запрошенный адрес URL (Рендериться будут все вариации urlов, содержащие path, если не указать exact. Тогда будет рендериться строго переданный url.
)
- component - тот компонент, который отвечает за обработку запроса по этому маршруту 
 
Switch - для поиска первого совпавшего пути (прим. сначала идет “/’, потом “/main”, мы ищем “/main”,
откроет “/”
BrowserHistory - сохраняется в историю, имеет человеческие назавния (если приложение нестатическое (обрабатываются динамические запросы))
HashHistory - не сохраняется, имеет хэши в URL

<BrowserRouter> -это <Router> , который использует HTML5 history API (pushState, replaceState и событие popstate), чтобы сохранить ваш UI в sync с URL.

#### BrowserRouter и HashRouter
Первое отличие:  
- Они используют разные WEB APIs. <HashRouter> использует и считывает hash из URL, <BrowserRouter> использует window.history WEB API.
  
Второе различие:  
- <HashRouter> используется для статического одностраничного сайта. Идеально подходит для браузерных проектов. <BrowserRouter> используется для динамического веб-сайта. Следует использовать, когда у вас есть сервер, который будет обрабатывать динамические запросы (знает, как реагировать на любые возможные URL).

Оба из них создадут специальный объект истории. Вы должны использовать BrowserRouter, если у вас есть сервер, который отвечает на запросы, и HashRouter, если вы используете статический файловый сервер

```javascript
<Router>
    <Switch>
        <Route exact path="/" component={Main} />
        <Route path="/about" component={About} />
        <Route component={NotFound} />
    </Switch>
</Router>
```
```javascript
<BrowserRouter>
    <Switch>
        <Route exact path="/~s285611/lab4/public/" component={Start}/>
        <Route path="/~s285611/lab4/public/main" component={Main}/>
    </Switch>
</BrowserRouter>
```

### 138. Написать EJB , который " просыпается " в полночь и выводит содержимое таблицы н_люди

из доков по аннотации @Schedule: All elements of this annotation are optional. If none are specified a persistent timer will be created with callbacks occuring every day at midnight in the default time zone associated with the container in which the application is executing.
То есть достаточно просто поставить эту анноташку над нужным методом и магия свершится

```java
@ApplicationScoped
@Singleton // используется инъекция, все дела
public class Bessonnitsa {
	@PersistenceContext(unitName = "movie-unit")
    private EntityManager em;

	@Schedule
	public void doParty() {
            em.createQuery(“SELECT h from н_люди h”)
                        .getResultList()
                        .forEach(p->System.out.println(p.name));
	}
}
```

### 139. ORM

ORM - Технология, которая позволяет связывать объектное и реляционное отображения. Существуют несколько орм-провайдеров. Самые известные - гибернейт и эклипслинк. Использует jdbc и является высшим уровнем абстракции над jdbc.

Но время шло и разработчики каждый раз сталкивались с необходимостью писать однотипный и ненужный "обслуживающий" код (так называемый Boilerplate code) для тривиальных операций по сохранению Java объектов в БД и наоборот, созданию Java объектов по данным из БД. И тогда для решения этих проблем на свет появилось такое понятие, как ORM.

ORM — Object-Relational Mapping или в переводе на русский объектно-реляционное отображение. Это технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования. Если упростить, то ORM это связь Java объектов и записей в БД:

EclipseLink is more standards compliant, since it is the reference implementation for JPA 2, Hibernate has some compliancy issues, but is more mature.

One of the main benefits of EclipseLink is that you can call native SQL functions directly in your JPQL queries. In Hibernate this is not directly possible.

But Hibernate has a bigger community, better documentation and also better error messages.

EclipseLink больше соответствует стандартам, поскольку это эталонная реализация для JPA 2, Hibernate имеет некоторые проблемы с совместимостью, но он более зрелый.

Одним из основных преимуществ EclipseLink является то, что вы можете вызывать собственные функции SQL непосредственно в своих запросах JPQL. В Hibernate это невозможно напрямую.

Но Hibernate имеет большее сообщество, лучшую документацию, а также лучшие сообщения об ошибках.

Hibernate:

ORM-фреймворк от Red Hat, разрабатывается с 2001 г.

Ключевые особенности:

Таблицы БД описываются в XML-файле, либо с помощью аннотаций.  
2 способа написания запросов — HQL и Criteria API.  
Есть возможность написания native SQL запросов.  
Есть возможность интеграции с Apache Lucene для полнотекстового поиска по БД (Hibernate Search).  
Расширенная поддержка естественных идентификаторов  
Загрузка нескольких сущностей по их первичному ключу  
Управление созданием и обновлением меток времени  
Присоединение к неассоциированным объектам в запросах  
Поддержка мультитенантности  

EclipseLink

ORM-фреймворк от Eclipse Foundation.

Ключевые особенности:

Основан на кодовой базе Oracle TopLink.  
Является эталонной реализацией (reference implementation) для JPA.  
EclipseLink предлагает другие опции, которых нет в Hibernate.  
Обработка событий изменения базы данных  
Составные блоки сохранения состояния для сопоставления сущностей с таблицами в нескольких базах данных  
Поддержка мультитенантности  

Например:

- @ ReadOnly - указывает, что объект, который будет сохранен, доступен только для чтения

- @ Struct - определяет класс для сопоставления с базой данных «struct» type


Hibernate одна из самых популярных открытых реализаций последней версии спецификации (JPA 2.1). Даже скорее самая популярная, почти стандарт де-факто. То есть JPA только описывает правила и API, а Hibernate реализует эти описания, впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA
 
### 139. Servlet + html. Посчитать и вывести количество сессий в текущий момент

```jsp
<%! private int count = 0;
private Set<String> sessions; %>
<%
sessions.add(request.getSession().getId());
%>
<%= sessions.size()%>
```

### 140. RMI. RMI в javaEE

Remote method invocation - технология, которая позволяет вызывать методы удаленных объектов. Объекты передаются по значению, а не по ссылке. Если объект экспортирован передается заглушка(stub). Передаваемые объекты должны быть сериализуемыми

RMI тесно связан с принципом Location Transparency. Пример использования RMI (и, соответственно, реализации Location Transparency): Remote EJB и Local EJB. Для клиента создаётся видимость целостности приложения, как будто оно не распределено по разным серверам с разными JVM, то есть для использования Remote EJB ему не надо делать дополнительных движений.

### 141. Инициализация Spring Beans

Итак, поехали
У Spring есть четкий порядок инициализации объектов:  
Формируется Configuration Metadata, она может быть создана из XML-контекста, из конфигурации с помощью Annotations либо Java Configuration.  
Все объекты, которые имплементируют интерфейс BeanFactoryPostProcessor, читают Metadata и изменяют ее в соответствии со своим предназначением.  
Вся Metadata, которую модифицировали и нет, передается в BeanFactory, которая непосредственно и создает spring beans.  
Все объекты, которые имплементируют интерфейс BeanPostProcessor, производят pre initializing- и post initialization-действия.  
Все бины, которые уже были инициализированы, отдаются в IoC Container.  

### 142. Компонент для React, реализующий интерфейс ввода данных для банковской карты: номер (16 цифр); имя (латинские символы); срок действия(mm/yy); зазитный код (3 цифры)

```javascript
import {React} from 'react'

export class CreditCard extends React.Component{
    constructor(props){
        super(props)
        this.state = {
            number = '',
            data = '',
            owner = '',
            CVV = ''
        }
    //Так же все методы надо привязать,чтобы использовать this в них, приведу один
    this.onChange = this.onChange.bind(this)
    }

    //Все аналогичны, напишу один
    onChange(e) {
    //Вот тут делаете валидацию или добавляете / если это Data
    this.state.number = e.value
    }
    onClick(e) {
    sendData(this.state.number, this.state.date, this.state.CVV, this.state.owner)
    }

    render() {
        return(
            <input onChange={this.onChangeNumber(event)} value={this.state.number}/>
            <input onChange={this.onChangeData(event)} value={this.state.data}/>
            <input onChange={this.onChangeOwner(event)} value={this.state.owner}/>
            <input onChange={this.onChangeCVV(event)} value={this.state.CVV}/>
            <button onClick={this.onClick() }/>
        )
    }

    export default CreditCard;

}
```

```javascript
handleChange = name => event => {
       this.setState({
           [name]: event.target.value,
       });
   };
```
```javascript
render() {
        return (
            <div>
                <form id="formLogIn" >
                    <h1>Введите данные карты:</h1>
                    <h3>Номер:</h3>
                    <InputText maxlength="16" keyfilter={/[0-9^\s]/} value={this.props.number} onChange={this.handleChange('number')}/>
                    <h3>Имя:</h3>
                    <InputText keyfilter={/[A-z^\s]/} value={this.props.name} onChange={this.handleChange('name')}/>
                    <h3>Срок действия:</h3>
                    <Calendar value={this.state.date} onChange={this.handleChange('date')} view="month" dateFormat="mm/yy" yearNavigator={true} yearRange="2010:2030"/>
                    <h3>Защитный код:</h3>
                    <InputText maxlength="3" keyfilter={/[0-9^\s]/} value={this.props.code} onChange={this.handleChange('code')}/>
                    <Button label="Send" onClick={this.clickButton}/>
                </form>
            </div>
        );
    }
 }
  
### 143. JMS и реализация в Java

![alt text](resources/JMS2.png)
![alt text](resources/JMS.png)

На самом деле можно и синхронно (то есть получатель вызывает метод receive, и ему либо даётся Message, либо null). 

Есть три важные штуки: Session, MessageProducer и MessageConsumer. Вся схема с доставкой / получением сообщений будет работать только пока сессия запущена. Она может быть приостановлена методом stop и возобновлена start. Методами сессии создаются поставщики и потребители. Для каждого из них можно передать в конструктор куда они будут обращаться (topic или queue), но если этого не сделать, то при отправке / получении сообщения можно будет указать куда / откуда это делать.   
С поставщиком всё просто: формирует сообщение (разные для разных типов контента) и вызывает producer.send(msg). С потребителем интереснее: он может сделать receive (синхронный способ, может выдавать null), а можно навесить на этого потребителя MessageListener, который будет вызываться как только сообщение будет доставлено, а не когда потребитель этого захочет, то есть асинхронно.  
Теперь про разницу между Topic и Queue. В случае топика поставщик - это что-то типа блоггера, он пишет сообщение, а подписота читает. Однако у сообщений есть тайм-аут, после которого их уже нельзя будет получить. В случае Queue сообщение исчезнет как только какой-либо потребитель его получит, то есть гарантируется, что только один юзер получит его. Таймаута на сообщении нет. Юзер может отказываться от сообщения, чтобы следующий в очереди мог посмотреть, не ему ли оно  

### 144. State в React redux и flux

Общее состояние для всего приложения. Хранится в Redux store, не должно меняться никак кроме использования метода dispatch, который принимает reducer.   
Reducer - функция, которая принимает старое состояние и действие(объект с данными, которые меняем - опционально и типом действия - type - обязательно) и возвращает новое состояние в зависимости от типа действия.  
Умные компоненты могут получать доступ к значениям стейтам и редюсерам с помощью метода connect, который используя прописанные в компоненте функции mapStateToProps, mapDispatchToProps.  
Редюсеры также позволяют работать не со всем стейтом, а с его частями, объединяя их в одно с помощью метода combineReducers. Просто получить значение стейта - getState(). Узнать об изменениях в стейте - subscribe(listener) - вызывается всякий раз, когда был вызван dispatch, принимает функцию, которая будет вызвана, возвращает функцию, которая отпишет слушателя.

#### Flux и Redux

Ранее я упоминала, что Flux — это обобщенный шаблон, а не конкретная библиотека. Таким образом, существует ряд различных модулей и фреймворков, которые могут быть использованы для реализации Flux. Но один фреймворк, в частности, зарекомендовал себя как самый популярный. Эта структура — Redux.

![alt text](resources/flux.png)

Redux стремится упростить многие концепции, представленные Flux. Является ли Redux, строго говоря, реализацией Flux — вопрос некоторых дискуссий. Redux и Flux схожи в том, что они оба подчеркивают важность однонаправленного потока данных, и они оба корректируют состояние (state) посредством actions с полями type. Тем не менее, они имеют некоторые отличия, которые важно отметить:

Redux:

- Без диспатчера  
  Redux избавляется от концепции диспатчера (dispatcher). Он может сделать это, потому что Redux имеет только одно хранилище (подробнее об этом чуть позже), поэтому существует только один пункт назначения для передачи новых действий (actions), что устраняет необходимость в диспатчере (dispatcher).
  
- Единственный, менее запутанный store
  С Redux все состояние вашего приложения находится в централизованном хранилище (store), которое служит единственным источником правды приложения. Кроме того, были уменьшены обязанности store — теперь он отвечает только за удерживание состояния, и больше не отвечает за определение того, как настроить его state в ответ на actions. Логика для этого теперь была делегирована …

- Reducers
  Редьюсеры — это чистые функции, которые принимают текущее состояние (state) и заданное действие (action) в качестве аргументов, и выводят либо не измененное состояние, либо новую копию состояния. Здесь важен термин «копия» — Redux считает состояние неизменным. Если необходимо изменить состояние, оно не изменяется напрямую. Вместо этого создается копия состояния, и редьюсер редактирует эту копию, затем возвращает ее, и заменяет исходное состояние его измененной копией.  

При создании хранилища Redux, ему дается аргумент одного корневого редьюсера, который отвечает за всю логику этого хранилища. Однако редьюсер может иметь любое количество под-редьюсеров, которые управляют разными подсекциями состояния. Этот процесс известен как композиция редьюсера. Это увлекательный предмет, который, я не буду здесь вдаваться в подробности, является неотъемлемой частью масштабируемости приложения.

![alt text](resources/redux.png)

### 145. JPQL запрос из таблицы, который выводит всех сотрудников старше 18 лет по полу age (Date)

JPQL (Java Persistence query language) это язык запросов, практически такой же как SQL, однако
вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В
качестве параметров запросов так же используются типы данных атрибутов Entity, а не полей баз
данных. 

```jpaql
SELECT p FROM Person p WHERE ((YEAR(CURRENT_DATE)- YEAR(p.birthDate))>18)
```

```java
@Resource EntityManager em

List<Employee> list = em.createQuery(“Select e from Employee e where e.age > 18”).getResultList();
```

### 148. 3 фаза жизни jsf

Выполнение проверок (Process Validations):
запускаются валидаторы для компонентов, которые проверяют совпадают ли данные с заранее заданными условиями. (мы не проверяем совпадают ли данные по типу это на 2 фазе, когда работают конвертеры) Если на этой фазе ловится ошибка, то остальные скипается и мы рендерим ответ с этой ошибкой

Фазы жизненного цикла:
- Восстановление представления (Restore View) : для запрошенной страницы либо извлекается дерево компонентов, если страница уже открывалась, либо создается новое дерево компонентов, если страница запрашивается впервые. Для компонентов запрашиваемой страницы восстанавливаются их прошлые состояния (форма заполняет вводимыми значениями).
- Применение значений запроса (Apply Request Values) : анализ HTTP запроса, объектам дерева компонентов присваиваются соответствующие им значения из запроса. Если к компоненту подключен конвертер, то значение обрабатывается/конвертируется. При возникновении ошибки, все последующие шаги пропускаются. Если компонент ввода (UIInput) содержит валидатор и имеет свойство immediate="true", то этот компонент будет валидироваться в этой фазе. Также, при необходимости, события (нажатие кнопки или ссылки) добавляются в очередь событий.
- Выполнение проверок (Process Validations) : преобразование строковых значений в "локальные значения" и применение валидации дерева компонентов. Если в результате валидации компонента возникает ошибка, то она сохраняется и JSF пропускает все последующие шаги обработки запроса до фазы "Формирования ответа" для предупреждения пользователя об ошибке.
- Обновление значений модели (Update Model Values) : обновление свойства managed bean информацией из дерева компонентов.
- Выполнение приложения (Invoke Application) : JSF обрабатывает события, которые были сгенерированы нажатием на кнопки и ссылки. На данном этапе также решаются вопросы, связанные с навигацией приложения, если это необходимо. Если один из компонентов формы имеет свойство immediate="true", то он должен был быть обработан в фазе "Применение значений запроса".
- Формирование ответа (Render Response) : JSF создает ответ, основываясь на данных, полученных на предыдущих шагах. Информация страницы обновляется данными из managed bean и генерируется html страница с помощью Renderers. Если на предыдущих шагах происходили какие-либо ошибки, то они инкапсулируются в тег <messages>.
- Страница Java Server Faces представлена в виде дерева компонентов. Корневым компонентом дерева является UIViewRoot.

### 149. IoC DI в Spring 

Бины имеют свои скопы( прототип, синглтон (+ сессия и запрос, если юзается в веб-приложении)) можно реализовать свои области видимости, бины помечаются аннотациями(@service, @component…) организация di идет с помощью @Autowired, @Inject, @Resource. 
можно инжектить с помощью конструктора, можно инжектнуть только какое то поле  
IoC - это когда контейнер занимается порождением и управлением компонентов, и нам не приходится так часто видеть new в коде. Об управлении жизненным циклом компонентов в спринге написано тут.

### 150. сервер JMS, который осуществляет рассылку спама всем подписчикам топика "lol"

```java
@ApplicationScoped
public class Sender {
    @Resource(mappedName = "jms/blablabla")
    private Topic topic;

    @Inject
    private JMSContext context;

    public void sendMessage(String txt) {
    context.createProducer().send(topic, txt);
    }
}
```
____

```java
@Resource(mappedName="jms/ConnectionFactory")
private static ConnectionFactory connectionFactory;
@Resource(mappedName="lol")
private static Topic topic;

public void sendSpam() {
	Connection connection = connectionFactory.createConnection();
        try {
            Session session = connection.createSession(false,
     			Session.AUTO_ACKNOWLEDGE);
	        MessageProducer producer = session.createProducer(topic);
	        connection.start();
            TextMessage message = session.createTextMessage();
            message.setText(“даже школьник смог написать сайт просто прочитав этот ...”);
            while (true) {
                producer.send(message);
                Thread.sleep(1000 * 60);
            }
        catch (InterruptedException e) {
        e.printStackTrace();
        } finally { 
            if (connection != null) { 
                try { connection.close(); } 
                catch (JMSException e) {e.printStackTrace();} 
            }
        }

    }
}
```

### 150. 1 фаза ЖЦ jsf

Формирование представления:
- JSF Runtime формирует представление (начиная с UIViewRoot):
- Создаются объекты компонентов.
- Назначаются слушатели событий, конвертеры и валидаторы.
- Все элементы представления помещаются в FacesContext.
- Если это первый запрос пользователя к странице JSF, то формируется пустое представление.
- Если это запрос к уже существующей странице, то JSF Runtime синхронизирует состояние компонентов представления с клиентом.

### 151. Spring, отличия от java ee

Во первых, приложение Spring это самостоятельное приложение, которому для работы ничего не нужно, так как оно не связано ни с каким контейнером, а сервер, если он есть, то есть приложение серверное, в него уже встроен. Так же вполне себе может функционировать и без сервера и вообще не принадлежать к миру WEB. В отличие от Java EE, она и предназначена для → серверных приложений ← , она предоставляет целый контейнер, кластер java ee, который дает много возможностей из коробки, даже слишком много. Из плюсов, много возможностей. Из минусов, прозрачность процессов идет к черту.

java ee базируется на трехуровневой архитектуре, есть бизнес тир, есть клиент тир, есть вью тир. Спринг базируется на куче независимых модулей. Java ee based on high-level language. Spring не зависит от языка.

### 152. Сконфигурировать entity через xml

persistence.xml:
```xml
<entity-mapping>
    <entity class=”User” name=”User”>
        <table name=”User”/>
        <attributes>
            <id name=”Username”/>
            <basic name=”dolzhnost”/>
            <basic name=”password”><column=”pswd” length=50/><basic>
        </attributes>
    </entity>
</entity-mapping>
```

### 153. Структура JSF-приложения. Компоненты JSF. Иерархия компонент

2 билет

### 154. JPA - особенности, недостатки и преимущества, отличия от JDBC и от его использования с ORM.

jpa это спецификация для работы с базами данных. а jdbc это стандарт. они нужны для работы с базами данных. jpa использует orm провайдер, которй использует ждбс, который испjльзует ждбц драйвер для доступа в базу данных. jpa позволяет абстрагироваться от особенностей орм
 провайдера и писать универсальный код. увеличивается переносимость

ORM — это по сути концепция о том, что Java объект можно представить как данные в БД (и наоборот). Она нашла воплощение в виде спецификации JPA — Java Persistence API. 

Спецификация — это уже описание Java API, которое выражает эту концепцию. Спецификация рассказывает, какими средствами мы должны быть обеспечены (т.е. через какие интерфейсы мы сможем работать), чтобы работать по концепции ORM. И как использовать эти средства.

Реализацию средств спецификация не описывает. Это даёт возможность использовать для одной спецификации разные реализации. Можно упростить и сказать, что спецификация — это описание API.

Реализации JPA ещё называют JPA Provider. Одной из самых заметных реализаций JPA является Hibernate. Поэтому, предлагаю её и рассмотреть.

Java-стандарт (JSR 220, JSR 317), который определяет:
- как Java-объекты хранятся в базе;
- API для работы с хранимыми Java-объектами;
- язык запросов (JPQL);
- возможности использования в различных окружениях

###Что даёт использование JPA?

- Достижение лучшей переносимости.
- Упрощение кода.
- Сокращение времени разработки.
- Независимость от ORM-фреймворков.

### 155. Конвертер jsf 

В стандартную поставку JSF входит множество стандартных конвертеров данных, благодаря чему
большая часть конвертации происходит автоматически.  

f:convertNumber: используется для преобразования строки в число.
f:convertDateTime: используется для преобразования строки в формат даты.

Стандартные конвертеры
- javax.faces.BigDecimal
- javax.faces.BigInteger
- javax.faces.Boolean
- javax.faces.Byte
- javax.faces.Character
- javax.faces.DateTime
- javax.faces.Double
- javax.faces.Float

Конвертер jsf служат для преобразования данных в формат проперти, к которой они привязаны. По умолчанию есть конвертеры в числа и в дату. Можно написать свой конвертер, он должен реализовать интерфейс converter. конвертеры могут привязываться автоматически по типу данных, можно через вложенный тэг, можно через свойство

Что нужно для создания своего конвертера:
1) Создать класс, реализующий интерфейс Converter
2) Реализовать метод getAsObject(), для преобразования строкового значения поля в объект.
3) Реализовать метод getAsString.
4) Зарегистрировать конвертер в контексте Faces в файле faces-config.xml, используя элемент ИЛИ пометить аннотацией @FacesConverter(name)

файл faces-config.xml :
```xml
<converter>
  <converter-for-class>
    com.arcmind.contact.model.Group
  </converter-for-class>
  <converter-class>
    com.arcmind.contact.converter.GroupConverter
  </converter-class>
</converter>
```

```xml
  <converter>
        <converter-id>resultConverter</converter-id>
        <converter-class>ResultConverter</converter-class>
  </converter>
```

### 156. Интерфейс entitymanager и его методы. 

![alt-date](resources/entityManager.png)

EntityManager - базовый интерфейс для работы с хранимыми
данными:
- Обеспечивает взаимодействие с Persistence Context.  

 Контекст сохранения транзакции привязан к транзакции. Как только транзакция завершится, сущности, присутствующие в контексте постоянства, будут сброшены в постоянное хранилище.
 
Когда мы выполняем любую операцию внутри транзакции, EntityManager проверяет контекст сохранения . Если он существует, то он будет использован. В противном случае это создаст контекст постоянства.
- Можно получить через EntityManagerFactory.
- Обеспечивает базовые операции для работы с данными (CRUD).

Основные метод :
1) Для операций над Entity: persist (добавление Entity под управление JPA, а именно PersistenceContext), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Enity от изменений в других thread),
2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery
3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate
4) Работа с EntityGraph: createEntityGraph, getEntityGraph
5) Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear.



### 158. ajax в jsf

<f:ajax> можно указать листенера, который будет ловить евенты, можно указать, что отрендерить, можно указать, что отэкзекутить

```xhtml
 <f:ajax event="click" execute="newPointForm X hiddenR Y "
 render="X Y messageY pointsTable hiddenR b1 b2 b3 b4 b5"/>
```

### 159. Архитектура JPA

Матрешка. использует ормпровайдер, который использует ждбц, который использует ждбц драйвер, который ходит в базу.

EntityManagerFactory - This is a factory class of EntityManager. It creates and manages multiple
EntityManager instances.
EntityManager - It is an Interface, it manages the persistence operations on objects. It works like factory for
Query instance.
Entity - Entities are the persistence objects, stores as records in the database.
EntityTransaction - It has one-to-one relationship with EntityManager. For each EntityManager, operations
are maintained by EntityTransaction class.
Persistence - This class contain static methods to obtain EntityManagerFactory instance.
Query - This interface is implemented by each JPA vendor to obtain relational objects that meet the criteria.


### 160. Интерфейс авторизации(логин+пароль) на React. На стороне сервера - REST AP

![alt-text](resources/authorizationReactPractice.png)

this.toggleState вызывается не в контексте класса и поэтому this - underfined -> поэтому биндим

### 160. Управляемые бины, конфигурация и что-то еще

- Содержат параметры и методы для обработки данных с компонентов, событий и валидации данных.
- Жизненным циклом управляет JSF Runtime Environment. Доступ из JSF-страниц осуществляется с
помощью элементов EL.  
- Для объявлении класса управляемым бином используется аннотация @ManagedBean(name =
«beanName», eager = «true\false»).  
name: указывает уникальное имя класса (бина) в JSF. Если имя не указано, то имя совпадает с
именем класса, где первая буква в нижнем регистре.  
eager: указывает на время создания бина. Если стоит true, то бин будет создан на старте
приложения, если false, то бин будет создан при первом запросе к нему.  

- faces-config.xml:

```xml
<managed-bean>
    <managed-bean-name>customer</managed-bean-name>
    <managed-bean-class>CustomerBean</managed-bean-class>
    <managed-bean-scope>request</managed-bean-scope>
    <managed-property>
        <property-name>areaCode</property-name>
        <value>#{initParam.defaultAreaCode}</value>
    </managed-property>
</managed-bean>
```


- аннотации:
```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
@ManagedProperty(value="#{initParam.defaultAreaCode}" name="areaCode")
private String areaCode;
}
```

### 161. JPA

jpa это спецификация для ORM-библиотек. а jdbc это стандарт. они нужны для работы с базами данных. jpa использует orm провайдер, которй использует ждбс, который испjльзует ждбц драйвер для доступа в базу данных. jpa позволяет абстрагироваться от особенностей жпа провайдера и писать универсальный код. увеличивается переносимость

### 162. Реализуйте CRUD-интерфейс к таблице Н_ВИДЫ_УЧЕБНОЙ_ДЕЯТЕЛЬНОСТИ с помощью Spring data

```java
@Entity
@Table(name = "country")
public class Country {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    private String name;

    // далее идут get- и set-методы...
}
```
Spring Data предоставляет абстракцию CrudRepository, которая типизируется целевой сущностью и её id. CrudRepository имеет набор базовых методов для работы с сущностью, названия которых говорят сами за себя:

Нам достаточно расширить этот интерфейс, добавить сигнатуры необходимых нам методов и Spring автоматически создаст реализацию этого интерфейса!
```java
public interface CountryDao extends CrudRepository<Country, Integer> {

    List<Country> findAllByOrderByIdDesc();

    Country findByName(String name);
}
```

```java
@Service
public class CountryServiceImpl implements CountryService {

    @Autowired
    private CountryDao countryDao;

    @Override
    public List<Country> getAll() {
        return countryDao.findAllByOrderByIdDesc();
    }
}
```

### 163. Location Transparency, реализация в Java EE

Инфраструктура завязана на RMI (Java API, позволяющий вызывать методы удаленных объектов)

Благодаря CDI не важно, где физически расположен вызываемый компонент — за его вызов отвечает контейнер.

Клиент имеет прокси, обращается с ней как с нужным объектом. Прокси перенаправляет его вызовы куда следует: если нужный компонент находится локально, идёт к нему обращение по ссылке; если удалённо (в другой JVM) - необходима сериализация передаваемых данных.

принцип прозрачного нахождения. мы можем писать код не думая о том, где находится объект, его будет вызывать контейнер. для реализации в java ее нужно реализовать стаб на стороне клиента и скелетон на стороне сервера. Контейнер будет таскать объекты с помощью rmi
Для клиента создаётся видимость целостности приложения, как будто оно не распределено по разным серверам с разными JVM, то есть для использования Remote EJB ему не надо делать дополнительных движений. 

### 164. Rest в Spring. Spring RESTful

В спринг реализован rest путем RestController, все контроллеры, лежащие внутри класса, помеченного такой аннотацией будут автоматически сериализовать возвращаемые данные в JSON, так же можно указывать параметры в маппингах контроллеров, например @RequestMapping(“/get/{entity}”), которые можно получать вместе с запросом. Под коробкой такого веб приложения может лежать Spring MVC или WebFlux. Также в Спринге есть REST клиент в различных реализациях RestTemplate, WebClient

```java
package com.example.restservice;

import java.util.concurrent.atomic.AtomicLong;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class GreetingController {

	private static final String template = "Hello, %s!";
	private final AtomicLong counter = new AtomicLong();

	@GetMapping("/greeting")
	public Greeting greeting(@RequestParam(value = "name", defaultValue = "World") String name) {
		return new Greeting(counter.incrementAndGet(), String.format(template, name));
	}
}
```

A key difference between a traditional MVC controller and the RESTful web service controller shown earlier is the way that the HTTP response body is created. Rather than relying on a view technology to perform server-side rendering of the greeting data to HTML, this RESTful web service controller populates and returns a Greeting object. The object data will be written directly to the HTTP response as JSON.

### 165. Создать бин, конфигурируемый аннотациями, с именем myBean, контекст которого равен контексту другого бина - myOtherBean

```java

@ManagedBean(name=”myOtherBean”)
@ApplicationScoped
class MyManagedBean {
	@ManagedProperty(value="#{myBean}")
    	private NeededBean neededBean;

    public NeededBean getNeededBean()    {
           return neededBean;
    }
    
    public void setNeededBean(NeededBean neededBean)    {
        this.neededBean = neededBean;
    }
}

```

```java
@ManagedBean(name=”myBean”)
@NoneScoped
class MyManagedBean {
	
}
```

### 166. Жизненный цикл Session beans

![alt-text](resources/lifecycleOfSessionBeans.png)

В плюс к этому ещё есть пулы экземпляров бинов. Так как клиенты обращаются к проксям, реализующим бизнес-интерфейс, а с реальными объектами бинов дел не имеют, с их жизненным циклом можно вытворять разные штуки. Вот что происходит для каждого из трёх видов сессионных бинов:

- Stateful - у каждого клиента своя прокси, ведущая на свой и только свой экземпляр бина, потому что клиенту важно состояние его бина
- Stateless - у каждого клиента один и тот же интерфейс, который каким-то образом уводит пользователя к одному из экземпляров бина из пула
- Singleton - единый интерфейс и единый экземпляр заставят вас поразвлекаться с concurrency

Аннотация @EJB служит для CDI и предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

### Жизненный цикл Stateless

- Не существует . В этом состоянии экземпляр компонента просто не существует.
- Готовое состояние . При первом запуске WebLogic Server создается несколько экземпляров компонента, которые помещаются в пул готовности. Контейнер может создавать больше экземпляров, если это необходимо для контейнера EJB.

#### Переход из состояния "не существует" в состояние готовности
Когда контейнер EJB создает экземпляр сеансового компонента без сохранения состояния для помещения в пул готовности, он вызывает метод обратного вызова public void setSessionContext (SessionContext ctx) . У этого метода есть параметр javax.ejb.SessionContext , который содержит ссылку на контекст сеанса, то есть интерфейс к контейнеру EJB, и может использоваться для ссылки на сам объект компонента сеанса. Полная информация о javax.ejb. SessionContext можно найти в вашей любимой документации J2EE и справочнике по API на http://java.sun.com .

После вызова метода обратного вызова setSessionContext контейнер EJB вызывает метод обратного вызова ejbCreate . Вы можете реализовать этот метод обратного вызова, например, для получения домашних интерфейсов других EJB, вызванных сессионным компонентом, как показано в разделе « Определение сеансового компонента» . Метод ejbCreate вызывается только один раз за время существования сеансового компонента и не привязан к вызову метода create клиентским приложением. Для сессионного компонента без сохранения состояния вызов createметод возвращает ссылку на экземпляр компонента, уже находящийся в готовом пуле; он не создает новый экземпляр компонента. Управление экземплярами сессионных компонентов без сохранения состояния полностью выполняется контейнером EJB.

#### Готовое состояние
Когда экземпляр компонента находится в состоянии готовности, он может обслуживать клиентские запросы; то есть выполнять методы компонентов. Когда клиент вызывает бизнес-метод, контейнер EJB назначает доступный экземпляр компонента для выполнения бизнес-метода. После завершения выполнения экземпляр сеансового компонента готов к выполнению другого бизнес-метода.

#### Переход от состояния готовности к состоянию несуществующего
Когда контейнер EJB решает уменьшить количество экземпляров сессионного компонента в готовом пуле, он подготавливает экземпляр компонента к сборке мусора. Непосредственно перед этим он вызывает метод обратного вызова ejbRemove . Если вашему сессионному компоненту необходимо выполнить какое-либо действие по очистке перед сборкой мусора, вы можете реализовать его с помощью этого метода обратного вызова. Метод обратного вызова не привязан к методу удаления, вызванному клиентом. Для сессионного компонента без сохранения состояния вызов метода remove делает недействительной ссылку на экземпляр компонента, уже находящийся в пуле готовности, но не перемещает экземпляр компонента из состояния готовности в состояние не существует, так как управление экземплярами сеансового компонента без сохранения состояния полностью выполняется контейнером EJB.

### Жизненный цикл Stateful

- Не существует . В этом состоянии экземпляр компонента просто не существует.
- Готовое состояние . Экземпляр компонента в состоянии готовности привязан к конкретному клиенту и участвует в диалоге.
- Пассивное состояние . Экземпляр компонента в пассивном состоянии пассивирован для экономии ресурсов.

#### Переход из состояния "не существует" в состояние готовности
Когда клиент вызывает метод create для сеансового компонента с отслеживанием состояния, контейнер EJB создает новый экземпляр и вызывает метод обратного вызова public void setSessionContext (SessionContext ctx) . У этого метода есть параметр javax.ejb.SessionContext , который содержит ссылку на контекст сеанса, то есть интерфейс к контейнеру EJB, и может использоваться для ссылки на сам объект компонента сеанса. Полная информация о javax.ejb. SessionContext можно найти в вашей любимой документации J2EE и справочнике по API на http://java.sun.com . После метода обратного вызова setSessionContextвызывается, контейнер EJB вызывает метод обратного вызова ejbCreate, который соответствует сигнатуре метода create .

#### Состояние готовности
Экземпляр bean-компонента с отслеживанием состояния в состоянии готовности привязан к конкретному клиенту на время его разговора. Во время этого разговора экземпляр может выполнять методы компонента, вызванные клиентом.

#### Активация и пассивация
Для более оптимального управления ресурсами контейнер EJB может пассивировать неактивный экземпляр сессионного компонента с сохранением состояния, переводя его из состояния готовности в пассивное состояние. Когда экземпляр сессионного компонента пассивируется, его (непреходящие) данные сериализуются и записываются на диск, после чего экземпляр компонента удаляется из памяти. Непосредственно перед сериализацией вызывается метод обратного вызова ejbPassivate . Если вашему сессионному компоненту необходимо выполнить некоторую пользовательскую логику перед пассивацией, вы можете реализовать ее с помощью этого метода обратного вызова.

Если после пассивации клиентское приложение продолжает диалог, вызывая бизнес-метод, пассивированный экземпляр bean-компонента повторно активируется; его данные, хранящиеся на диске, используются для восстановления состояния экземпляра компонента. Сразу после восстановления состояния вызывается метод обратного вызова ejbActivate . Если ваш сеансовый компонент должен выполнять некоторую пользовательскую логику после активации, вы можете реализовать ее с помощью этого метода обратного вызова. Вызывающая сторона (клиентское приложение или другой EJB) экземпляра сеансового компонента не будет знать о пассивации (и реактивации).

Если сессионный компонент с отслеживанием состояния настроен для использования алгоритма типа кеша NRU (не использовавшегося недавно), то время ожидания сеансового компонента может истечь в пассивном состоянии. Когда это происходит, он переходит в состояние не существует; то есть он удален. Перед удалением контейнер EJB вызовет метод обратного вызова ejbRemove . Если сессионный компонент с отслеживанием состояния настроен на использование алгоритма LRU (последний раз использованный), он не может истекать по тайм-ауту в пассивном состоянии. Вместо этого этот сессионный компонент всегда переводится из состояния готовности в пассивное состояние по истечении времени ожидания.

Точный таймаут можно установить с помощью атрибута idleTimeoutSeconds в аннотации @Session . Алгоритм типа кеша может быть установлен с помощью атрибута cacheType в той же аннотации.

#### Переход от состояния готовности к состоянию несуществующего
Когда клиентское приложение вызывает метод удаления для сессионного компонента с отслеживанием состояния, оно прекращает диалог и сообщает контейнеру EJB удалить экземпляр. Непосредственно перед удалением экземпляра контейнер EJB вызовет метод обратного вызова ejbRemove . Если ваш сессионный компонент должен выполнить некоторую пользовательскую логику перед удалением, вы можете реализовать ее с помощью этого метода обратного вызова.

Неактивный сеансовый компонент с отслеживанием состояния, настроенный для использования алгоритма типа кэш-памяти NRU (не использовавшийся недавно), может истекать по тайм-ауту, что переводит его в состояние не существует, то есть он удаляется. Перед удалением контейнер EJB вызовет метод обратного вызова ejbRemove . Если сессионный компонент с отслеживанием состояния, настроенный для использования алгоритма LRU (последний раз использовавшийся), истекает по времени, он всегда переходит в пассивное состояние и не удаляется.

Точный таймаут можно установить с помощью атрибута idleTimeoutSeconds в аннотации @Session. Алгоритм типа кеша может быть установлен с помощью атрибута cacheType в той же аннотации.

### 168. Jsx, особенности, применение в реакт

JSX — синтаксис, похожий на XML / HTML, используемый в React, расширяет ECMAScript, так что XML / HTML-подобный текст может сосуществовать с кодом JavaScript / React. Синтаксис предназначен для использования препроцессорами (т. е. транспилерами, такими как Babel), чтобы преобразовать HTML-подобный текст, найденный в файлах JavaScript, в стандартные объекты JavaScript. Примеры(с и без):
```javascript
function Button (props) {
 // Возвращает DOM элемент. Например:
 return <button type="submit">{props.label}</button>;}
// Отрисовываем компонент Button в браузере
ReactDOM.render(<Button label="Save" />, mountNode)


function Button (props) {
 return React.createElement(
   "button",
   { type: "submit" },
   props.label
 );
}
// Чтобы использовать Button вы должны написать что-то наподобие
// этого:
ReactDOM.render(
 React.createElement(Button, { label: "Save" }),
 mountNode
);

```
### 169. Написать правило навигации, для перехода с одной страницы на другую по нажатию кнопки

```xml
<navigation-rule>
	<from-view-id>index.xhtml</from-view-id>
    <navigation-case>
        <from-outcome>main</from-outcome>
        <to-view-id>main.xhtml</to-view-id>
        <redirect/>
    </navigation-case>
</navigation-rule>

```

### 170. Бизнес-логика, ejb, структура и классы. Локальные и удаленные что-то.

Пользователь хочет вызывать методы, но из-за того, что приложение может быть развёрнуто в разных JVM одновременно, контейнер должен иметь возможность управлять этими вызовами. Поэтому клиенту достаются не реальные объекты, а прокси, которые создаются контейнером и перенаправляют запросы куда надо. Чтобы контейнер знал, какие методы бина (класса, реализующего бизнес-логику, то есть Model из MVC) включать в прокси, нужен так называемый бизнес-интерфейс - интерфейс, содержащий объявления этих самых методов. Естественно, бин должен будет его реализовывать.
 
EJB делятся на два вида (есть и другие деления, о них позже): Local и Remote. Когда бин помечается как локальный, мы договариваемся с контейнером, что данный бин будет вызываться только в пределах одной JVM, то есть его можно будет использовать по ссылке и ничего не придётся сериализовывать, что неплохо ускорит работу приложения. Раз уж на то пошло, то для локальных бинов даже необязательно делать бизнес-интерфейс, если пометить его аннотацией @LocalBean. А вот Remote бины имеют все прелести RMI: передачу по значению а не по ссылке, а значит нужна сериализация + обязательны бизнес-интерфейсы. 

1. Bean has a @LocalBean annotation -> bean has a no-interface view
2. Bean has a @Local annotation -> bean has a local view
3. Bean has a @Remote annotation -> bean has a remote view
4. Bean has no view annotations, but directly implements an interface which has a @Local annotation -> bean has a local view
5. Bean has no view annotations, but directly implements an interface which has a @Remote annotation -> bean has a remote view
6. Bean has no view annotations, but directly implements an interface which has no view annotations -> bean has a local view
7. Bean has no view annotations, and implements no interfaces -> bean has a no-interface view

Также EJB делятся на Session и Message-Driven. Вызов методов первых происходит напрямую, а вторых - по возникновению событий и только так (типа один большой бин-слушатель). MDB нас особо не интересуют.

Session бины делятся на Stateful, Stateless и Singleton. Весьма очевидно из названий в чём их особенности, но если не слишком, то чекайте 

### 2. SPA

Одностраничное приложение - приложение, которое фактически содержит только одну html страницу и несколько разных представлений, подгружаемых динамически. 
- экономит трафик
- переносит часть нагрузки с серверов на клиента 
- спасает клиента от сбоев в сети 
- использует browser history api для переадресации и кнопочки назад. 
- может работать в оффлайн режиме
- быстрый отклик (подражаение десктопным приложениям)
- богатый пользовательский интерфейс, так называемый User Experience. Так как web-страница одна, построить богатый, насыщенный пользовательский интерфейс гораздо проще. Проще хранить информацию о сеансе, управлять состояниями представлений (views) и управлять анимацией (в некоторых случаях).


#### Минусы

- Долгая первая загрузка
- Нет поддержки javascript == нет приложения
- SEO
- Большая часть взаимодействия на клиенте

### 171. Что-то с БД, JPA Criteria api. Найти всех студентов со средним баллом ниже 4.0 и удалить

Criteria API - это когда вместо sql-подобных запросов в виде строки делается серия вызовов методов строителя запросов, определяющих новый запрос.

```java

@Stateless
@LocalBean
public class StudentManagement {
    @PersistenceContext
    private EntityManager em;

    public void deleteStudents() {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaDelete<Student> delete = cb.createCriteriaDelete(Student.class);
        Root e = delete.from(Student.class);
        delete.where(cb.lessThan(e.get("avgGrade"), 4.0));
        this.em.createQuery(delete).executeUpdate();
    }
}

```

### 172. stateless stateful singleton session bean. Сходство отличия итп

Stateful ассоциируются с конкретным пользователем + могут уходить в спячку (с возможностью умереть по достижении тайм-аута) чтобы ждать возвращения пользователя. Посему у каждого юзера своя прокси на свой ejb. 

Stateless могут менять обслуживаемых пользователей, поэтому в них не надо хранить состояние (хоть никто и не запретит). Благодаря такой особенности, нагрузку на сервера проще распределить между юзерами.

Stateless or Singleton:

Я бы выбрал Stateless - сервер может генерировать множество экземпляров bean-компонента и обрабатывать входящие запросы параллельно.

Синглтон звучит как потенциальное узкое место - значение @Lock по умолчанию - @Lock (WRITE), но может быть изменено на @Lock (READ) для компонента или отдельных методов.


@Stateless позволит вам иметь несколько копий, готовых для обработки в JVM (столько, сколько позволяет память и размер пула), где, как @Singleton, в JVM есть только одна копия, даже если одна может поддерживать несколько параллельных потоков, работающих против нее.

С точки зрения производительности @Singleton было бы лучше, при условии, что используемые ресурсы позволяют длительный доступ. Однако в распределенной среде иногда происходят плохие вещи, например, могут выйти из строя ссылки базы данных или сети.

С @Stateless бином доступ более недолговечный. Кроме того, в случае сбоя он просто возродится и попытается установить новое соединение с ресурсом. Если что-то подобное происходит с синглтоном, то синглтон должен обработать его, не требуя перезапуска приложения, потому что @PostConstruct вызывается только один раз для каждой JVM.

Я бы предпочел немного отказоустойчивости по сравнению с производительностью в большинстве ситуаций, особенно в системах, которые я не контролирую.

### 173. компоненты react. Что такое итп. Умные и глупые компоненты

#### Глупые компоненты:
- не зависят от остальной части приложения, например Flux actions или stores
- часто содержатся в this.props.children
- получают данные и колбэки исключительно через props
- имеют свой css файл
- изредка имеют свой state
- могут использовать другие глупые компоненты
- примеры: Page, Sidebar, Story, UserInfo, List

#### Умные компоненты:
- оборачивает один или несколько глупых или умных компонентов
- хранит состояние стора и пробрасывает его как объекты в глупые компоненты
- вызывает Flux actions и обеспечивает ими глупые компоненты в виде колбэков
- никогда не имеют собственных стилей
- редко сами выдают DOM, используйте глупые компоненты для макета
- римеры: UserPage, FollowersSidebar, StoryContainer, FollowedUserList

А теперь мои умные и глупые:  
Умные - могут изменять данные  
Глупые - не могут

### 174. jsf поле многострочного ввода в которое можно ввести только строчные английские буквы

```xhtml
<h:inputTextArea> <f:validateRegex pattern =”^[a-z]+$”/></h:inputTextArea>
```


# Видео по Spring:

1) Мы за SIngle Responsibility и за принцип разделения интерфейсов, поэтому все выносим в отдельные интерфейсы  
    Инициализируем реализации интерфейсов Announcer и Policemen в ПОЛЯХ класса CoronaDesinfector
    ```java
    private Announcer announcer = new ConsoleAnnouncer(); 
    ```

2) У CoronaDesinfector в итоге не single responsibility, а много responsibility (>7), так как мы отвечаем за создание объектов классов (которые в полях)  
    Выбираем реализацию нужную нам

3) Пилим Factory, который создавал бы объекты за нас
    ```java
    private Announcer announcer = ObjectFactory.getInstance().createObject(Announcer.class); 
    ```
4) в Factory в методе createObject выбирается нужная реализация на основании класса Config, который будет сканировать пакеты

5) в Config есть map с реализациями, если там содержится нужный интерфейс и реализация, пакеты еще раз сканироваться не будут

6) Объект мы создали, но нужно ведь и настроить (вдруг в классе есть fields, которые нужно заинжектить (из файлов конфигов, к примеру))

7) Для настройки объекта используется анализ огромного количества аннотаций (куча if'ов). Поэтому для каждой аннотации свой конфигуратор. Класс ObjectFactory за настройку объекта отвечать не должен   
    А в Factory будет храниться лист конфигураторов

8) Это не инверсия контроля, это lookup
   ```java
   private Announcer announcer = ObjectFactory.getInstance().createObject(Announcer.class); 
   ```
   Мы создаем фабрику каждый раз, мы дергаем статиеский метод getInstance() и делаем это каждый раз, когда нужно что-то создать
      -> нужен синглтон (кэшировать синглтоны). 
      
9) Домашние синглтоны это плохо, так как одни синглтоны могут юзать другые. Сервису A нужен сервис B, cервису B - сервис C и все они будут юзать getInstance()  
   Все домашние синглтоны между собой связаны статическими методами, хрен, что подложишь, хрен. что подменишь
   Синглтон это классно, но реализовывать его плохо. Нужно кешировать синглтоны! юзая Context
   
10) Мы не инициализируем Announcer и Policemen сами, мы юзаем аннотацию @InjectByType и просим конфигуратор InjectByTypeObjectConfigurator все сделать (проинициализировтаь за нас)  
    Конфигуратор и main могут юзать getInstance() у фабрики, это норма

11) Фабрика в конструкторе получает Context

12) PostConstruct прогоняется в Factory, так как это вторичный конструктор и это логично. а Ordering у конфигураторов это плохо

13) Хочется добавить что-то в метод объекта Recommendator, видоизменив поведение. Proxy Pattern используется для этого. Фабрике будет пох, так как интерфейс общий
    -> новый конфигуратор -> еще один лист конфигураторов в фабрике (ProxyConfigurator)

![alt-text](resources/finalSituationSpring.png)

# Важное отличие Spring от Java EE:

В Spring есть Runtime. Получается RunTime управляет компонентами. Умный RunTime собирает все вместе и управляет сервером.

А в EE сервер приложений управляет RunTime. Мы говорим серверу приложений, что мы хотим, чтобы он сделал 

DI работает похожим образом, но в Spring мы имеем более гибку конфигурационную тему 

А в EE ориентация не на конфигурацию и хитрую компоновку приложения, а на то, что у нас умный RunTime = сервер приложений и сервер приложений обеспечивает рзные полезные фишечки

в EE менее удобная конфигурация, но зато, если мы запилили кластер, приложене по нему размажется. Просто потому что кластер провайдится Application сервером и он у руля (все приложение хостится на Application Server). Нет внешней по отношению к серверу конфигурации, которая им управляет 

В EE можно использовать Remote для бинов прозрачно через аннотацию

В построение Spring приложения - трехфазовый конструктор. На объекты в любом случае накладываются срезы


--BeanFactoryPostProcessor--

1) Конструктор Java

--BeanPostProcessor--

AutowiredBeanPostProcessor 

2) @PostConstruct сеттятся все поля (все бины перерабатываются и отрабатываются @Autowired и прочие прочие прочие аннотации, под которые написаны обработчики этих аннотаций), -> все бины лежат в мапе бинов и готовы к действию

--BeanPostProcessor

3) event у Spring ApplicationContextRefreshed: 
- порождение Proxy объекта для бинов.
- Запихивание наших бинов внутрь Proxy объектов 
- наращивание срезов (аспектов) на начало/конец вызова метода

Spring Framework активно использует BeanPostProcessor для проксирования и др., поэтому, если вам необходима поддержка такой функциональности, как AOP и транзакций, то при использовании BeanFactory необходимо добавить вручную регистрацию BeanPostProcessor и BeanFactoryPostProcessor, как показано ниже:

Разница между @Inject, @Autowire и @Resource?

@Autowired: аннотация Spring (в отличие от @Inject и @Resource), которая вводит ресурс по типу, то есть по классу интерфейса аннотированного поля или подрядчика. Если у нас мало реализаций интерфейса или подкласса, мы можем сузить выбор с помощью аннотации @Qualifier, чтобы избежать двусмысленности. Для резервного совпадения имя bean-компонента считается значением квалификатора по умолчанию. Хотя вы можете использовать это соглашение для ссылки на конкретные bean-компоненты по имени, @Autowired в основном относится к инъекции, управляемой типом, с дополнительными семантическими квалификаторами.

@Inject:Аннотация на основе JSR-330 (внедрение зависимостей для Java) определяет вводимые конструкторы, методы и поля. Эта аннотация является почти полной заменой аннотации Spring @Autowired. Таким образом, вместо использования аннотации @Autowired, специфичной для Spring, вы можете использовать @Inject. Одно из различий между @Autowired и @Inject заключается в том, что @Inject не имеет обязательного поля, поэтому, если мы не сможем найти подходящий объект для инъекции, он потерпит неудачу, в то время как @Autowired может использовать required = false и разрешить пустое поле (только если необходимо!). Преимущество аннотации @Inject в том, что вместо того, чтобы напрямую вводить ссылку, вы можете попросить @Inject внедрить Provider. Интерфейс Provider позволяет, среди прочего, ленивую инъекцию ссылок на bean-компонент и внедрение нескольких экземпляров bean-компонента. Если у нас мало реализаций интерфейса или подкласса, мы можем сузить выбор, используя аннотацию @Named, чтобы избежать двусмысленности. @Named аннотация работает так же, как Spring @Qualifier

@Resource: аннотация на основе JSR-250. @Resource очень похож на @Autowired и @Inject, но основное различие заключается в путях выполнения, используемых для определения необходимого bean-компонента для внедрения. @Resource сузит поиск сначала по имени, затем по типу и, наконец, по квалификаторам (игнорируется, если совпадение найдено по имени). @Autowired и @Inject сузят поиск сначала по типу, затем по квалификатору и, наконец, по имени.

Их единственное различие заключается в их назначении, т.е. @Controller используется в Spring MVC для определения контроллера, который является сначала компонентом Spring, а затем контроллером. Точно так же @Service используется для аннотированных классов, которые содержат бизнес-логику на уровне сервиса, а @Repository используется на уровне доступа к данным.

Read more: https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html#ixzz6jE8nybWX


